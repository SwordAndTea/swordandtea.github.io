<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="xiangwei&#39;s blog">
<meta property="og:url" content="http://swordandtea.github.io/page/6/index.html">
<meta property="og:site_name" content="xiangwei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SwordAndTea">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>xiangwei's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiangwei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/" class="post-title-link" itemprop="url">Linux网络编程基础API</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 11:04:29" itemprop="dateCreated datePublished" datetime="2020-11-06T11:04:29+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-16 14:49:05" itemprop="dateModified" datetime="2021-03-16T14:49:05+08:00">2021-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h1><p>字节序分为大端字节序和小端字节序。现代PC大多采用小端字节序，<code>因此小端字节序又称为主机字节序</code>。</p>
<p>当两台字节序不同的主机之间进行通信时，由于字节序的不同就会导致对数据的错误解释。但是接受端也不知道发送端发送过来的数据的字节序到底是大端还是小端，解决办法是：<code>发送端总是把要发送的数据转化为大端字节序数据后再发送</code>，而接受端可以根据自身采用的字节序决定是否对接收到的数据进行转换。因此<code>大端字节序也称为网络字节</code>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>另外需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由Java编写）通信，也要考虑字节序的问题（Java虚拟机采用大端字节序）。</p>
<p>在linux中提供了下面4个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> __hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> __hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> __netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> __netshort)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示”host to network long”，即将32位无符号数从主机字节序转换为网络字节序数据。</p>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h2 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h2><p>Linux C  Socket网络编程接口表示socket地址的结构体sockaddr，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">  	<span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sa_family成员时地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型对应。常见的协议族(protocal family，也称domain，见后文)和对应的地址族如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址族</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">AF_UNIX</td>
<td style="text-align:center">UNIX本地协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">TCP/IPv4协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">TCP/IPv6协议族</td>
</tr>
</tbody>
</table>
</div>
<p>宏PF_*和AF_*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>sa_data成员用于存放socket地址值。但是，不同协议族的地址值具有不同的含义和长度，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td>文件的路径名，长度可到108字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td>16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td>16bit端口号，32bit流标识，128bit IPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
</div>
<p>由上表可见，<code>14字节的sa_data根本无法完全容纳多数协议族的地址值</code>。因此，Linux定义了下面这个新的通用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体不仅能提供了足够大的空间用于存放地址值，而且是内存对齐的(这是__ss_align成员的作用)。</p>
<h2 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h2><p><code>上面的两个通用socket地址结构体显然都不好用</code>，所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地协议族使用如下专用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* 地址族: AF_UNIX */</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];     <span class="comment">/* 文件路径名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TCP/IP协议族有socket_in和sockaddr_in6两个专业socket地址结构体，它们分别用于IPv4和IPv6：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockadddr_in</span>&#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sun_family;		<span class="comment">/* 地址族: AF_INET */</span></span><br><span class="line">  	<span class="keyword">u_int16_t</span> sin_port; 			<span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>		/* <span class="title">IPv4</span>地址结构体 */</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  	<span class="keyword">u_int32_t</span> s_addr;					<span class="comment">/* IPv4地址，要用网络字节序号表示 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sin6_family;			<span class="comment">/* 地址族: AF_INET6 */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;					<span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">  	<span class="keyword">u_int32_t</span> sin6_flowinfo;			<span class="comment">/* 流信息，应设置为0 */</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>		<span class="comment">/* IPv6地址结构体 */</span></span><br><span class="line">  	<span class="keyword">u_int32_t</span> sin6_scope_id;			<span class="comment">/* scope ID, 尚处于实验阶段 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>]; 		<span class="comment">/* IPv6地址，要用网络字节序表示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket类型sockaddr(强制转换即可)，因为socket编程接口使用的地址参数的类型都是sockaddr</code>。</p>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分10进展字符串表示IPv4地址，以及用16进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数才能使用。而记录日志时则相反，我们要把整数表示的IP地址转为可读的字符串。Linux提供了3个用于IP地址形式转化的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>; <span class="comment">/*in_addr 是 __uint32_t 的typdef*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, struct in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Inet_addr函数将用点十进制字符串表示的IPv4地址转为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE</p>
</li>
<li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败时返回0</p>
</li>
<li><p>Inet_ntoa函数将用网络字节序表示的IPv4地址转化为用点十进制表示的IPv4地址。<font color="red">但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的</font>，下面的代码揭示了其不可重入性：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *value1 = inet_ntoa(inet_addr(<span class="string">&quot;1.2.3.4&quot;</span>));</span><br><span class="line"><span class="keyword">char</span> *value2 = inet_ntoa(inet_addr(<span class="string">&quot;10.194.71.60&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 1: %s\n&quot;</span>, value1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 2: %s\n&quot;</span>, value2);</span><br><span class="line"><span class="comment">//最后打印的结果为：</span></span><br><span class="line">address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数相同的功能，并且它们<font color="red">同时适用于IPv4地址和IPv6地址。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *scr, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>inet_pton函数用于将字符串表示的IP地址src(用点十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址)转化成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败时返回0。</p>
</li>
<li><p>inet_ntop函数将网络字节序整数表示的IP地址，转化为IP字符串。前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定字符串dst目标存储单元的大小。有两个宏能帮助我们快速指定这个大小(分别用于IPv4和IPv6)：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<h1 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h1><p>UNIX/Linux的一个思想就是：所有的东西都是文件。socket也不例外，他就是可读、可写、可控制</p>
<p>可关闭的文件描述符。</p>
<p>下面的socket系统调用可创建一个socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domin, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>domin 参数告诉系统使用哪个底层协议族。对于TCP/IP协议族而言，该参数应该设置为PF_INET(Protocal Family of Internet，用于IPv4)或PF_INET6(用于IPv6)，对于UNIX本地协议族而言，该参数应设置为PF_UNIX</li>
<li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_DGRAM（数据报）服务。对于TCP/IP协议族而言，SOCK_STEAM表示传输层使用TCP协议，SOCK_DGRAM表示传输层使用UDP协议。</li>
<li>protocol参数是在前两个参数构成的协议集合下，在选择一个具体的协议。不过这个值通常都是唯一，几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</li>
</ul>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<h1 id="绑定socket"><a href="#绑定socket" class="headerlink" title="绑定socket"></a>绑定socket</h1><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。需要将一个socket与socket地址进行绑定。通常在服务器端中，我们需要进行socket地址绑定，因为只有绑定后，客户端才能知道该如何连接它。客户端通常不需要绑定socket地址，而是采用匿名方式，即使用操作系统自动分配的socket地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bind将addr所指的socket地址分配给未绑定的sockfd文件描述符，addrlen参数指出该socket地址长度。</p>
<h1 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h1><p>socket被命名之后，还不能马上接收客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户端连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd参数指定被监听的sock文件描述符</li>
<li>backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接。客户端也将受到ECONREFUSED错误。在内核版本2.2之前的linux中，backlog参数是值所有处于半连接状态和完全连接状态的socket上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket上限，处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义</li>
</ul>
<p>listen成功返回0，失败时返回-1并设置errno</p>
<h1 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h1><p>下面的系统调用从listen的监听队列中接收一个连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd参数是执行过listen系统调用的监听socket文件描述符。addr参数用来获取客户端的socket地址，该socket地址的长度由addrlen参数返回。</p>
<p><code>accept成功时返回一个新的连接socket文件描述符</code>，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1，并设置errno。</p>
<p><code>当当前监听队列中没有连接时，accept会被阻塞。</code></p>
<p><code>accept只是从监听队列中取出连接，而不管取出连接后，连接处于何种状态（连接或者断开）</code>。</p>
<h1 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h1><p>在客户端需要通过一下系统调用来主动与服务器建立连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklent_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd是由socket系统调用返回的socket文件描述符</li>
<li>serv_addr是服务器监听的socket地址</li>
<li>addrlen参数则serv_addr的长度</li>
</ul>
<p>connect成功时返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno，其中两种常见的errno是ECONNREFUSED和ETIMEOUT，它们的含义分别是连接被拒绝和连接超时。</p>
<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><p>关闭连接实际上就是关闭连接对应的socket文件描述符，可以通过调用关闭普通文件描述符的系统调用来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不过，<code>close系统调用并非总是立即关闭一个连接</code>，而是将fd的引用记数减一，只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，<code>一次fork系统调用默认将父进程中打开的socket文件描述符的引用计数加1</code>。如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用shutdown系统调用（相对于close来说，它是专门为网络编程设计的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<p>howto参数决定了shutdown的行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">可选值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SHUT_RD</td>
<td style="text-align:center">关闭sockfd上读的这一半，应用程序不能再针对socket文件描述符号执行读操作，并且该socket接收缓冲区中的数据都将被丢弃</td>
</tr>
<tr>
<td style="text-align:center">SHUT_WR</td>
<td style="text-align:center">关闭sockfd上写的这一半。sockfd的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socke文件描述符执行写操作。这种情况下，连接处于半关闭状态。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_RDWR</td>
<td style="text-align:center">同时关闭sockfd上的读和写</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，shutdown能分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。shutdow成功时返回0，失败时返回-1，并设置errno。</p>
<h1 id="socket服务端，客户端示例"><a href="#socket服务端，客户端示例" class="headerlink" title="socket服务端，客户端示例"></a>socket服务端，客户端示例</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create socket fd fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sock_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_addr</span>;</span></span><br><span class="line">    sock_addr.sin_family = AF_INET;<span class="comment">//ipv4地址协议族</span></span><br><span class="line">    sock_addr.sin_port = htons(<span class="number">22996</span>); <span class="comment">//转换为网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;sock_addr.sin_addr);<span class="comment">//将字符串类型的地址转换为网络类型地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock_fd, <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr *&gt;(&amp;sock_addr), <span class="keyword">sizeof</span>(sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    ret = listen(sock_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;listen fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_socklen;</span><br><span class="line">        ret = accept(sock_fd, &amp;client_addr, &amp;client_socklen);</span><br><span class="line">        <span class="keyword">if</span> (client_socklen == <span class="keyword">sizeof</span>(struct sockaddr_in)) &#123;<span class="comment">//如果是ipv4连接</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">client_ipv4_sock</span> =</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *&gt;</span>(&amp;client_addr);</span><br><span class="line">            <span class="keyword">char</span> client_ipv4_str[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connection from &quot;</span></span><br><span class="line">                      &lt;&lt; inet_ntop(client_ipv4_sock-&gt;sin_family, &amp;client_ipv4_sock-&gt;sin_addr, client_ipv4_str, INET_ADDRSTRLEN) <span class="comment">//网络ip地址转换为字符串表示</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                      &lt;&lt; ntohs(client_ipv4_sock-&gt;sin_port) <span class="comment">//网络字节序端口号转主机字节序</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_sock_addr</span>&#123;</span>&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    server_sock_addr.sin_port = htons(<span class="number">22996</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(sock_fd, <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr*&gt;(&amp;server_sock_addr), <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h2><p>对文件的读写操作read和write同样适用于socket，但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次recv，才能读取到完整的数据。<code>recv可能返回0，这意味着通信对方已经关闭连接了</code>。recv出错时返回-1并设置errno。</li>
<li>send往sockfd上写入数据，buf和len参数分别指定缓冲区的位置和大小。send成功时返回实际写入的数据长度，失败则返回-1并设置errno。</li>
</ul>
<p>recv和send函数中的flag参数为数据收发提供了额外的控制，它可以取下表所示选项中的一个或几个的逻辑或</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项名</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">send</th>
<th style="text-align:center">recv</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MSG_CONFIRM</td>
<td style="text-align:center">指示数据链路层协议持续监听对方的回应，直到得到答复，它仅能用于SOCK_DGRAM和SOCK_RAW类型的socket</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_DONTROUTE</td>
<td style="text-align:center">不查看路由表，直接将数据发送给本地局域网络内的主机。这表示发送者确切地知道目标主机就在本地网络上</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_DONTWAIT</td>
<td style="text-align:center">对socket的此次操作时非阻塞的。socket的读写操作默认是阻塞的。</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_MORE</td>
<td style="text-align:center">告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送。这样可防止TCP发送过多小的报文段，从而提高效率</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_WAITALL</td>
<td style="text-align:center">读操作仅在读取指定数量的字节后才返回</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_PEEK</td>
<td style="text-align:center">窥探读缓存的数据，此次读操作不会导致这些数据被清除</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_OOB</td>
<td style="text-align:center">发送或接收紧急数据</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_NOSIGNAL</td>
<td style="text-align:center">往读端关闭的管道或者socket连接中写数据不引发SIGPIPE信号</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
</div>
<h2 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h2><p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">sockelen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklent_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数scr_addr所指的内容，addrlen参数则指定该地址的长度。</p>
<p>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接受端的socket地址，addrlen参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均于send/recv系统调用的flags参数及返回值相同。</p>
<p>另外，recvfrom/sendto系统调用也可以用于面向连接(STREAM)的socket数据读写，只需要把最后两个参数都设置为NULL即可。</p>
<h2 id="带外标记检查"><a href="#带外标记检查" class="headerlink" title="带外标记检查"></a>带外标记检查</h2><p>当Linux内核检查到TCP紧急标志时，将通知应用程序有带外数据需要接受。内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。但是，即使应用程序得到了有外带数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据，可以通过以下函数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockadmark判断sockfd是否处于带外标记，即下一个读取到的数据是否是带外数据，如果是，sockatmark返回1，此时就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h1 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h1><p>Linux中有下面两个系统调用是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd参数指定被操作的目标socket文件描述符。level参数指定要操作哪个协议的选项，比如说IPv4、IPv6、TCP等。option_name参数则指定选项的名字。</p>
<p>下表列举了socket通信中几个比较常用的socket选项。option_value和option_len参数分别是被操作选项的值和长度。不同的选项具有不同类型的值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">level</th>
<th style="text-align:center">option name</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOL_SOCKET（通用socket选项，与协议无关）</td>
<td style="text-align:center">SO_DEBUG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">打开调试信息</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_REUSEADDR</td>
<td style="text-align:center">int</td>
<td style="text-align:center">重用本地地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_TYPE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">获取socket类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_ERROR</td>
<td style="text-align:center">int</td>
<td style="text-align:center">获取并清除socket错误状态</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_DONTROUTE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">不查看路由表，直接将数据发送给<font color="orange">本地局域网内</font>的主机。含义和send方法的MSG_DONTROUTE标志类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVBUF</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP接收缓冲区大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDBUF</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP发送缓冲区大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_KEEPALIVE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">发送周期性保活报文以维持连接</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_OOBINLINE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收到的带外数据将保留在普通数据的输入队列中，此时我们不能使用带MSG_OOB标志的读操作来读取带外数据，而应该像读取普通数据那样读取带外数据</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_LINGER</td>
<td style="text-align:center">linger结构体</td>
<td style="text-align:center">若缓冲区中还有数据待发送，则延迟关闭</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVLOWAT</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP接收缓存区低水位标记</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDLOWAT</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP发送缓存区低水位标记</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVTIMEO</td>
<td style="text-align:center">timeval</td>
<td style="text-align:center">接收数据超时</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDTIMEO</td>
<td style="text-align:center">timeval</td>
<td style="text-align:center">发送数据超时</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_TOS</td>
<td style="text-align:center">int</td>
<td style="text-align:center">服务类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IP_TTL</td>
<td style="text-align:center">int</td>
<td style="text-align:center">存活时间</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IPV6</td>
<td style="text-align:center">IPV6_NEXTHOP</td>
<td style="text-align:center">sockaddr_in6</td>
<td style="text-align:center">下一跳IP地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_RECVPKTINFO</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收分组信息</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_DONTFRAG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">禁止分片</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_RECVTCLASS</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收通信类型</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP_MAXSEG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP最大报文段大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">TCP_NODELAY</td>
<td style="text-align:center">int</td>
<td style="text-align:center">禁止Nagle算法</td>
</tr>
</tbody>
</table>
</div>
<p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno</p>
<p><code>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前对socket设置才有效</code>。这是因为连接socket只能有accept调用返回，<code>而accept从监听队列中接受的连接至少已经完成TCP三次握手的前两个步骤</code>，这说明服务器已经向客户端发出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。这种情况Linux给开发人员提供的解决方案是：<code>在调用listen前，对socket设置的这些socket选项，那么accept返回的连接socket将自动继承这些选项。这些选项选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SDNLOWAT、TCP_MAXSEG、TCP_NODELAY</code>。<code>而对客户端而言，这些socket选项则应该在调用connect函数之前设置</code>，因为connect调用成功返回之后，TCP三次握手已完成。</p>
<h2 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h2><p>对于处于TIME_WAIT状态的TCP连接，服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_addr</span>;</span></span><br><span class="line">sock_addr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip_string, &amp;sock_addr.sin_addr);</span><br><span class="line">sock_addr.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock, (sturct sockaddr *)&amp;sockaddr, <span class="keyword">sizeof</span>(sockaddr));</span><br></pre></td></tr></table></figure>
<p>经过setsockopt的设置后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h2 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a>SO_RCVBUF和SO_SNDBUF选项</h2><p>SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区的发送缓冲区的大小。不过，当我们用setsockopt来设置TCP的接受缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接受缓冲区的最小值时256字节，而发送缓冲区的最小值是2048字节（不过，不同的系统可能有不同的默认值）。系统这样做的目的，主要是确保一个TCP连接有足够的空闲缓冲区来处理拥塞（比如说快重传算法就期望TCP接收缓冲区能至少容纳4个大小为最大报文段长度的TCP报文段）。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。</p>
<h2 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h2><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记，它们一般被I/O复用系统调用用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总量大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据；当TCP发送缓冲区中的<code>空闲空间</code>（可以写入数据的空间）大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写数据。</p>
<p><code>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节</code>。</p>
<h2 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h2><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭socket时，close将立即返回，TCP模块负责将socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>设置（获取SO_LINGER选项值时），我们需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l_onoff;	<span class="comment">/* 开启（非0）还是关闭（0）该选项 */</span></span><br><span class="line">  <span class="keyword">int</span> l_linger;	<span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据linger结构中两个成员变量的不同值，close系统调用可能产生如下3中行为之一：</p>
<ul>
<li>l_onoff等于0，此时SO_LINGER选项不起作用，close用默认行为来关闭socket</li>
<li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将<code>丢弃</code>被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供一了异常终止一个连接的方法。</li>
<li>l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送玩所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送玩残留数据并得到对方确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/10/18/av_processing/audio/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/18/av_processing/audio/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">音频基础知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-18 20:09:39" itemprop="dateCreated datePublished" datetime="2020-10-18T20:09:39+08:00">2020-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-27 09:47:48" itemprop="dateModified" datetime="2022-03-27T09:47:48+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/audio/" itemprop="url" rel="index">
                    <span itemprop="name">audio</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="声音的产生"><a href="#声音的产生" class="headerlink" title="声音的产生"></a>声音的产生</h1><p>物体的<code>振动</code>产生声波，通过声音传播<code>介质</code>，传入人的鼓膜，再到听小骨，最后到听觉神经和大脑。</p>
<h1 id="声音的三要素"><a href="#声音的三要素" class="headerlink" title="声音的三要素"></a>声音的三要素</h1><ul>
<li>音调：由声音的频率决定，频率越高，声音越高，在乐音中，规定国际标准音高为440HZ，对应为音名为A4。</li>
<li>响度：又称为音量，音强，由振幅和人离声源距离决定。</li>
<li>音色：由发生物体材料和结构决定</li>
</ul>
<h1 id="模拟信号和数字信号"><a href="#模拟信号和数字信号" class="headerlink" title="模拟信号和数字信号"></a>模拟信号和数字信号</h1><h2 id="模拟音频信号"><a href="#模拟音频信号" class="headerlink" title="模拟音频信号"></a>模拟音频信号</h2><p>模拟音频信号是指时间轴连续，振幅轴连续的音频信号。自然界中存在的声音都算是模拟信号。</p>
<h2 id="数字音频信号"><a href="#数字音频信号" class="headerlink" title="数字音频信号"></a>数字音频信号</h2><p>时间和幅度都用离散的数字表示的信号。计算机只能存储和处理数字音频信号。</p>
<h2 id="A-D，D-A转换"><a href="#A-D，D-A转换" class="headerlink" title="A/D，D/A转换"></a>A/D，D/A转换</h2><ul>
<li>A/D转换：模/数转换，模拟信号转为数字信号</li>
<li>D/转换：数/模转换，数字信号转为模拟信号</li>
</ul>
<p>一般计算机处理音频信号的过程：对模拟信号进行采样、量化、编码、压缩转换成数字信号(设备一般是麦克风🎤和声卡)，然后对数字音频进行处理(变声、降噪、存储)，要播放音频的时候，将音频信号再还原成模拟信号播放(设备一般是声卡和扬声器🔉)。</p>
<h1 id="模拟信号到数字音频的转换-A-D转换"><a href="#模拟信号到数字音频的转换-A-D转换" class="headerlink" title="模拟信号到数字音频的转换(A/D转换)"></a>模拟信号到数字音频的转换(A/D转换)</h1><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>在模拟信号的时间轴上每隔一定时间抽取一个信号的幅度样本（时间轴数字化）。</p>
<ul>
<li>采样周期(T)：每隔T秒进行一次采样</li>
<li>采样频率(F)：一秒采样多少次</li>
<li>T = 1/F</li>
</ul>
<p><code>奈奎斯特采样定理</code>：如果想要通过数字信号重建原始模拟信号，那么采样频率必须大于模拟信号最高频率的两倍。（<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24490634/answer/490847222">解释</a>）</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p>由于在采样的时候，从模拟信号中获取到的幅度值其实本质上是个模拟量，这个模拟量可能是在计算机中是无法表示的，因为即使是使用浮点数，可以表示的值也都是离散的小数值，所以如果想要把采样过的值存储到计算机中进行处理，就需要将这些值转换为计算机可以处理的值。这个过程就是<code>量化</code>。</p>
<p>在将计算机不能存储和处理的值转换为计算机可以存储和处理的值的时候，最后计算机存储的结果可能和和实际的结果存在偏差。这就是<code>量化误差</code>。例如：某个计算只能存储int类型的值，但是某次采样到的数据的值为3.1，那么量化后的值应该为3，那么就产生了量化误差。</p>
<p>在音频信号处理中，<code>一般采用8bit、16bit、24bit</code>去存储经过量化过后的值(既可以使用整型数据，也可以使用浮点型数据，使用整型数据属于<strong>均匀量化</strong>，使用浮点数据属于<strong>非均匀量化</strong>)，使用的bit位数越多，可以表示的数据量就越多，可以表示的精度就越高。所以一般高清音质，高保真音质使用的24bit来存储量化后的值。</p>
<h2 id="PCM文件"><a href="#PCM文件" class="headerlink" title="PCM文件"></a>PCM文件</h2><h2 id="WAV文件"><a href="#WAV文件" class="headerlink" title="WAV文件"></a>WAV文件</h2><h1 id="音频编解码"><a href="#音频编解码" class="headerlink" title="音频编解码"></a>音频编解码</h1><p>音频编解码用于对量化后的音频数据进行压缩，方便对音频数据的存储和传输。</p>
<h2 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h2><h3 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h3><p>指音频(或视频)文件在单位时间内使用的数据量，单位一般是Kb/s或者Mb/s(注意是bit)。固定码率是指音频(或视频)文件在每一个单位时间内使用的数据量都相等。可变码率指不同单位时间内使用的数据量可以不同。</p>
<h3 id="压缩比"><a href="#压缩比" class="headerlink" title="压缩比"></a>压缩比</h3><p>原始数据和压缩后的数据总体的大小占比。一般来说，对于同一个原始数据，压缩比越小，码率越高，最后还原出来的数据越真实。</p>
<h2 id="三大主要音频编解码标准"><a href="#三大主要音频编解码标准" class="headerlink" title="三大主要音频编解码标准"></a>三大主要音频编解码标准</h2><h3 id="ITU"><a href="#ITU" class="headerlink" title="ITU"></a>ITU</h3><p>主要指定有线语言压缩标准，一般用于语音通话</p>
<h3 id="3GPP"><a href="#3GPP" class="headerlink" title="3GPP"></a>3GPP</h3><p>主要指定无线语音压缩标准</p>
<h3 id="MPEG"><a href="#MPEG" class="headerlink" title="MPEG"></a>MPEG</h3><p>主要指定音乐压缩标准等，例如MP3、AAC编解码标准</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/10/08/opengl/shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/08/opengl/shader/" class="post-title-link" itemprop="url">shader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-08 15:35:23" itemprop="dateCreated datePublished" datetime="2020-10-08T15:35:23+08:00">2020-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-16 11:07:45" itemprop="dateModified" datetime="2022-01-16T11:07:45+08:00">2022-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shader简介"><a href="#shader简介" class="headerlink" title="shader简介"></a>shader简介</h1><p>shader程序是OpenGL渲染管线中的某个步骤，他运行在GPU上。shader程序之间是隔离的，他们之间进行通信的唯一方式就是接受上游shader的输出作为自己的输入并输出新的数据作为下游的输入。</p>
<h1 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h1><p>shader程序是有GLSL这种编程语言编写的，shader总是以一个版本声明开始，接下来就是一系列的输入输出变量和uniform，然后就是main函数，每个shader程序都是以main函数作为程序入口，在main函数中处理输入变量并为输出变量赋值。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// process input(s) and do some weird graphics stuff</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// output processed stuff to output variable</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个shader的输入变量也叫做<strong>vertex attribute</strong>，由于硬件的限制，我们在shader中声明的vertex attribute的数量是有上限的，OpenGL保证至少可以声明16个4维变量，最大数量可以通过查询GL_MAX_VERTEX_ATTRIBS来获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum nr of vertex attributes supported: &quot;</span> &lt;&lt; nrAttributes &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>虽然大多数情况下最多值就等于最小值16。</p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>GLSL 有和C语言一样的基础类型: <code>int</code>, <code>float</code>, <code>double</code>, <code>uint</code> and <code>bool</code>。另外GLS也有两种container类型:  <code>vectors</code> 和 <code>matrices</code>。</p>
<h3 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h3><p>GLSL中的vector类型是可以容纳1、2、3 或者 4 个<strong>基本类型</strong>元素的container。它们有以下几种声明形式form (<code>n</code> 代表元素的个数):</p>
<ul>
<li><code>vecn</code>: the default vector of <code>n</code> floats.</li>
<li><code>bvecn</code>: a vector of <code>n</code> booleans.</li>
<li><code>ivecn</code>: a vector of <code>n</code> integers.</li>
<li><code>uvecn</code>: a vector of <code>n</code> unsigned integers.</li>
<li><code>dvecn</code>: a vector of <code>n</code> double components.</li>
</ul>
<p>我们可以使用 <code>.x</code>, <code>.y</code>, <code>.z</code> and <code>.w</code> 来分别获取到第一到第四个元素。大多数情况下，我们使用float类型的<code>vecn</code>就足够了。</p>
<p>vertor类型有一些很方便的赋值和构造方式：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> someVec;</span><br><span class="line"><span class="type">vec4</span> differentVec = someVec.xyxx;</span><br><span class="line"><span class="type">vec3</span> anotherVec = differentVec.zyw;</span><br><span class="line"><span class="type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line"><span class="type">vec2</span> vect = <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line"><span class="type">vec4</span> result = <span class="type">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec4</span> otherResult = <span class="type">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h3><p>//TODO: 看完后序章节后补全矩阵这部分。</p>
<h2 id="Ins-And-Outs"><a href="#Ins-And-Outs" class="headerlink" title="Ins And Outs"></a>Ins And Outs</h2><p>每个shader程序使用<code>in</code>和<code>out</code>关键字来标识输入输出，如果下一个shader的输入变量和上一个shader的输出变量名一致，OpenGL就会将变量的值传递过去（这个逻辑是在链接shader program的时候完成的）。</p>
<p>但是vertex shader和fragment shader有一些特殊的地方。因为vertex是渲染管线的第一个阶段，它的输入由用户来定义。为了说明vertex shader的输入是如何组织的，我们在vertex shader中定义输入的时候还需要使用location来说明：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> pos;</span><br></pre></td></tr></table></figure>
<p>然后用户在CPU中定义输入的来源数据。</p>
<p>fragment shader要求必须有一个<code>vec4</code>类型的颜色输出变量，因为fragment shader的作用就是生成最后像素的颜色值。如果你没有定义这个颜色输出，OpenGL最后输出的可能就是纯黑色或者纯白色。</p>
<p>So if we want to send data from one shader to the other we’d have to declare an output in the sending shader and a similar input in the receiving shader. When the types and the names are equal on both sides OpenGL will link those variables together and then it is possible to send data between shaders (this is done when linking a program object). </p>
<h2 id="Uniforms"><a href="#Uniforms" class="headerlink" title="Uniforms"></a>Uniforms</h2><p>uniforms是另外一种从CPU传递数据到shader程序的方式，uniform和vertex attribute不同，它是全局性质的，也就是说，uniform变量在shader program之间是隔离的，但是在shader program中的每个shader之间是共享的。另外一旦uniform变量被赋值，它的值就会一直保持这个，直到下一次被重置或者重新赋值。定义uniform变量，我们只需在定义变量时使用uniform关键字即可：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> outColor;</span><br></pre></td></tr></table></figure>
<p>如果你你定义了uniform变量但是没有在任何地方使用，GLSL编译器或最终会将这个变量移除。</p>
<p>uniform变量的赋值可以在glsl中赋值，也可以在CPU中赋值，在CPU中赋值时，需要先获取到uniform变量的location，然后才能赋值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0</span>f, <span class="number">1.0</span>, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br></pre></td></tr></table></figure>
<font color="orange">注意，在CPU端获取uniform变量时不需要先调用glUseProgram，但是为uniform变量赋值的之前则必须先调用glUseProgram。</font>



<h1 id="fragment-interpolation"><a href="#fragment-interpolation" class="headerlink" title="fragment interpolation"></a>fragment interpolation</h1><p>OpenGL在渲染一个primitive时，在rasterization阶段，一个primitive最终会对应到屏幕中的若干个像素，也即是若干个fragmen，rasterization阶段会决定这些fragment的位置，<font color="orange">基于这个位置，fragment shader中的所有输入变量的值将会是对应primitive中各顶点输出值的线性插值结果。</font></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/10/01/opengl/opengl%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/01/opengl/opengl%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">opengl简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-01 10:32:44" itemprop="dateCreated datePublished" datetime="2020-10-01T10:32:44+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-03 10:17:07" itemprop="dateModified" datetime="2022-03-03T10:17:07+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OpenGL简介-What-is-OpenGL"><a href="#OpenGL简介-What-is-OpenGL" class="headerlink" title="OpenGL简介(What is OpenGL)"></a>OpenGL简介(What is OpenGL)</h1><p>OpenGL是一个提供操作图形和图像的API标准(注意是标准，而不是实际的某种编程语言的接口)，这些接口标准由Khronos Group管理。OpenGL接口标准定义每个函数的输入输出是什么，每个函数应该有怎样的表现等等。这些接口最终由开发者来实际实现（一般是显卡厂商）。虽然不同开发者实现的Open GL的代码细节不同，但是由于标准的存在，对于用户来说使用方式和最终结果是没有区别的（如果有，那就是显卡制造商写的OpenGL实现有问题）。</p>
<h2 id="Core-Profile模式和Immdiate-模式"><a href="#Core-Profile模式和Immdiate-模式" class="headerlink" title="Core Profile模式和Immdiate 模式"></a>Core Profile模式和Immdiate 模式</h2><p>在以前，使用OpenGL开发用的是immdiate模式，immediate模式是指固定的渲染管线，用户只需要开发少量的代码，就能获得最终的渲染图形，但是同时，用户对渲染过程的控制度很低，在处理渲染上灵活性很差。从OpenGL 3.2开始，OpenGL开始使用core-profile模式，从3.2版本开始，这是OpenGL的一个分支，这个版本删除了所有旧的不推荐使用的功能。当我们在core-profile模式下，OpenGL会强迫我们使用现代的渲染方法，当我们尝试使用已经Deprecated的方法时，OpenGL会抛出异常并停止渲染。</p>
<h2 id="OpenGL扩展-Extensions"><a href="#OpenGL扩展-Extensions" class="headerlink" title="OpenGL扩展(Extensions)"></a>OpenGL扩展(Extensions)</h2><p>OpenGL一个很好的特性就是扩展，当显卡公司对于渲染有了新的优化或者有新的渲染技术，这些就可以通过扩展的形式发布出去给用户使用，而不用等OpenGL把这些功能新加入到OpenGL标准中，对于用户而言，在编写OpenGL程序的时候只需要判断是否有相应扩展，如果有就可以使用相应的接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do cool new and modern stuff supported by hardware</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Extension not supported: do it the old way</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>OpenGL标准本身可以看作是一个状态机的定义：定义当前OpenGL应该如果运行的变量集合。OpenGL的状态同城称为OpenGL context，在使用OpenGL时，我们经常通过设置一些选项、操作一些缓冲区然后对当前上下文进行渲染来更改其状态。</p>
<h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>OpenGL 实际上只是一个标准/规范，由驱动程序制造商将规范实现到特定显卡支持的驱动程序。由于OpenGL驱动有很多不同的版本，其大部分函数的位置在编译时是未知的，需要在运行时查询。然后开发人员的任务是检索需要的函数的位置并将它们存储在函数指针中供以后使用，这个步骤可以通过GLAD这个库来帮助实现。</p>
<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>在OpenGL中，所有的都是3维空间，但是屏幕石油二维的像素组成的，所以OpenGL大多数的工作其实就是将3维空间的坐标转换到二维空间的像素，这个过程就是有渲染管线来完成的。渲染管线可以分为两大部分：第一部分，将3D坐标转换为2D坐标；第二部分将2D坐标转换为具体的颜色像素。</p>
<p>渲染管线的具体步骤可以分为多步，每一步都需要将前一步的输出作为自己的输入，并且每一步都是高度可定制化的，而且可以很方便的并行处理。由于并行化的特性，现代图形卡可以快速处理渲染管线中的步骤。</p>
<blockquote>
<p>Because of their parallel nature, graphics cards of today have thousands of small processing cores to quickly process your data within the graphics pipeline. The processing cores run small programs on the GPU for each step of the pipeline. These small programs are called <font color="orange">shaders.</font></p>
</blockquote>
<h2 id="vertex-shader"><a href="#vertex-shader" class="headerlink" title="vertex shader"></a>vertex shader</h2><p>vertex shader将单个vertex作为输入，单个vertex作为输出。vertex shader的主要作用是将3D坐标转换为另外一个3D坐标，并对vertex的属性做一些额外的处理。</p>
<h2 id="primitive-assembly"><a href="#primitive-assembly" class="headerlink" title="primitive assembly"></a>primitive assembly</h2><p>primitive assembly步骤将vertex shader的所有输出作为输入，以此来形成primitive shape，primitive shape是组成最终物体的基础形状。</p>
<blockquote>
<p>In order for OpenGL to know what to make of your collection of coordinates and color values OpenGL requires you to hint what kind of render types you want to form with the data. Do we want the data rendered as a collection of points, a collection of triangles or perhaps just one long line? Those hints are called <font color="orange">primitives</font> and are given to OpenGL while calling any of the drawing commands. Some of these hints are GL_POINTS, GL_TRIANGLES and GL_LINE_STRIP.</p>
</blockquote>
<h2 id="geometry-shader"><a href="#geometry-shader" class="headerlink" title="geometry shader"></a>geometry shader</h2><p>primitive assembly步骤的输出作为geometry shader的输入。geometry shader将一组形成primitive的vertex作为输入，geometry shader在此基础上通过生成新的点来生成新的primitive（可以和primitve assembly阶段生成的primitive不同）以此来生成其他新的形状。</p>
<h1 id="rasterization"><a href="#rasterization" class="headerlink" title="rasterization"></a>rasterization</h1><p>resterization步骤将geometry shader的输出作为输入，rasterization阶段将最终的primitive转换为最终显示在屏幕的像素点位置，并且将超出屏幕部分的去掉以提高性能。</p>
<h2 id="fragment-shader"><a href="#fragment-shader" class="headerlink" title="fragment shader"></a>fragment shader</h2><p>fragment shader的主要目的是计算像素点的最终颜色，这个阶段一般是所有OpenGL高级特效生成的阶段。通常fragment shader包含可以用来计算最终像素颜色的数据，例如光照，光照颜色，阴影等信息。</p>
<blockquote>
<p>A fragment in OpenGL is all the data required for OpenGL to render a single pixel.</p>
</blockquote>
<h2 id="alpha-test-and-blender"><a href="#alpha-test-and-blender" class="headerlink" title="alpha test and blender"></a>alpha test and blender</h2><p>在所有颜色值都已经被决定后，会进入到alpha test和blender阶段。这个阶段会检查frament的深度信息和stencil信息，判断这个fragment是在其他object的前面还是后面，一次判断是否需要最终渲染这个fragment。另外这一步也会检查alpha通道，以此来混合（blend）颜色信息。因此，即使在fragment shader中计算出了像素的输出颜色，最终像素的实际颜色也可能会和计算出来的不同。</p>
<p>可以看到，一个渲染管线包含了很多步骤和很多可配置的渲染属性。但是，在大多数情况下，我们只需要和处理vertex shader和fragment shader就可以了。geometry shader是可选的并且通常用默认的geometry shader实现就可以了。vertex shader和fragment shader是现代OpenGL要求用户至少提供的两个shader，这两个shader没有默认的实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/09/28/others/coin-or%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/28/others/coin-or%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Untitled</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-28 11:25:13" itemprop="dateCreated datePublished" datetime="2020-09-28T11:25:13+08:00">2020-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-24 17:28:11" itemprop="dateModified" datetime="2021-05-24T17:28:11+08:00">2021-05-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>462</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="coin-or-简介"><a href="#coin-or-简介" class="headerlink" title="coin-or 简介"></a>coin-or 简介</h1><h1 id="single-compile-single-lib-by-using-configure"><a href="#single-compile-single-lib-by-using-configure" class="headerlink" title="single: compile single lib by using configure"></a>single: compile single lib by using configure</h1><p>./configure \<br>—host=arm-apple-darwin \<br>—enable-static \<br>—disable-shared \<br>—prefix=$PWD/build/arm64 \<br>CC=gcc \<br>CFLAGS=”-DNDEBUG -miphoneos-version-min=8.0 -arch arm64 -g -O0 -fembed-bitcode \<br>-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk” \<br>CXX=g++ \<br>CXXFLAGS=”-DNDEBUG -miphoneos-version-min=8.0 -arch arm64 -g -O0 -fembed-bitcode \<br>-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk \<br>-std=c++11 -stdlib=libc++” \<br>LDFLAGS=”” \<br>LIBS=”-lc++ -lc++abi”</p>
<h2 id="导出-PKG-CONFIG-PATH"><a href="#导出-PKG-CONFIG-PATH" class="headerlink" title="导出 PKG_CONFIG_PATH"></a>导出 PKG_CONFIG_PATH</h2><p>export pkgconfig path<br>export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/Users/bytedance/Desktop/coin-or/Osi/build/arm64/lib/pkgconfig<br>export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/Users/bytedance/Desktop/coin-or/CoinUtils/build/arm64/lib/pkgconfig</p>
<p>pkgconfig folder can be read by <code>pkg-config</code></p>
<h2 id="遇到报错ld-bind-at-load-and-bitcode-bundle-Xcode-setting-ENABLE-BITCODE-YES-cannot-be-used-together"><a href="#遇到报错ld-bind-at-load-and-bitcode-bundle-Xcode-setting-ENABLE-BITCODE-YES-cannot-be-used-together" class="headerlink" title="遇到报错ld: -bind_at_load and -bitcode_bundle (Xcode setting ENABLE_BITCODE=YES) cannot be used together"></a>遇到报错ld: -bind_at_load and -bitcode_bundle (Xcode setting ENABLE_BITCODE=YES) cannot be used together</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53121019/ld-bind-at-load-and-bitcode-bundle-xcode-setting-enable-bitcode-yes-cannot">export MACOSX_DEPLOYMENT_TARGET=”10.15.0”</a></p>
<h1 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h1><p>./coinbrew build Clp \<br>—host=arm-apple-darwin \<br>—enable-static \<br>—disable-shared \<br>—prefix=$PWD/ios \<br>CC=gcc \<br>CFLAGS=”-DNDEBUG -miphoneos-version-min=8.0 -arch arm64 -g -O0 -fembed-bitcode \<br>-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk” \<br>CXX=g++ \<br>CXXFLAGS=”-DNDEBUG -miphoneos-version-min=8.0 -arch arm64 -g -O0 -fembed-bitcode \<br>-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk \<br>-std=c++11 -stdlib=libc++” \<br>LDFLAGS=”” \<br>LIBS=”-lc++ -lc++abi” \<br>—tests none \<br>—no-third-party \<br>—verbosity 4 </p>
<h1 id="osx-to-be-fixed"><a href="#osx-to-be-fixed" class="headerlink" title="osx to_be_fixed"></a>osx to_be_fixed</h1><p>./coinbrew build Clp —enable-static —disable-shared CC=clang CXX=clang++ —tests none —prefix=$PWD/osx —no-third-party</p>
<h1 id="android"><a href="#android" class="headerlink" title="android"></a>android</h1><h2 id="android-armv8-a"><a href="#android-armv8-a" class="headerlink" title="android armv8-a"></a>android armv8-a</h2><p>export NDK=/Users/bytedance/Downloads/android-ndk-r21b<br>export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64<br>export TARGET=aarch64-linux-android<br>export API=21<br>export AR=$TOOLCHAIN/bin/$TARGET-ar<br>export AS=$TOOLCHAIN/bin/$TARGET-as<br>export CC=$TOOLCHAIN/bin/$TARGET$API-clang<br>export CXX=$TOOLCHAIN/bin/$TARGET$API-clang++<br>export LD=$TOOLCHAIN/bin/$TARGET-ld<br>export RANLIB=$TOOLCHAIN/bin/$TARGET-ranlib<br>export STRIP=$TOOLCHAIN/bin/$TARGET-strip</p>
<p>./coinbrew build Clp \<br>—host=$TARGET \<br>—enable-static \<br>—disable-shared \<br>—prefix=$PWD/android/armv8-a \<br>—tests none \<br>—no-third-party</p>
<h2 id="android-armv7-a"><a href="#android-armv7-a" class="headerlink" title="android armv7-a"></a>android armv7-a</h2><p>export NDK=/Users/bytedance/Downloads/android-ndk-r21b<br>export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64<br>export TARGET=armv7a-linux-androideabi<br>export API=21<br>export AR=$TOOLCHAIN/bin/arm-linux-androideabi-ar<br>export AS=$TOOLCHAIN/bin/arm-linux-androideabi-as<br>export CC=$TOOLCHAIN/bin/$TARGET$API-clang<br>export CXX=$TOOLCHAIN/bin/$TARGET$API-clang++<br>export LD=$TOOLCHAIN/bin/arm-linux-androideabi-ld<br>export RANLIB=$TOOLCHAIN/bin/arm-linux-androideabi-ranlib<br>export STRIP=$TOOLCHAIN/bin/$arm-linux-androideabi-strip</p>
<p>./coinbrew build Clp \<br>—host=$TARGET \<br>—enable-static \<br>—disable-shared \<br>—prefix=$PWD/android/armv7-a \<br>—tests none \<br>—no-third-party</p>
<h1 id="local"><a href="#local" class="headerlink" title="local"></a>local</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>./coinbrew build Clp —enable-static —disable-shared —tests none —prefix=$PWD/static —no-third-party</p>
<h2 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h2><p>./coinbrew build Clp —prefix=$PWD/dynamic —no-third-party —verbosity 4</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/09/04/redis/redis%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/redis/redis%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">redis配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-04 20:47:41" itemprop="dateCreated datePublished" datetime="2020-09-04T20:47:41+08:00">2020-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-05 09:36:29" itemprop="dateModified" datetime="2020-09-05T09:36:29+08:00">2020-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>96</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>redis的配置文件位于Redis的安装目录下，文件名为redis.conf，windows下为redis.windows.conf，这个文件是一个文本文件。</p>
<h1 id="配置命名"><a href="#配置命名" class="headerlink" title="配置命名"></a>配置命名</h1><p>在redis命令行下，你可以使用CONFIG命令获取或者设置相关配置</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET loglevel</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET * # 用于获取所有配置</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET loglevel &quot;notice&quot;</span><br></pre></td></tr></table></figure>
<h1 id="Redis参数说明"><a href="#Redis参数说明" class="headerlink" title="Redis参数说明"></a>Redis参数说明</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-conf.html">详见</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/08/07/devops/docker/Docker%20%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/07/devops/docker/Docker%20%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">docker 初学笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-07 15:20:41" itemprop="dateCreated datePublished" datetime="2020-08-07T15:20:41+08:00">2020-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-02 22:51:00" itemprop="dateModified" datetime="2022-05-02T22:51:00+08:00">2022-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-镜像与容器"><a href="#Docker-镜像与容器" class="headerlink" title="Docker 镜像与容器"></a>Docker 镜像与容器</h1><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一系列构建镜像所需的指令和说明。</p>
<p>Dockerfile字段介绍:</p>
<ul>
<li><p>FROM: 定制的镜像所基于的基础的镜像，后续的操作都将基于这个基础镜像。</p>
<ul>
<li>FROM的基础镜像是必须指定的，如果确实没有基于的其他镜像，可以指定为一个特殊的空镜像叫scratch。</li>
</ul>
</li>
<li><p>RUN: 后面接命令行命令，它有两种形式:</p>
<ul>
<li>RUN 直接跟要执行的命令行命令</li>
<li>RUN [“可执行文件”, “参数1”, “参数2”, …]</li>
</ul>
<p>Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。如果命令太多，可以使用&amp;&amp;符号连接命令，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN yum install wget \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>COPY: 复制指令，从<a href="#使用Dockerfile构建镜像">上下文目录中</a>复制文件或者目录到容器里指定路径：</p>
<ul>
<li>```shell<br>COPY [—chown=<user>:<group>] &lt;源路径1&gt;…  &lt;目标路径&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  * 源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则，如COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">  </span><br><span class="line">  * 目标路径: 容器内的指定路径</span><br><span class="line"></span><br><span class="line">* CMD: 类似于RUN指令，但是CMD的命令是在容器开始运行时会被运行，RUN命令是在构建镜像时被运行。CMD命令为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。**如果Dockerfile有多个CMD命令，仅最后一个生效**</span><br><span class="line"></span><br><span class="line">* EVN: 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。EVN命令使用格式如下：</span><br><span class="line">  </span><br><span class="line">  * &#96;&#96;&#96;shell</span><br><span class="line">    ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">    ENV &lt;key1&gt;&#x3D;&lt;value1&gt; &lt;key2&gt;&#x3D;&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
</group></user></li>
</ul>
</li>
<li><p>WORKDIR: 指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。(WORKDIR 指定的工作目录，必须是提前创建好的)。docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
</li>
<li><p>其他更多命令见<a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-dockerfile.html">这里</a></p>
</li>
</ul>
<h1 id="Docker-常用命令及介绍"><a href="#Docker-常用命令及介绍" class="headerlink" title="Docker 常用命令及介绍"></a>Docker 常用命令及介绍</h1><h1 id="Registry相关"><a href="#Registry相关" class="headerlink" title="Registry相关"></a>Registry相关</h1><p>1、切换Registry</p>
<h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><h5 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<h5 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<h5 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">or</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>列出来表格有以下几个字端</p>
<ul>
<li>REPOSITORY: 镜像名称</li>
<li>TAG: 镜像的标签</li>
<li>IMAGE ID: 镜像ID</li>
<li>CREATED: 镜像创建时间</li>
<li>SIZE: 镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果不指定TAG，默认会使用为TAG被标记为latest的那个。</p>
<h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [-f] &lt;image-id&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>-f 表示force</li>
</ul>
<h5 id="使用Dockerfile构建镜像"><a href="#使用Dockerfile构建镜像" class="headerlink" title="使用Dockerfile构建镜像"></a>使用Dockerfile构建镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;image name&gt;:&lt;tag name&gt; .</span><br></pre></td></tr></table></figure>
<p>-t 参数是标签，如果不给tag name，会自动将tag name设置为latest，<code>如果该镜像之前已经有被标记为latest tag 的镜像，那个这个之前的镜像的tag会被标记为none</code>。所以最好为每个镜像给一个tag。</p>
<p>“.”表示上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。可以类比cmake命令的”cmake .”</p>
<p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
<p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
<h2 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h2><ul>
<li><code>docker ps -a</code><ul>
<li>查看目前创建的所有容器的状态</li>
</ul>
</li>
<li><code>docker stop &lt;container id&gt;</code><ul>
<li>暂停运行某个容器</li>
<li>Cotainer id 可以通过docker ps命令查看</li>
</ul>
</li>
<li><code>docker restart &lt;container id&gt;</code><ul>
<li>重启某个容器</li>
</ul>
</li>
<li><code>docker rm &lt;container id&gt;</code><ul>
<li>删除某个容器</li>
</ul>
</li>
<li><code>docker rm $(docker ps -aq)</code><ul>
<li>删除所有容器</li>
</ul>
</li>
<li><code>docker run -it &lt;image_name&gt;:&lt;image_tag&gt; /bin/bash</code><ul>
<li>使用某个镜像启动某个容器，并以<font color="orange">命令行形式</font>进入该容器</li>
<li>-i 参数：交互式操作</li>
<li>-t参数: 为容器重新分配一个伪输入终端</li>
<li>-i、-t一般同时使用</li>
<li>/bin/bash：使用的shell</li>
<li><font color="orange">通过该命令如果在shell中执行exit命令后，容器将会停止运行</font></li>
</ul>
</li>
<li><code>docker run -d &lt;image_name&gt;:&lt;image_tag&gt; [--name &lt;custom_container_name&gt;] [-p &lt;outter_port&gt;:&lt;inner_port&gt;]</code><ul>
<li>以守护进程模式在后台启动一个容器</li>
<li>-d参数：表示以守护进程形式在后台启动</li>
<li>—name参数：容器的名称，如果不定义则会是一个随机的名称</li>
<li>-p参数：端口映射，docker容器内部默认是不开放端口的，需要手动指定哪些端口开放，并且外部从哪些端口访问对应容器内的端口</li>
</ul>
</li>
<li><code>docker exec -it &lt;container id&gt; /bin/bash</code><ul>
<li>以命令行的形式进入某个容器</li>
<li>docker exec 用于在一个运行的container中运行一个命令，更多docker exec的使用可以用docker exec —help查看</li>
</ul>
</li>
<li><code>docker export &lt;container id&gt; &gt; &lt;filename&gt;</code> <ul>
<li>创建容器快照</li>
<li>示例：<code>docker export 1e560fca3906 &gt; ubuntu.tar</code></li>
</ul>
</li>
<li><code>docker import &lt;filePath | url&gt; &lt;imageName:tag&gt;</code><ul>
<li>将容器快照文件再导入为镜像</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/07/27/program_language/c++/C++PrimerPlus/%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/27/program_language/c++/C++PrimerPlus/%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-27 16:35:04" itemprop="dateCreated datePublished" datetime="2020-07-27T16:35:04+08:00">2020-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-09 16:43:45" itemprop="dateModified" datetime="2022-02-09T16:43:45+08:00">2022-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-primer-plus/" itemprop="url" rel="index">
                    <span itemprop="name">c++ primer plus</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>inline function在编译后实质上是函数代码块的替换，编译器不一定会实现inline function，如果编译器认为inline function太复杂或者有递归调用。<font color="orange">inline function的链接性为内部链接，所以inline function的定义和声明不能放在不同的文件中。</font></p>
<h1 id="引用类型作函数参数"><a href="#引用类型作函数参数" class="headerlink" title="引用类型作函数参数"></a>引用类型作函数参数</h1><p>如果函数的参数为引用类型，如果传递的参数类型正确但不是左值或者传递的参数类型不正确，在其可以转换为正确的类型的情况下，<strong>编译将会创建一个临时变量，而将引用参数引用到该临时变量上</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">refcube</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;ra)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> re * ra * ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> side = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;side;</span><br><span class="line"><span class="keyword">double</span> &amp;rd = side;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> edge = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> lens[<span class="number">4</span>] = &#123;<span class="number">2.0</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">12.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> c1 = refcube(side);<span class="comment">//won&#x27;t create temporary variable</span></span><br><span class="line"><span class="keyword">double</span> c2 = refcube(lens[<span class="number">2</span>]);<span class="comment">//won&#x27;t create temporary variable</span></span><br><span class="line"><span class="keyword">double</span> c3 = refcube(rd);<span class="comment">//won&#x27;t create temporary variable</span></span><br><span class="line"><span class="keyword">double</span> c4 = refcube(*pd);<span class="comment">//won&#x27;t create temporary variable</span></span><br><span class="line"><span class="keyword">double</span> c5 = refcube(edge);<span class="comment">//will create temporary variable</span></span><br><span class="line"><span class="keyword">double</span> c6 = refcube(<span class="number">7.0</span>);<span class="comment">//will create temporary variable</span></span><br><span class="line"><span class="keyword">double</span> c7 = refcube(side + <span class="number">10.0</span>);<span class="comment">//will create temporary variable</span></span><br></pre></td></tr></table></figure>
<h1 id="带默认参数的函数"><a href="#带默认参数的函数" class="headerlink" title="带默认参数的函数"></a>带默认参数的函数</h1><ul>
<li>如果要用为某个参数设置默认值，则必须为<code>它右边的所有参数提供默认值</code>。</li>
<li>函数定义中有默认参数，在函数实现中的函数头中可以不再写默认参数的值。</li>
</ul>
<h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>...</code>代表可以接受<font color="orange">任意类型</font>的数据任意多个。</p>
<p>获取到可变参数列表的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">    va_list    ap;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">        sum += temp;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、va_list args;            <span class="comment">//定义一个可变参数列表</span></span><br><span class="line"><span class="number">2</span>、va_start(args,n);    <span class="comment">//初始化args指向强制参数n的`下一个参数`</span></span><br><span class="line"><span class="number">3</span>、va_arg(args,type);    <span class="comment">//`获取当前参数内容`并将args指向下一个参数</span></span><br><span class="line"><span class="number">4</span>、va_end(args);            <span class="comment">//释放args</span></span><br></pre></td></tr></table></figure>
<p>在使用va_arg宏时，<code>要求type是POD(Plain Old Data)类型</code>，能用 C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据，所有基本数据类型都是POD。并且如果type和对应的参数不对的话会产生强制类型转换。如果类型转换失败就会将数据设置为0或者其他初始化的值。</p>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul>
<li><p>函数的参数列表也称为函数特征标</p>
</li>
<li><p>函数重载要求函数的参数数目或参数类型<code>或参数的顺序</code>不同，而参数名是无关紧要，且编译器在检查时<code>不一定</code>会将引用类型和本身类型视为同一特征标，但是如果调用重载函数存在二义性则编译器会报错。</p>
</li>
<li><p><code>对于非引用传参，形参是否const是等价的</code>。但是<code>当使用引用传参时，有无const是不同的</code>。使用指针传参时，<code>指向const对象的指针和指向非const对象的指针做形参的函数是不同的</code></p>
</li>
<li><p>只是函数返回值不同不能构成函数重载</p>
</li>
<li><p><code>在类中，C++将区分常量和非常量函数(即函数本身是否为const)的特征标</code></p>
</li>
<li><p>函数重载匹配原则</p>
<ul>
<li>最匹配原则</li>
<li>如果没有匹配的将会进行类型强转后进行匹配，但是进行类型强转后进行匹配后有多个匹配的会产生报错；</li>
</ul>
</li>
</ul>
<h1 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h1><font color="orange">函数模版并没有创建一个函数，它只是告诉编译器如何创建如何创建一个函数，编译器在遇到使用模版函数的地方会将模版函数展开成具体的函数。</font>

<p>模版函数匹配原则：越具体越适配原则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span></span>;<span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T *t)</span></span>;<span class="comment">//函数2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">func(&amp;a);<span class="comment">//函数2更适配</span></span><br></pre></td></tr></table></figure>
<h2 id="decltype-x-y"><a href="#decltype-x-y" class="headerlink" title="decltype(x) y"></a>decltype(x) y</h2><p>decltype(x) y，用于说明y的类型和x的类型一样，decltype的运用场景大多是模版</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto gt(T1 x, T2 y) -&gt; decltype(x + y);</span><br></pre></td></tr></table></figure>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数指针的声明方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type (*pointer_name)(parameter);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>*</code>和pointer_name要用括号括起来，否则就变成了返回指针的函数。</p>
</li>
<li><p>不能声明一个指向模版函数的指针，因为模版函数并没有实现真的函数，而只是说明如何声明函数</p>
</li>
</ul>
<h1 id="宏定义形式的函数"><a href="#宏定义形式的函数" class="headerlink" title="宏定义形式的函数"></a>宏定义形式的函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a) &gt; (b) ? (a) : (b)</span></span><br></pre></td></tr></table></figure>
<font color="orange">注意要将参数用括号扩起来</font>

<p>有些时候用宏定义的代码被do { } while(0);包含了起来，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) do &#123;    \</span></span><br><span class="line">    (a) &gt; (b) ? (a) : (b); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这是因为宏的处理是文本替换，有时候将宏用文本替换后代码就产生了语法错误，而使用do {} while(0)是为了避免由于文本替换后带来的语法错误，并保证宏函数无论如何都会执行一次。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/07/27/program_language/c++/Effective-c++/%E6%9D%A1%E6%AC%BE04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/27/program_language/c++/Effective-c++/%E6%9D%A1%E6%AC%BE04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">条款04-确定对象被使用前已被初始化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-27 11:30:17 / Modified: 10:03:08" itemprop="dateCreated datePublished" datetime="2020-07-27T11:30:17+08:00">2020-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">effective c++</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>799</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="确定对象被使用前已被初始化"><a href="#确定对象被使用前已被初始化" class="headerlink" title="确定对象被使用前已被初始化"></a>确定对象被使用前已被初始化</h1><ul>
<li>对内置型数据(char, int, float, char * 等)进行手工初始化，因为C++不保证初始化它们</li>
<li><strong>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前</strong></li>
<li>对象成员变量的初始化使用成员初始化列表的方式(<strong>如果成员变量是const或者reference就一定要使用初始化列表的方式</strong>)</li>
<li>如果class内存在许多成员变量或者是从多个基类继承来的，而且这个class有多个构造方法，导致成员初始化列表存在许多重复，这种情况下可以合理地在初始列中挑出那些“赋值操作的性能和初始化一样好”的成员变量，改用它们的赋值操作，并将那些赋值操作移往某个函数(通常为private)，供所有的构造函数调用</li>
<li>C++有十分固定的成员初始化次序，base class总是早于derived class被初始化，<strong>class的成员变量总是以其声明次序被初始化</strong>，即使它们在成员初始化列表中以不同的次序出现，所以<strong>当你在成员初始值列中列出各个成员时，最好总是与其声明次序一致</strong></li>
</ul>
<h1 id="不同编译单元内定义的non-local-static对象的初始化次序"><a href="#不同编译单元内定义的non-local-static对象的初始化次序" class="headerlink" title="不同编译单元内定义的non-local static对象的初始化次序"></a>不同编译单元内定义的non-local static对象的初始化次序</h1><p>函数内的static对象称为local static对象，其他static对象成为non-local static对象。</p>
<p>所谓编译单元是指产出单一目标文件(single object file)的那些源码，基本上它是单一源码文件加上其所含入的头文件。</p>
<p>现在问题涉及至少两个源码文件，每一个内含至少一个non-local static对象，如果某个编译单元内的某个non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的non-local static对象”的初始化次序并无明确定义。</p>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in a.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//a non-local static object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//in b.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Directory( params );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//in b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line">Directory::Directory( params ) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();<span class="comment">//use tfs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in main.cpp</span></span><br><span class="line"><span class="function">Directory <span class="title">tmpDirectory</span><span class="params">( params )</span></span>;<span class="comment">//tempDirectory is also a non-local static object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化tmpDirectory时需要用到tfs，这时候tfs可能还没有被初始化，这就会出现问题。</p>
<p>解决办法：将每个non-local static对象放到一个属于它自己的专属函数内，成为一个local static对象，这些函数返回一个reference指向它所含的对象。</p>
<p>接上例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in a.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span> ... &#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">  <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in b.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in b.cpp</span></span><br><span class="line">Directory::Directory( params ) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tmpDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Directory <span class="title">td</span><span class="params">( params )</span></span>;</span><br><span class="line">  <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...;</span><br><span class="line">  temDir().doSomething();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的基础在于：C++保证，函数内的local static对象会在“该函数被调用期间”“首次遇上该对象的定义式”时被初始化。<strong>这种方式也是Singleton模式的一个常见实现方法。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/07/27/program_language/c++/C++PrimerPlus/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/27/program_language/c++/C++PrimerPlus/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">内存模型与命名空间</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-27 10:39:13" itemprop="dateCreated datePublished" datetime="2020-07-27T10:39:13+08:00">2020-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-29 16:26:09" itemprop="dateModified" datetime="2022-01-29T16:26:09+08:00">2022-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-primer-plus/" itemprop="url" rel="index">
                    <span itemprop="name">c++ primer plus</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="变量作用范围"><a href="#变量作用范围" class="headerlink" title="变量作用范围"></a>变量作用范围</h1><h2 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h2><ul>
<li>自动存储持续性：在程序开始执行其所属的函数或者代码块（花括号括起来的部分）时被创建，执行完函数或者代码块后，其内存空间被释放。</li>
<li>静态存储持续性：<code>在程序的整个运行过程中都存在</code></li>
<li>线程存储持续性（c++11）使用thread_local声明，其生命周期与所属线程一样长</li>
<li>动态存储持续性：使用new和delete来动态管理</li>
</ul>
<h2 id="连接性"><a href="#连接性" class="headerlink" title="连接性"></a>连接性</h2><ul>
<li>外部连接性：可在其他文件中访问</li>
<li>内部链接性：只能在当前文件中访问</li>
<li>无链接性：只能在当前函数或代码块中访问</li>
</ul>
<h2 id="静态初始化和动态初始化"><a href="#静态初始化和动态初始化" class="headerlink" title="静态初始化和动态初始化"></a>静态初始化和动态初始化</h2><ul>
<li><p>静态初始化：在编译器处理文件时对变量进行初始化</p>
</li>
<li><p>动态初始化：编译后初始化</p>
</li>
</ul>
<h2 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h2><p>编译器将<code>分配固定的内存块来存储所有的静态变量</code>，这些变量在整个程序执行期间一直存在。并且，<code>如果没有显示地初始化静态变量，编译器将把它设置为0</code>。在默认情况下，静态数组和结构将每个元素或成员的所有<code>位(bit)</code>都设置为0。</p>
<p>声明三种链接性的静态持续变量的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global = <span class="number">1000</span>;<span class="comment">//静态持续，外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> one_file = <span class="number">50</span>;<span class="comment">//静态持续，内部链接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//静态持续，无链接</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态外部变量"><a href="#静态外部变量" class="headerlink" title="静态外部变量"></a>静态外部变量</h3><p><code>静态持续性</code>，<code>外部链接性</code>的变量，<code>定义</code>有两种方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> up = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> up = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即定义静态外部变量的时候可以省略extern关键字</span></span><br></pre></td></tr></table></figure>
<p><code>声明</code>外部变量的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> up;<span class="comment">//up 在其他文件定义</span></span><br></pre></td></tr></table></figure>
<h3 id="静态内部变量"><a href="#静态内部变量" class="headerlink" title="静态内部变量"></a>静态内部变量</h3><p>使用static定义并同时初始化声明的变量就是静态内部变量</p>
<p>static声明的静态内部变量将会隐藏常规同名外部变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in file1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> errors = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//in file2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> errors = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; errors;<span class="comment">//使用在file2中定义的errors</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>同名变量覆盖规则：外部可见变量被本文件可见变量覆盖，局部变量覆盖全局变量</code></p>
<h1 id="const定义的全局变量"><a href="#const定义的全局变量" class="headerlink" title="const定义的全局变量"></a>const定义的全局变量</h1><p>默认情况下<code>全局变量</code>的链接性为外部的，<code>但</code>const<code>全局变量</code>的链接性为内部的。也就是全局const定义就像使用了static说明符一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">10</span>;<span class="comment">//same as static const int value = 10;</span></span><br></pre></td></tr></table></figure>
<p>但是const可以和extern连用，声明链接性为外部的常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h1 id="函数的持续性和链接性"><a href="#函数的持续性和链接性" class="headerlink" title="函数的持续性和链接性"></a>函数的持续性和链接性</h1><ul>
<li><p>函数默认情况下是静态的，即在整个程序执行期间都一直存在，<code>默认情况下，函数的链接性为外部的</code>，即多个文件可见</p>
</li>
<li><p>可以使用static关键字将函数的链接性设置为内部，<code>且静态定义将覆盖外部定义</code>，且必须在函数的<code>定义和实现中都使用static关键字</code></p>
</li>
<li><p>内联函数不受这项规则的约束，内联函数的链接性为内部的，但是<code>c++要求同一个函数的所有内联定义都必须相同</code></p>
</li>
</ul>
<p><code>如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本</code></p>
<h1 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h1><p>链接程序要求每个不同的函数都有不同的符号名，在C语言中，一个名称只对应一个函数。例如c编译器可能将spiff这样的函数翻译为_spiff。</p>
<p>但在c++中，由于函数重载，一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。例如可能将spiff(int)翻译为spiff_i，将spiff(double, double)翻译成spiff_d_d。</p>
<p>如果要在c++程序中使用c库中预编译的函数，由于有c编译器预编译的函数符号和c++要寻找的函数符号不相同，所有可能c++编译器会找不到这些函数。为了解决这个问题，可以用函数原型来指出要使用的约定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//use C protocol for name look-up</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">spoff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//use C++ protocol for name look-up</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">spaff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//use C++ protocol for name look-up</span></span><br></pre></td></tr></table></figure>
<p>另外的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>注意由于extern &quot;C&quot;之后将按照C的方式翻译函数的名称，所以此时将不能在extern &quot;C&quot; 中进行函数重载</code>。</p>
<h1 id="new、new-和定位new"><a href="#new、new-和定位new" class="headerlink" title="new、new[]和定位new"></a>new、new[]和定位new</h1><p>new、new[]的调用实质上是分别调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>);</span><br></pre></td></tr></table></figure>
<p>要使用定位new特性，首先需要包含头文件new。定位new的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chaff</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *dross;</span><br><span class="line">    <span class="keyword">int</span> slag;</span><br><span class="line">    chaff(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;&quot;</span>, <span class="keyword">int</span> slag = <span class="number">0</span>) : slag(slag) &#123;</span><br><span class="line">        dross = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(dross, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">char</span> buffer2[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line">chaff *p1 = <span class="keyword">new</span> (buffer1) chaff(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">chaff *p2 = <span class="keyword">new</span> (buffer2) <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">chaff *p3 = <span class="keyword">new</span> (buffer1) chaff(<span class="string">&quot;2&quot;</span>);<span class="comment">//将会覆盖p1中的内容</span></span><br><span class="line">chaff *p4 = <span class="keyword">new</span> (buffer1 + <span class="keyword">sizeof</span>(chaff)) chaff(<span class="string">&quot;3&quot;</span>);<span class="comment">//不会覆盖p3指向的内容</span></span><br></pre></td></tr></table></figure>
<p><code>delete和delete[]只能用于指向常规new运算符分配的堆内存，所以delete不一定能作用于定位new运算符所指向的区域，所以最好不要delete定位new运算符返回的指针</code></p>
<p>new 和 delete、new[] 和 delete[]要配套使用，delete和delete[]可以作用于空指针，delete和delete[]不能同时释放同一内存空间两次，除非是空指针，否则将会出现runtime error。</p>
<h1 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h1><h2 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="cv-限定符"></a>cv-限定符</h2><ul>
<li>const</li>
<li>volatile</li>
</ul>
<p>假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会发生变化。如果不将变量声明为volatile，则编译器讲进行这种优化；将变量声明为volatile则相当于告诉编译器，不要进行这种优化。<code>volatile的使用一般在多进程或多线程的情况下，可能其他进程或线程或改变某个内存空间的值，如果不两次获取的话，程序就会出错。</code></p>
<h2 id="mutable限定符"><a href="#mutable限定符" class="headerlink" title="mutable限定符"></a>mutable限定符</h2><p>mutable用来指出即使结构或类变量为const，其某个成员也可以被修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> access;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data veep&#123;<span class="string">&quot;tom&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">veep.access++;<span class="comment">//allowed</span></span><br></pre></td></tr></table></figure>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>“::”放在变量前面，该运算符表示使用变量的全局版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ::value &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用namespace创建名称空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tom &#123;</span><br><span class="line">    <span class="keyword">int</span> pal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Jack &#123;</span><br><span class="line">    <span class="keyword">int</span> pal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>名称空间可以是全局的，也可以位于另一个名称空间中，但<code>不能位于代码块中。</code></p>
<p>名称空间是开放的，即可以把名称加入到已有的名称空间中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tom &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将会扩展上面的Tom命名空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h2><p>using声明使特定的标示符可用，using编译指令使整个名称空间可用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Tom::func;<span class="comment">//using声明</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tom;<span class="comment">//using 编译指令</span></span><br></pre></td></tr></table></figure>
<h3 id="using编译指令和using声明的区别"><a href="#using编译指令和using声明的区别" class="headerlink" title="using编译指令和using声明的区别"></a>using编译指令和using声明的区别</h3><p>如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。然而，使用了using编译指令(using namespace)时，将进行名称解析。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Jill&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">bucket</span><span class="params">(<span class="keyword">double</span> n)</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="keyword">double</span> fetch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Hill</span>&#123;</span> ... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> fetch;<span class="comment">//全局fetch</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Jill;</span><br><span class="line">    Hill Thrill;</span><br><span class="line">    <span class="keyword">double</span> water = bucket(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> fetch;<span class="comment">//将会隐藏Jill::fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; fetch;<span class="comment">//写局部fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ::fectch;<span class="comment">//写全局的fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Jill::fetch;<span class="comment">//写Jill::fetch</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fetch;<span class="comment">//将会隐藏全局fetch</span></span><br><span class="line">    <span class="keyword">using</span> Jill::fetch;<span class="comment">//错误</span></span><br><span class="line">    Hill top;<span class="comment">//错误</span></span><br><span class="line">    Jill::Hill hill;<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于命名空间的一些小tip"><a href="#关于命名空间的一些小tip" class="headerlink" title="关于命名空间的一些小tip"></a>关于命名空间的一些小tip</h3><ul>
<li><p>可以在名称空间中使用using编译指令和using声明：</p>
<ul>
<li>```cpp<br>namespace myth{<pre><code>using Jill::fetch;
using namespace std;
</code></pre>}<br>//这时候访问fetch的两种方式:<br>cout &lt;&lt; myth::fetch;<br>cout &lt;&lt; Jill::fetch<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 可以为名称空间创建别名:</span><br><span class="line">  </span><br><span class="line">  * &#96;&#96;&#96;cpp</span><br><span class="line">    namespace my_very_favorite_things&#123; ... &#125;;</span><br><span class="line">    namespace mvft &#x3D; my_very_favorite_things;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>未命名的名称空间：</p>
<ul>
<li><pre><code class="lang-cpp">namespace &#123;
    int ice;
    int bandycoot;
&#125;
</code></pre>
</li>
<li><p><code>不能在未命名的名称空间所属文件之外的其他文件中，使用该未命名名称空间中的名称</code>。未命名的名称空间中的变量相当于声明了链接性为内部的静态变量。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/07/27/program_language/c++/Effective-c++/%E6%9D%A1%E6%AC%BE03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/27/program_language/c++/Effective-c++/%E6%9D%A1%E6%AC%BE03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/" class="post-title-link" itemprop="url">条款03-尽可能使用const</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-27 10:30:17" itemprop="dateCreated datePublished" datetime="2020-07-27T10:30:17+08:00">2020-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-26 11:22:17" itemprop="dateModified" datetime="2020-07-26T11:22:17+08:00">2020-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">effective c++</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/07/26/program_language/c++/Effective-c++/%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2#define/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/program_language/c++/Effective-c++/%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2#define/" class="post-title-link" itemprop="url">条款02-尽量以const，enum，inline替换#define</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-26 11:20:20 / Modified: 11:21:21" itemprop="dateCreated datePublished" datetime="2020-07-26T11:20:20+08:00">2020-07-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">effective c++</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>126</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h1><h1 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h1><p>使用#define定义的常量，尽量使用const 来定义，使用#define定义的函数，尽量使用inline函数来定义</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a) &gt; (b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MAX(++a, b);<span class="comment">//a被累加两次</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MAX(++a, b+<span class="number">10</span>);<span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>
<p>由于使用#define定义的函数或者常量都是本文替换，所以文本替换后其语意会产生偏差。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwordAndTea"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SwordAndTea" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SwordAndTea" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">150k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">8:18</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
