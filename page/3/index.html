<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="xiangwei&#39;s blog">
<meta property="og:url" content="http://swordandtea.github.io/page/3/index.html">
<meta property="og:site_name" content="xiangwei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SwordAndTea">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>xiangwei's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiangwei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/12/03/IELTS/IELTS-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/03/IELTS/IELTS-Notes/" class="post-title-link" itemprop="url">IELTS-Notes</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-03 20:59:12" itemprop="dateCreated datePublished" datetime="2022-12-03T20:59:12-05:00">2022-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-17 07:31:37" itemprop="dateModified" datetime="2023-01-17T07:31:37-05:00">2023-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IELTS/" itemprop="url" rel="index">
                    <span itemprop="name">IELTS</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>179</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>has yet to do xxx = has not yet to do xxx，都表示还没有做xxx</p>
</li>
<li><p>特殊过去式和过去分词：</p>
<ul>
<li><p>become：became，become（过去分词是原型）</p>
</li>
<li><p>read: read, read (过去式和过去分词都是原形)</p>
</li>
<li><p>creep: crept或creeped, crept或creeped</p>
</li>
</ul>
</li>
<li><p>By + 时间节点，要用完成时，根据具体语境判断是用过去完成时还是将来完成时</p>
</li>
<li><p>manage to do something：设法<font color="orange">完成了</font>某事</p>
</li>
<li><p>强调句：It is/are/was/were + (被强调部分) + that + (其他部分)</p>
</li>
<li><p>一定程度：to an extent</p>
</li>
<li><p>little more than：表示“仅仅”的意思，因为是little，不是a little</p>
</li>
<li><p>A 怎么怎么样 despite B 怎么怎么样：尽管B 怎么怎么样，但是A怎么怎么样</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/11/30/IELTS/IELTS-Reading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/30/IELTS/IELTS-Reading/" class="post-title-link" itemprop="url">IELTS-Reading</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-30 04:58:02" itemprop="dateCreated datePublished" datetime="2022-11-30T04:58:02-05:00">2022-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-01 08:25:45" itemprop="dateModified" datetime="2023-04-01T08:25:45-04:00">2023-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IELTS/" itemprop="url" rel="index">
                    <span itemprop="name">IELTS</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h1><ul>
<li><p>考试时间：60分钟</p>
</li>
<li><p>文章数量：3篇</p>
</li>
<li><p>题目数量：40道（13+13+14）</p>
</li>
<li><p>文章字数：1200-1500 words/p</p>
</li>
<li><p>题型：</p>
<ul>
<li><p>图标填空题型</p>
</li>
<li><p>完成句子题型</p>
</li>
<li><p>摘要题型</p>
</li>
<li><p>简答题型</p>
</li>
<li><p>判断题型</p>
</li>
<li><p>配对题型</p>
</li>
<li><p>标题对应题型</p>
</li>
<li><p>选择题型</p>
</li>
</ul>
</li>
<li><p>评分标准</p>
<ul>
<li><p>9分——对39到40个</p>
</li>
<li><p>8.5分——对37到38个</p>
</li>
<li><p>8分——对35到36个</p>
</li>
<li><p>7.5分——对33到34个</p>
</li>
<li><p>7分——对30到32个</p>
</li>
<li><p>6.5分——对27到29个</p>
</li>
<li><p>6分——对23到26个</p>
</li>
</ul>
</li>
</ul>
<h1 id="句子-笔记填空"><a href="#句子-笔记填空" class="headerlink" title="句子/笔记填空"></a>句子/笔记填空</h1><h2 id="题型特点"><a href="#题型特点" class="headerlink" title="题型特点"></a>题型特点</h2><ul>
<li><p>原文原词填空（不改形式，<font color="orange">连续选词</font>）</p>
</li>
<li><p>顺序题目（<font color="orange">偶尔小乱序</font>）</p>
</li>
<li><p>答案位置可能集中（几个段落），<font color="orange">可能分散（全文）</font></p>
</li>
</ul>
<h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><ul>
<li><p>审题目要求：字数要求，<font color="orange">在符合题目要求的前提下，保持字数最大化，如超过字数要求，去掉修饰词，保留核心词</font></p>
</li>
<li><p>在题干中划定位词，回原文中定位</p>
<ul>
<li><p>大定位</p>
<ul>
<li>名词</li>
</ul>
</li>
<li><p>精准定位</p>
<ul>
<li><p>冠词</p>
</li>
<li><p>否定词</p>
</li>
<li><p>逻辑关系词</p>
</li>
<li><p>介词</p>
</li>
<li><p>动词</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>预判答案</p>
<ul>
<li><p>名词占到80%，动词占10%，形容词、副词、数词共占10%</p>
</li>
<li><p>名词：预测是填专有/特殊/普通名词，<font color="orange">单数/复数</font>，人/物</p>
<ul>
<li>空前有known as / called / named / refer to as 一般填专有/特殊名词</li>
</ul>
</li>
<li><p>动词：预测原形/过去式/ing形式</p>
</li>
<li><p>注意：<font color="orange">答案形式没有动词+名词</font></p>
</li>
</ul>
</li>
<li><p>可从最容易定位、最简单的题目开始做，然后再往前往后找</p>
</li>
</ul>
<h1 id="摘要填空"><a href="#摘要填空" class="headerlink" title="摘要填空"></a>摘要填空</h1><p>该题目是一小段文字，是整篇文章或原文中的几个段落主要内容的缩写或改写，按照范围，摘要可分为两种：全文摘要和部分段落摘要。</p>
<p>全文摘要（20%）：题目标题与原文标题相似，题数较多</p>
<p>部分段落摘要（80%）：标题区别较大，题数较少。</p>
<h2 id="有单词列表的摘要填空"><a href="#有单词列表的摘要填空" class="headerlink" title="有单词列表的摘要填空"></a>有单词列表的摘要填空</h2><h3 id="题型特点-1"><a href="#题型特点-1" class="headerlink" title="题型特点"></a>题型特点</h3><ul>
<li><p>顺序性（偶尔小乱序，很少）</p>
</li>
<li><p>选项特点</p>
<ul>
<li><p>原文单词</p>
</li>
<li><p>词性变化</p>
</li>
<li><p>同义词</p>
</li>
<li><p>语态变化</p>
</li>
</ul>
</li>
<li><p>主要是否可以某个选项可以选多次</p>
</li>
</ul>
<h1 id="图表题"><a href="#图表题" class="headerlink" title="图表题"></a>图表题</h1><ul>
<li><p>原理图（Diagram）</p>
</li>
<li><p>流程图（Flow Chart）</p>
</li>
<li><p>统计表（Table）</p>
</li>
</ul>
<h2 id="题型特点-2"><a href="#题型特点-2" class="headerlink" title="题型特点"></a>题型特点</h2><ul>
<li><p>图上的提示信息在文中通常会原词重现</p>
</li>
<li><p>答案常常集中于原文中的一个或者两个段落</p>
</li>
<li><p>原文原词填空，不要做任何修改</p>
</li>
<li><p>顺序题目（小范围乱序，很少）</p>
</li>
</ul>
<h1 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h1><h2 id="题型特点-3"><a href="#题型特点-3" class="headerlink" title="题型特点"></a>题型特点</h2><ul>
<li><p>顺序性：题干顺序与原文顺序基本一致，<font color="orange">可以认为没有乱序</font></p>
</li>
<li><p>题目在原文中的分布是不均匀的，可能出现跨段出题</p>
</li>
</ul>
<h2 id="解题步骤-1"><a href="#解题步骤-1" class="headerlink" title="解题步骤"></a>解题步骤</h2><ul>
<li><p>在题干中选择至少两个定位词回文中定位</p>
</li>
<li><p>定位句一般为一到两个句子</p>
</li>
<li><p>一次划两个题目的定位词去文中找可以加快做题速度</p>
</li>
<li><p>选True的一般情况：</p>
<ul>
<li><p>题目是原文的原意表达，使用原词或者同义替换改写，通常运用同义词或同义结构</p>
</li>
<li><p>题目是对原文信息的概括或归纳总结（出现的情况很少）</p>
<ul>
<li><p>题目是对原文相邻的两个句子或同一段落中上下文信息的归纳总结</p>
</li>
<li><p>题目是对原文中不同自然段中的信息归纳总结</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选False的一般情况：</p>
<ul>
<li><p>使用反义词或者表达意思相反</p>
</li>
<li><p>绝对陈述</p>
</li>
</ul>
</li>
<li><p>选Not Given的情况：</p>
<ul>
<li><p>原文中无法找到定位句</p>
</li>
<li><p>可以找到定位句，到是无法得出相关信息，可能成立可能不成立</p>
</li>
</ul>
</li>
</ul>
<h1 id="配对题"><a href="#配对题" class="headerlink" title="配对题"></a>配对题</h1><h2 id="单词-句子配对题"><a href="#单词-句子配对题" class="headerlink" title="单词-句子配对题"></a>单词-句子配对题</h2><p>题干是单词，选项是句子 or 题干是句子，选项是单词</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><font color="orange">单词有顺序性（题干是单词就根据题干回原文中找，选项是单词就根据选项从原文中找）</font>，出题范围是全文，<font color="orange">如果单词是人名的话，在文中可能在前面出现一次完整的人名后，在后面使用人名简写，要注意</font></li>
<li>可以先看下选项和题目的个数，明确是否有多余选项（选项个数大于题目个数）或者是否一定会有重复选择（选项个数小于题目个数）的情况</li>
</ul>
<h2 id="半句配对题"><a href="#半句配对题" class="headerlink" title="半句配对题"></a>半句配对题</h2><p>题干是句子的一半，选项也是句子的一半</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><font color="orange">题干</font>大部分都有顺序性，出现乱序的情况较少</li>
</ul>
<h2 id="段落信息配对题"><a href="#段落信息配对题" class="headerlink" title="段落信息配对题"></a>段落信息配对题</h2><p>题干是句子，题目问句子对应文章中的哪一段</p>
<h3 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h3><ul>
<li><font color="orange">题目完全乱序</font>
</li>
<li><p>同义替换较复杂</p>
</li>
<li><p>多数情况下是题目只对应段落中的一个句子，也有少数题目对应段落中多个句子</p>
</li>
</ul>
<h3 id="解题步骤与技巧"><a href="#解题步骤与技巧" class="headerlink" title="解题步骤与技巧"></a>解题步骤与技巧</h3><ul>
<li><p>此类题型<font color="orange">最后做</font>，一般会与其他题型有交叉重合出题点</p>
</li>
<li><p>做题顺序：可以不按照题号顺序</p>
<ul>
<li><p>先做特征明显的，映像深刻的</p>
</li>
<li><p>剩余题目按照<font color="orange">文章段落顺序</font>寻找答案</p>
</li>
</ul>
</li>
<li><p>重点看<font color="orange">未出过题</font>的段落</p>
</li>
</ul>
<h2 id="分类配对题"><a href="#分类配对题" class="headerlink" title="分类配对题"></a>分类配对题</h2><p>题干是句子，题目让选择对应的类别——A类、B类、A类和B类都是，A类和B类都不是</p>
<h3 id="题目特点-1"><a href="#题目特点-1" class="headerlink" title="题目特点"></a>题目特点</h3><ul>
<li><p>小范围乱序</p>
</li>
<li><p>出题位置比较集中</p>
</li>
</ul>
<h3 id="解题步骤与技巧-1"><a href="#解题步骤与技巧-1" class="headerlink" title="解题步骤与技巧"></a>解题步骤与技巧</h3><ul>
<li><p>用选项大定位（确定出题段落）</p>
</li>
<li><p>划出题干关键字，去文中定位，分辨主语</p>
</li>
</ul>
<h1 id="主旨题"><a href="#主旨题" class="headerlink" title="主旨题"></a>主旨题</h1><h2 id="选标题"><a href="#选标题" class="headerlink" title="选标题"></a>选标题</h2><p>题干是段落序号，选项是段落主旨大意</p>
<h3 id="题型特点-4"><a href="#题型特点-4" class="headerlink" title="题型特点"></a>题型特点</h3><ul>
<li><font color="orange">完全乱序</font>
</li>
<li><p>出题位置特殊，如果出的话一定是文章的第一题</p>
</li>
<li><p>选项较多，具有干扰选项（选项数量超过题目数量）</p>
</li>
<li><p>两种类型：paragraph（给每一个小段选一个主旨，<font color="orange">大多数情况是这种类型</font>）；section（多个段落合起来选一个主旨），<font color="orange">当类型为paragraph类型时，不一定要给每一段都选，注意看题目</font></p>
</li>
</ul>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p><font color="orange">最后做</font>这种题，该题不会和段落信息配对题一起出现在一篇文章中</p>
</li>
<li><p>60%的段落会有主旨句，主旨句一般出现在段落的第一句、第二句或最后一句</p>
</li>
</ul>
<h1 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h1><p>选择题有多种类型，按形式划分可以分为：单选（4选1）和多选（5选2、7选3、10选5），按内容划分可以分为：细节型和总结型</p>
<ul>
<li><p>单选题型特点</p>
<ul>
<li><p>属于顺序题型，一段一题或一段两题</p>
</li>
<li><p>题目有时会告诉是在那段出题，出题位置也有可能在introduction段（标题和主体内容之间的一段用于说明的文字）</p>
</li>
<li><p>如果题目中出现原文原词的，大概率会是错误答案</p>
</li>
</ul>
</li>
<li><p>多选题特点</p>
<ul>
<li><p>按答对个数给分</p>
</li>
<li><p>答案在文中出现的位置通常是密集的</p>
</li>
<li><p>如果题目中出现原文原词的，大概率会是错误答案</p>
</li>
</ul>
</li>
</ul>
<h1 id="做题心得"><a href="#做题心得" class="headerlink" title="做题心得"></a>做题心得</h1><ul>
<li><p>那些最后做的题（段落信息配对、主旨题）不一定要所有都最后做，建议提前画好关键词，可以边看边做一些明显的题，等到最后再来做那些不太好确定的题</p>
</li>
<li><p>看清题目，到底是说xxx是好的还是不好的（是advantage还是disadvantage，是practical还是impractical）</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/11/24/IELTS/IELTS-Writing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/24/IELTS/IELTS-Writing/" class="post-title-link" itemprop="url">IELTS-Writing</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-24 02:52:14" itemprop="dateCreated datePublished" datetime="2022-11-24T02:52:14-05:00">2022-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-07 10:17:56" itemprop="dateModified" datetime="2023-07-07T10:17:56-04:00">2023-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IELTS/" itemprop="url" rel="index">
                    <span itemprop="name">IELTS</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h1><p>雅思写作分有两个task，task 1是图表题，task 2是议论题。写作考试时间为60分钟。task 1一般花20分钟（task 1占总分的1/3），task 2一般花40分钟（task 2占总分的2/3）。</p>
<h1 id="Task-1：小作文"><a href="#Task-1：小作文" class="headerlink" title="Task 1：小作文"></a>Task 1：小作文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>task 1 为图表题，一般有6种小题型，分为两大类：</p>
<p><img title src="/2022/11/24/IELTS/IELTS-Writing/task_1.png" alt="task1" data-align="center" width="714"></p>
<p>第一类：数据类—— line chart、pie chart、bar chart、table</p>
<p>第二类：描述类—— flow chart、map</p>
<h2 id="第一类小作文写作方式"><a href="#第一类小作文写作方式" class="headerlink" title="第一类小作文写作方式"></a>第一类小作文写作方式</h2><p>第一类一般分为4-5段：</p>
<ul>
<li><p>开头段</p>
</li>
<li><p>overview段</p>
</li>
<li><p>主体段1</p>
</li>
<li><p>主体段2</p>
</li>
<li><p>主体段3（optional）</p>
</li>
</ul>
<h3 id="开头段"><a href="#开头段" class="headerlink" title="开头段"></a>开头段</h3><p>根据题目进行改写即可，能换则换，做到中规中矩（不追求写的很好），不抄题，不出语法错误。</p>
<p>步骤：</p>
<ol>
<li><p>改图描述了xxx</p>
<ul>
<li><p>the graph/diagram/chart (line chart / pie chart / bar chart / flow chart / flow chart / map)</p>
</li>
<li><p>不要写below/above</p>
</li>
<li><p>描述 show=compare=illustrate=demonstrate=give us the information of（最好的替换词就是compare和illustrate——考官说的）</p>
</li>
<li><p>混合图需要对每个图都进行说明</p>
</li>
<li><p>given is a xxx chart that illustrate xxx</p>
</li>
</ul>
</li>
<li><p>主体结构能改则改</p>
<ul>
<li>主动换被动/复杂结构（从句）/ 名词动词词性转换</li>
</ul>
</li>
<li><p>地点概述、列举即可（题目概述你列举，题目列举你概述）</p>
<ul>
<li>in the four countries (including)</li>
<li>in terms of four distinct ways</li>
<li>namely xxx, xxx</li>
</ul>
</li>
<li><p>时间</p>
<ul>
<li><p>between … and … = from … to</p>
</li>
<li><p>during … years/during the period from … to …/during the period shown/in a period spanning xxx years</p>
</li>
</ul>
</li>
</ol>
<h3 id="overview段"><a href="#overview段" class="headerlink" title="overview段"></a>overview段</h3><ul>
<li><font color="orange">概述主要内容或主要变化，显而易见的不需要进行写出</font>
</li>
<li><p><font color="orange">不要提到具体数据</font>，使用一些概括性的描述（xxx是最大、xxx是最小、xxx上升非常多、……）</p>
</li>
<li><p>尽量去描述大范围的概括性，尤其是对于静态图，例如有两个图标，有一些共同的特征，可以将两个图表放在一起概括而不是分别概括</p>
</li>
</ul>
<p>开头句式：It is clear that … / It is noticable that … / Overall, …</p>
<h3 id="主体段"><a href="#主体段" class="headerlink" title="主体段"></a>主体段</h3><h4 id="分段方式"><a href="#分段方式" class="headerlink" title="分段方式"></a>分段方式</h4><ul>
<li><font color="orange">混合图99%的情况下都是一图一段</font>
</li>
<li><p>在各个图例都很类似的情况下可以按照年份划分，如果图例差别较大，首先按照相似的几个划为一类来分</p>
</li>
</ul>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol>
<li><p>数据排列的顺序：从小到大/主要到次要，不可以跳跃式</p>
</li>
<li><p>篇幅的占比：不要过度关注细节，主要内容用复杂句式结构，次要信息合并描写</p>
</li>
<li><p><font color="orange">衔接手段</font>：段落间有衔接（词、短语、一句话），句子间有衔接（similarly，by contrast，on the contrary，however, while, whereas）</p>
</li>
<li><p>指代：避免重复，使用代词替换，或者用从句加代词（which is less than that in …）</p>
</li>
<li><p>词汇多样性：避免重复用一个单词表达一个意思</p>
</li>
<li><p>句式多样性：无语法错误前提下，使用复杂结构（there be句式、被动语态、定语从句、分词做状语、让步状语从句（尽管…，即使…））</p>
</li>
<li><p>注意时间、时态、最大值、单位</p>
</li>
<li><p><font color="orange">数据支持</font>：作文中提到的数据最好要超过题目中的一半以上</p>
</li>
</ol>
<ul>
<li><p>用于描述趋势的词/短语</p>
<ul>
<li><p>上升：increase/rise/grow/soar(急剧上升)</p>
</li>
<li><p>下降：decrease/decline/fall/drop/plummeted</p>
</li>
<li><p>保持不变：level off/remain stable/remain constant</p>
</li>
<li><p>波动：fluctuate</p>
</li>
</ul>
</li>
<li><p>用于描述幅度的词/短语</p>
<ul>
<li><p>sharp/dramatic/steep/significant</p>
</li>
<li><p>gradual/moderate/modest/slight</p>
</li>
</ul>
</li>
<li><p>线性图变化趋势描述句型</p>
<ul>
<li><p>there be + adj + n：there was a steep increase in sales of convenience food.</p>
</li>
<li><p>verb + adverb: Sales of convenience food increased steeply</p>
</li>
<li><p>something/year saw a xxx</p>
</li>
</ul>
</li>
</ul>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>线图可以写的内容</p>
<ol>
<li><p>点=起点、终点、最值、交点（数据不多的情况下起点可以自成一段）</p>
<ol>
<li><p>起点：数据不多的情况下，起点一般单独一段</p>
</li>
<li><p>终点：一般融在线里描写，如decrease to 9</p>
</li>
<li><p>最值：最大值一般单独写一句话（最小值视情况），有时半句</p>
</li>
<li><p>交点：一般不单独出现，写在线里</p>
</li>
</ol>
</li>
<li><p>线=趋势+幅度</p>
<ol>
<li><p>趋势：上升、下降、波动、稳定</p>
</li>
<li><p>幅度：大幅度/小幅度</p>
</li>
</ol>
</li>
<li><p>线与线=关系</p>
<ol>
<li><p>相似-用连接词连接（smilarly）</p>
</li>
<li><p>相反-用衔接词连接（by contrast）</p>
</li>
<li><p>交叉-用超过表达=overtake/surpass</p>
</li>
</ol>
</li>
</ol>
<font color="orange">note: 当条形图的横坐标为时间的时候，它本质就是一个线图，这时可以按照线图的逻辑来写</font>

<h3 id="第一类小作文常用同义表达"><a href="#第一类小作文常用同义表达" class="headerlink" title="第一类小作文常用同义表达"></a>第一类小作文常用同义表达</h3><ul>
<li><p>表示“大约”</p>
<ul>
<li><p>approximately</p>
</li>
<li><p>about</p>
</li>
<li><p>around</p>
</li>
<li><p>roughly</p>
</li>
</ul>
</li>
<li><p>表示“是最大”</p>
<ul>
<li><p>provided the most xxx</p>
</li>
<li><p>ranked at first</p>
</li>
<li><p>对于售卖可以用：become the best selling xxx</p>
</li>
</ul>
</li>
<li><p>接数据的一些表达</p>
<ul>
<li><p>to xxx</p>
</li>
<li><p>peaking at xxx</p>
</li>
<li><p>reaching xxx</p>
</li>
<li><p>with xxx</p>
</li>
<li><p>with approximately of xxx</p>
</li>
</ul>
</li>
<li><p>连续提到多个数据的一些表达</p>
<ul>
<li>xxx and xxx each xxx</li>
</ul>
</li>
<li><p>表示“花销”</p>
<ul>
<li>expenditure</li>
<li>budget</li>
<li>spending</li>
</ul>
</li>
<li><p>表示相似/想反增长和下降趋势</p>
<ul>
<li><p>experienced the same/opposite change inclinations inclinations</p>
</li>
<li><p>experienced similar/opposite tendencies of rises and falls</p>
</li>
</ul>
</li>
</ul>
<h2 id="第二类小作文写作方式"><a href="#第二类小作文写作方式" class="headerlink" title="第二类小作文写作方式"></a>第二类小作文写作方式</h2><h3 id="流程图（flow-chart）"><a href="#流程图（flow-chart）" class="headerlink" title="流程图（flow chart）"></a>流程图（flow chart）</h3><p>和第一类一样，流程图写作也分为4到5段：</p>
<ul>
<li><p>开头段（和第一类一样，都是改写题目）</p>
</li>
<li><p>overview段（<font color="orange">不同于第一类</font>，需要写如下内容）</p>
<ul>
<li><p>写流程图包括几个步骤、从xxx开始到xxx结束，包含几个原材料（optional）</p>
</li>
<li><p>有多个图则需要<font color="orange">每个图</font>写包含几个步骤，从xxx开始到xxx结束</p>
</li>
</ul>
</li>
<li><p>主体一段</p>
</li>
<li><p>主体二段（如果题目有两个流程图，自然按两个图进行分段，如果题目只有一个图，主题也要至少分为两段，分段一般是将前几个步骤分为一段，后几个步骤分为一段，需要视情况而定）</p>
</li>
<li><p>主体三段（optional）</p>
</li>
</ul>
<p>要点：</p>
<ul>
<li><font color="orange">使用一般现在时</font>
</li>
<li><p><font color="orange">不能</font>使用祈使句（动词做主语），也不可以写成操作指南（we can xxx），所以99%都要使用被动语态</p>
</li>
<li><p>流程图中的词<font color="orange">不能</font>做同义替换</p>
</li>
<li><p>每句话之间一定要有连接词</p>
</li>
</ul>
<h4 id="流程图overview段短语"><a href="#流程图overview段短语" class="headerlink" title="流程图overview段短语"></a>流程图overview段短语</h4><ul>
<li><p>包括几个步骤：</p>
<ul>
<li><p>consist of </p>
</li>
<li><p>is composed of x stages/steps</p>
</li>
<li><p>include</p>
</li>
</ul>
</li>
<li><p>从…开始到…结束：starting from … and ending in ….</p>
</li>
<li><p>总之：overall，in summary， all in all</p>
</li>
</ul>
<p>例句：</p>
<blockquote>
<p>Overall, cement production consists of 5 stages, starting from crushing materials into powder and ending in bagging cement. In contrast, concrete production is simple, mixing four materials.</p>
</blockquote>
<h4 id="流程图表示阶段的短语"><a href="#流程图表示阶段的短语" class="headerlink" title="流程图表示阶段的短语"></a>流程图表示阶段的短语</h4><ul>
<li><p>开始阶段</p>
<ul>
<li><p>Firstly/First of all</p>
</li>
<li><p>To begin with</p>
</li>
<li><p>At the first stage</p>
</li>
<li><p>During the begining phase</p>
</li>
<li><p>The process starts from</p>
</li>
</ul>
</li>
<li><p>次阶段</p>
<ul>
<li><p>before、until、after</p>
</li>
<li><p>next、Secondly</p>
</li>
<li><p>at the next stage</p>
</li>
<li><p>the next step in the process is xxx</p>
</li>
<li><p>then</p>
</li>
<li><p>finally</p>
</li>
<li><p>the following stage is</p>
</li>
</ul>
</li>
</ul>
<h4 id="流程图表示过程的短语"><a href="#流程图表示过程的短语" class="headerlink" title="流程图表示过程的短语"></a>流程图表示过程的短语</h4><ul>
<li><p>传送：</p>
<ul>
<li><p>deliver</p>
</li>
<li><p>send</p>
</li>
<li><p>transfer</p>
</li>
<li><p>transport</p>
</li>
</ul>
</li>
<li><p>转化</p>
<ul>
<li><p>convert into</p>
</li>
<li><p>transform into</p>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>utilize</p>
</li>
<li><p>use</p>
</li>
</ul>
</li>
</ul>
<h4 id="流程图废话文学操作"><a href="#流程图废话文学操作" class="headerlink" title="流程图废话文学操作"></a>流程图废话文学操作</h4><p>在一些情况下流程图的流程比较简单，尤其是只有一个图的情况下，按照全流程写下来有时候可能不够150个字，可以用以下方法来扩写</p>
<ul>
<li><p>选用复杂的顺序词</p>
</li>
<li><p>写废话</p>
<ul>
<li>as can be seen/observed</li>
</ul>
</li>
<li><p>扩写overview段</p>
<ul>
<li><p>the process 改写成the process of xxx</p>
</li>
<li><p>强行分为几个大步骤，每个大步骤分别说starting from xxx and ending in xxx</p>
</li>
</ul>
</li>
</ul>
<h3 id="地图（map）"><a href="#地图（map）" class="headerlink" title="地图（map）"></a>地图（map）</h3><p>地图写作也分为4到5段：</p>
<ul>
<li><p>开头段（和第一类一样，都是改写题目）</p>
</li>
<li><p>overview段（概括变化，简单提及一些重要变化即可）</p>
</li>
<li><p>主体一段</p>
</li>
<li><p>主体二段</p>
</li>
<li><p>主体三段（optional）</p>
</li>
</ul>
<h2 id="主体写作逻辑"><a href="#主体写作逻辑" class="headerlink" title="主体写作逻辑"></a>主体写作逻辑</h2><ul>
<li><p>先写新增的</p>
</li>
<li><p>再被代替的</p>
</li>
<li><p>然后写消失的</p>
</li>
<li><p>最后写扩建、减少的</p>
</li>
</ul>
<h4 id="地图写作常用词汇短语"><a href="#地图写作常用词汇短语" class="headerlink" title="地图写作常用词汇短语"></a>地图写作常用词汇短语</h4><ul>
<li><p>make something bigger</p>
<ul>
<li><p>extend</p>
</li>
<li><p>expand</p>
</li>
</ul>
</li>
<li><p>make something new again/modern</p>
<ul>
<li><p>renovate</p>
</li>
<li><p>modernise</p>
</li>
</ul>
</li>
<li><p>take something away and put something else in its place</p>
<ul>
<li>replace</li>
</ul>
</li>
<li><p>make something better</p>
<ul>
<li>improve</li>
</ul>
</li>
<li><p>make something smaller</p>
<ul>
<li>reduce</li>
</ul>
</li>
<li><p>build serveral buildings in an area where there was nothing</p>
<ul>
<li>develop</li>
</ul>
</li>
<li><p>put in something totally new</p>
<ul>
<li>add</li>
</ul>
</li>
<li><p>take something away</p>
<ul>
<li>remove</li>
</ul>
</li>
<li><p>build something again</p>
<ul>
<li>reconstruct</li>
</ul>
</li>
<li><p>表示数量增多/面积扩大</p>
<ul>
<li><p>double</p>
<ul>
<li>The number of dwelling places doubled to 200</li>
</ul>
</li>
<li><p>expand/extend/enlarge/develop/rise/grow/increase/improve</p>
<ul>
<li>Dwelling places was expanded to twice its size.</li>
</ul>
</li>
<li><p>become/turn/get + bigger / larger / smaller</p>
<ul>
<li>Dwelling places become bigger</li>
</ul>
</li>
</ul>
</li>
<li><p>表示数量减少/面积缩小</p>
<ul>
<li><p>reduce/decline/decrease/drop/fall/shrink</p>
<ul>
<li><p>The number of A dropped by half</p>
</li>
<li><p>The size of A was reduced to only half of / one third of the original isze</p>
</li>
<li><p>Woods shrank in size</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表示“替换”，即A消失+B出现</p>
<ul>
<li><p>replace/remove/convert/give way to</p>
<ul>
<li><p>A was replaced by B</p>
</li>
<li><p>A was removed</p>
</li>
<li><p>A was converted to B</p>
</li>
<li><p>A gave way to B</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表示新增</p>
<ul>
<li><p>build in/constructed in/add to</p>
<ul>
<li>A road was built in the north of the area</li>
</ul>
</li>
</ul>
</li>
<li><p>表示消失</p>
<ul>
<li>disappear/be no longer there</li>
</ul>
</li>
<li><p>地图表示方位的时候，注意介词的使用</p>
<ul>
<li><p>To 表示在外面的方位</p>
</li>
<li><p>In 表示在里面的方位</p>
</li>
</ul>
</li>
</ul>
<h1 id="不太好的表达收集"><a href="#不太好的表达收集" class="headerlink" title="不太好的表达收集"></a>不太好的表达收集</h1><ul>
<li><p>The other four proportions between 2003 and 2013 from less to more is xxx, xxx, xxx, xxx</p>
<ul>
<li>分析：这样表达没有提到数据，就是无效的表达，可以先说前两个数据，再说followed by 后两个数据</li>
</ul>
</li>
<li><p>There located xxx, There saw xxx</p>
<ul>
<li>分析：这样表达不太书面，记住在写作中用There的情况只有There be句型就行</li>
</ul>
</li>
<li><p>from 210 to 810 and 200 to 800 thousand, respectively</p>
<ul>
<li>改为from 210 and 200 to 810 and 800, respectively</li>
</ul>
</li>
</ul>
<h1 id="小作文优秀例句摘抄"><a href="#小作文优秀例句摘抄" class="headerlink" title="小作文优秀例句摘抄"></a>小作文优秀例句摘抄</h1><blockquote>
<p>Samsung and Apple <font color="orange">saw</font> the biggest rises in sales over the 5-year period</p>
<p>The table compares the five highest ranking countries <font color="orange">in terms of</font> the number of visitors and money spent by tourists over a period of two years.</p>
<p>It is clear that France was the world’s most popular tourist destination. // 说数据不一定要说数据排第一，可以用其他符合语境的表达，这里就是是最受欢迎的旅游目的地。</p>
<p>2013 <font color="orange">saw</font> a rise of between 1 and 4 million tourist visitors to each country <font color="orange">with the exception of</font> China, <font color="orange">which</font> received 2 million fewer visitors than in the previous year.</p>
<p>Generally, the percentage of moviegoers from all ages experienced the same change inclination, despite minor fluctuations.</p>
<p>In the first 10 years, osillations of differing extends can be observed in the figures for all group</p>
<p>These figures were <font color="orange">well over twice as high as</font> those for any other country</p>
<p>UK residents spent a significantly larger percentage of their household budgets on leisure than their New Zealand <font color="orange">counterparts</font>.</p>
<p>In 1980, 29% of an avarage New zealand budget <font color="orange">went on</font> food and drink, while <font color="orange">the equivalent figure</font> for UK was 23%</p>
<p><font color="orange">Looking at the age profile pie chart</font>, we can see that the majority of people attending evening lessons were over 40 years of age. <font color="orange">To be precise</font>, 42% of them were aged 50 or more and 26% were aged between 40 and 49.</p>
<p><font color="orange">The same increasing tendency was also witnessed by</font> female full-time and students, xxx</p>
</blockquote>
<h1 id="小作文写作心得"><a href="#小作文写作心得" class="headerlink" title="小作文写作心得"></a>小作文写作心得</h1><ul>
<li>写的时候不必太过于纠结一些描述的替换，如果想到了就换，没想到重复写也行，但是可以在重复的地方做些小标记，首先要关注于完成文章，完成文章后，如果有多的时间，再回去看重复的地方能否替换为其他的表达。</li>
<li>开头段一定要写全面（时间、地点、分类），如果时间不是连续的时间，而是几个离散的时间，可以用in xx separate years来概括。</li>
<li><font color="orange">小作文的Overview段最好能够写两句</font>。</li>
<li>尽量多的使用连接词</li>
</ul>
<h1 id="Task-2：大作文"><a href="#Task-2：大作文" class="headerlink" title="Task 2：大作文"></a>Task 2：大作文</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>task 2  为议论题，有四种小题型：</p>
<ul>
<li><p>双边讨论：Discuss both views and give your opinion</p>
</li>
<li><p>单边选择：To What extend do you agree or disagree</p>
</li>
<li><p>利弊分析：Do advantages outweigh disadvantages ? / Is this a positive or negative development ?</p>
</li>
<li><p>说明文：What are the reasons ?  what can be done to solve it?</p>
</li>
</ul>
<h2 id="双边讨论写作方法"><a href="#双边讨论写作方法" class="headerlink" title="双边讨论写作方法"></a>双边讨论写作方法</h2><p>双边讨论写作内容需要包括去分别描述两种观点+给出自己观点（自己的观点可以是偏好某一种观点或者是认为两种观点同等重要）</p>
<p>分段一般分为4到5段：</p>
<ul>
<li><p>开头段：<font color="orange">不能</font>再改写题目，一般写两句话：话题引入+表达自己观点，<font color="orange">表达自己的观点也要提及题目的两个观点，可以使用让步状语从句</font></p>
</li>
<li><p>主体段1：描写观点1，给出支撑观点1的理由</p>
</li>
<li><p>主体段2：描写观点2，给出支撑观点2的理由</p>
</li>
<li><p>主体段3 (optional)：写自己的观点，如果在开头段和结尾段中给出了自己的观点，那么可以省略该段</p>
</li>
<li><p>结尾段：总结+<font color="orange">给出自己的观点</font></p>
</li>
</ul>
<h3 id="开头段可用的句型"><a href="#开头段可用的句型" class="headerlink" title="开头段可用的句型"></a>开头段可用的句型</h3><ul>
<li><p>话题引入：</p>
<ul>
<li>whether xxx (and xxx) has/have aroused widespread controversy</li>
</ul>
</li>
<li><p>表达自己观点：</p>
<ul>
<li><p>in my opinion / in my point of view</p>
</li>
<li><p>as far as I am concerned</p>
</li>
<li><p>from my perspective</p>
</li>
</ul>
</li>
</ul>
<h3 id="主体段写作方式"><a href="#主体段写作方式" class="headerlink" title="主体段写作方式"></a>主体段写作方式</h3><p>双边讨论主题段的写作通常都采用On the one hand, …, On the other hand,… 来分别引出两段。（在一段内表示两个方面可以用For one thing, xxx. For another, xxx）</p>
<font color="orange">每一个观点最好要给点例子，而且例子最好不要用太长的话，并且做好用国外的例子</font>

<h2 id="单边选择写作方式"><a href="#单边选择写作方式" class="headerlink" title="单边选择写作方式"></a>单边选择写作方式</h2><p>单边选择只需要写出选择支持的一方的观点就行，不需要写出支持的另一方</p>
<h2 id="利弊分析写作方式"><a href="#利弊分析写作方式" class="headerlink" title="利弊分析写作方式"></a>利弊分析写作方式</h2><p>利弊分析需要分为5段：如果认为利大于弊，则利需要写两段，弊写一段，反之亦然</p>
<h2 id="大作文话题积累："><a href="#大作文话题积累：" class="headerlink" title="大作文话题积累："></a>大作文话题积累：</h2><ul>
<li><p>教育：引申出的话题：</p>
<ul>
<li><p>现在的学业</p>
</li>
<li><p>未来的就业</p>
</li>
<li><p>学生的性格养成</p>
</li>
<li><p>教育平等 =&gt; 减少贫富差距 =&gt; 促进社会稳定</p>
</li>
<li><p>社交媒体/名人网红 对青少年行为的影响</p>
</li>
<li><p>相关词汇积累：</p>
<ul>
<li>education，career，character，unemployment rate，</li>
</ul>
</li>
</ul>
</li>
<li><p>政府: 引申出来的话题：</p>
<ul>
<li><p>政府的权利与责任</p>
<ul>
<li><p>权利：formulate policies，enact laws，impose taxes</p>
</li>
<li><p>责任：provide public services（education、healthcare、infrastructure）</p>
</li>
</ul>
</li>
<li><p>政府的运作</p>
<ul>
<li><p>政府资金来源：taxes（taxpayer）</p>
</li>
<li><p>政府资金去向：public services，如果政府对某些public service增加资金投入，那么对于其他的public service的投入必然相对来说会减少（financial burden）。</p>
</li>
</ul>
</li>
<li><p>公民的权利与责任</p>
<ul>
<li><p>权利：人权（human right），自由（freedom）</p>
</li>
<li><p>责任：保护环境（protect the environment），承担自己的行为带来的后果（bear the consequences of their own actions），纳税（pay the tax）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>环境：引申出来的话题：</p>
<ul>
<li><p>全球变暖</p>
</li>
<li><p>垃圾问题：</p>
</li>
<li><p>相关词汇积累：</p>
<ul>
<li>global warming, greenhouse effect，the imporper disposal of waste，non-degradable，air pollution，species，extinction</li>
</ul>
</li>
</ul>
</li>
<li><p>媒体新闻</p>
<ul>
<li><p>媒体人责任</p>
</li>
<li><p>关注喜爱度</p>
</li>
<li><p>政治观点的宣传</p>
</li>
</ul>
</li>
<li><p>工作</p>
<ul>
<li><p>工资：用于满足基本生活的需要（meet basic needs）和过上有品质的生活（have a reasonable quality of life）</p>
</li>
<li><p>工作氛围和公司福利条件</p>
</li>
<li><p>工作的稳定性和后续职业的发展</p>
</li>
<li><p>工作的不可替代性</p>
</li>
<li><p>对于社会和国家的贡献</p>
</li>
</ul>
</li>
<li><p>幸福</p>
<ul>
<li><p>满足需求：物质层面 or 精神层面</p>
</li>
<li><p>健康的身体、家人朋友的陪伴、安全的住所、稳定的收入</p>
</li>
</ul>
</li>
</ul>
<h1 id="大作文自己没有想到的表达"><a href="#大作文自己没有想到的表达" class="headerlink" title="大作文自己没有想到的表达"></a>大作文自己没有想到的表达</h1><ul>
<li><p>生态平衡：ecological balance</p>
</li>
<li><p>破坏生物多样性：destroy/ruin the biodiversity</p>
</li>
<li><p>在某种程度上：to an extend</p>
</li>
<li><p>碳酸饮料：carbonated beverage</p>
</li>
<li><p>论坛网站：forum site</p>
</li>
<li><p>体罚：corporal punishment</p>
</li>
<li><p>acquire informations: 获取信息</p>
</li>
<li><p>none other than = only</p>
</li>
<li><p>should be concentrated more</p>
</li>
<li><p>are provided with more opportunities = have opportunities</p>
</li>
</ul>
<h1 id="大作文自己需要注意的点"><a href="#大作文自己需要注意的点" class="headerlink" title="大作文自己需要注意的点"></a>大作文自己需要注意的点</h1><ul>
<li><font color="orange">避免不相关的描述，回答问题+观点清晰，不要过度描写细节，如果某些内容可有可无，在不影响总字数的前提下，就删去</font>
</li>
<li><p>分句：一个句子只能有一个主语，如果要一句话有多个主语一定要用从句或者加上连接词</p>
</li>
<li><p>不要写缩写，例如were not不要写成weren’t，should not不要写成shouldn’t</p>
</li>
<li><p>如果优缺点有某个方面想不出来太多，可以用这样的表达：there are many good/bad impacts, and the most imperative one is xxx</p>
</li>
<li><font color="orange">不要随意的加人称代词，注意人称指代要写正确，主格宾格要写正确</font>
</li>
<li><p>不要写排比句，英文没有排比句，一定要加衔接词</p>
</li>
<li><p>to be blame 不要写出 to be blamed for</p>
</li>
<li><p>be taken <u>with</u> more notice</p>
</li>
<li><p>结尾段简单总和下自己的观点</p>
</li>
<li><p>不要写一些特别简单的表达，例如：good、can have</p>
</li>
</ul>
<h1 id="大作文审题总结"><a href="#大作文审题总结" class="headerlink" title="大作文审题总结"></a>大作文审题总结</h1><ul>
<li><p>看题目说的是哪个层面的问题，一般分为三个层面：个人/社会/国家</p>
</li>
<li><p>看到个人要联想到的话题：</p>
<ul>
<li>人权</li>
<li>个人性格养成</li>
<li>未来就业</li>
</ul>
</li>
<li><p>看到社会要联想到的话题</p>
<ul>
<li><p>就业</p>
</li>
<li><p>经济</p>
</li>
<li><p>社会价值观</p>
</li>
<li><p>公平</p>
</li>
<li><p>教育</p>
</li>
<li><p>贫富差距</p>
</li>
<li><p>稳定</p>
</li>
<li><p>环境</p>
</li>
<li><p>福利待遇</p>
</li>
</ul>
</li>
<li><p>看到国家要联想到的话题</p>
<ul>
<li><p>全球化</p>
</li>
<li><p>旅游业</p>
</li>
<li><p>民族凝聚力</p>
</li>
<li><p>国家形象</p>
</li>
<li><p>国际关系</p>
</li>
</ul>
</li>
</ul>
<h1 id="常用的改写句型"><a href="#常用的改写句型" class="headerlink" title="常用的改写句型"></a>常用的改写句型</h1><ul>
<li><p>被动句</p>
</li>
<li><p>强调句</p>
</li>
<li><p>双重否定句</p>
</li>
<li><p>倒装句</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/05/05/devops/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/devops/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">k8s常用命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-05 01:13:19 / Modified: 01:15:58" itemprop="dateCreated datePublished" datetime="2022-05-05T01:13:19-04:00">2022-05-05</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>37</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h1><ul>
<li><p><code>kubectl config get-contexts</code></p>
<ul>
<li>查看当前有哪些集群context可以使用</li>
</ul>
</li>
<li><p><code>kubectl config use-context &lt;context name&gt;</code></p>
<ul>
<li>切换kubectl当前的集群context</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/05/02/linux/linux%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/02/linux/linux%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">linux网络</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-02 19:12:34" itemprop="dateCreated datePublished" datetime="2022-05-02T19:12:34-04:00">2022-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-05 03:01:07" itemprop="dateModified" datetime="2022-05-05T03:01:07-04:00">2022-05-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>301</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由可以分为以下三种：</p>
<ul>
<li><p>主机路由：表示到某台具体主机的路由（目前来说很少使用了）</p>
</li>
<li><p>网络路由：表达到某个网段的路由</p>
</li>
<li><p>默认路由：即<code>0.0.0.0/0</code>对应的路由项，它用于在路由表中查不到匹配项时进行的默认路由</p>
</li>
</ul>
<font color="orange">路由表的匹配采用最长匹配的原则</font>

<p>路由表不用记录同一网段中的其他主机的ip，同一网络中的主机通信直接通过数据链路层的ARP协议查询到IP地址对应的MAC地址后进行通信即可。</p>
<h2 id="linux路由表组成部分"><a href="#linux路由表组成部分" class="headerlink" title="linux路由表组成部分"></a>linux路由表组成部分</h2><p>在linux中可以使用<code>ip route</code>命令来查看路由表。路由表项由以下几个部分组成：</p>
<ul>
<li><p>destination：路由目标路径</p>
</li>
<li><p>interface：路由器的出口</p>
</li>
<li><p>gateway</p>
<ul>
<li><p>直连情况（即两个ip之间没有通过路由器相连）：不需要配置gateway，或者值为0.0.0.0</p>
</li>
<li><p>非直连情况：需要配置gateway，其值为下一个路由器在本网络中（当路由器对接多个网络时，会有多个网络地址）的ip地址</p>
</li>
</ul>
</li>
</ul>
<h2 id="路由表配置"><a href="#路由表配置" class="headerlink" title="路由表配置"></a>路由表配置</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/04/03/devops/k8s/pod%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/devops/k8s/pod%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">pod详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 21:57:13" itemprop="dateCreated datePublished" datetime="2022-04-03T21:57:13-04:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2026-01-13 12:33:26" itemprop="dateModified" datetime="2026-01-13T12:33:26-05:00">2026-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index">
                    <span itemprop="name">k8s</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>pod是k8s集群中的最小调度单元，一个pod中可以有多个容器。k8s引入pod，而不直接对容器进行调度的原因有如下两个：</p>
<ul>
<li><p>一个是为了将容器的实现和k8s平台自身引擎的实现进行解耦，从而做到可以支持多种类型的容器（docker、rkt）</p>
</li>
<li><p>另外一个是可以让多个容器共享网络、存储、进程空间，减少资源消耗</p>
</li>
</ul>
<h1 id="使用yaml定义一个pod"><a href="#使用yaml定义一个pod" class="headerlink" title="使用yaml定义一个pod"></a>使用yaml定义一个pod</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment">#pod name</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment">#命名空间，如果无该字段，则使用默认命名空间</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#pod标签，可选</span></span><br><span class="line">   <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line">   <span class="attr">key2:</span> <span class="string">value2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 挂载目录，有多种挂载方式 </span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment">#容器的名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="comment">#容器使用的镜像</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 容器访问</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> </span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 容器环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br></pre></td></tr></table></figure>
<p>定义好一个pod描述之后，就可以使用<code>kubectl create -f xxx.yaml</code>来创建一个pod</p>
<h1 id="pod的常用操作"><a href="#pod的常用操作" class="headerlink" title="pod的常用操作"></a>pod的常用操作</h1><ul>
<li><p>查看pod被调度的节点已经pod ip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; get pod -o wide</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看pod的配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; get pod &lt;pod name&gt; -o &lt;yaml|json&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看pod的信息及事件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; describe pod &lt;pod name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入pod内的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; exec &lt;pod name&gt; -c &lt;container name&gt; -it /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看pod内容器日志，显示标准或者错误输出日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; logs -f &lt;pod name&gt; -c &lt;container name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;pod yaml file&gt; # 更新pod是使用更新yaml文件的形式</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f &lt;pod yaml file&gt; # 根据配置文件删除</span><br><span class="line">kubectl -n &lt;namespace&gt; delete pod &lt;pod name&gt; # 根据pod name删除</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Pod健康检查"><a href="#Pod健康检查" class="headerlink" title="Pod健康检查"></a>Pod健康检查</h1><p>pod的健康检查由kubelet来进行，pod健康检查有两种机制：</p>
<ul>
<li><p>LivenessProbe：存活性探测，用于判断容器是否存活，即pod是否为running状态。如果LivenessProbe探针探测到容器不健康，则kubelet将kill掉容器，并根据容器的重启策略是否重启（如果不配置，默认会进行重启），如果一个容器不包含LivenessProbe探针，则kubelet认为容器的LivenessProbe探针的返回值永远成功，即任务容器是健康的。 </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span> <span class="comment">#有三种类型：exec(执行脚本，脚本返回0表示健康)、</span></span><br><span class="line">               <span class="comment">#httpGet(返回200-399状态码表示健康)、</span></span><br><span class="line">               <span class="comment">#tcpSocket(如果能够建立TCP连接，则表示健康)</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">        <span class="attr">scheme:</span> </span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="comment"># 容器启动后多少秒后第一次执行探测</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="comment"># 多少秒执行一次探，默认10s，最小1s，</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="comment"># 探测超时时间默认1s，最小1</span></span><br><span class="line">      <span class="attr">successThreshold:</span> <span class="comment"># 连续探测成功多少次才被认为是成功，默认为为1</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="comment"># 连续探测失败多少次才被任务是失败，默认为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ReadinessProbe：可用性探测，用于判断容器是否正常提供服务，即容器的Ready是否为True，是否可以接收请求。如果ReadinessProbe探测失败，则容器的ready将为False，Endpoint Controller控制器会将此Pod的Endpoint从对应的service的Endpoint列表中移除，不再将任何请求调度到此Pod上，直到下次探测成功。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">        <span class="attr">scheme:</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="comment"># 容器启动后多少秒后第一次执行探测</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="comment"># 多少秒执行一次探测</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="comment"># 探测超时时间</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<font color="orange">对于同一个容器，两种健康检查可以同时设置。</font>

<h1 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h1><font color="orange">Pod的重启策略应用于Pod内的所有容器，并且仅在Pod所处的Node上由Kubelet进行判断和重启操作。</font>当某个容器异常退出或者健康检查失败时，kubelet将根据RestartPolicy的设置来进行相应的操作。Pod的重启策略包括Always、OnFailure和Never，默认值为Always。

* Always：当容器进程退出后，由kubelet自动重启该容器

* OnFailure：当容器进程终止运行且退出码不为0时，由kubelet自动重启该容器

* Never：不论容器运行状态如何，kubelet都不会重启该容器

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">containers:</span></span><br></pre></td></tr></table></figure>

# 镜像拉取策略

有如下几种镜像拉取策略：

* Always：总是拉取镜像，即使本地有镜像也从镜像仓库拉取

* IfNotPresent：本地有则使用本地镜像，本地没有则去仓库拉取，默认的镜像拉取策略

* Never：只使用本地镜像，本地没有则报错

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure>

# Pod资源限制

为了保证充分利用集群资源，且确保重要容器在运行周期内能够分配到足够的资源稳定运行，因此平台需要具备Pod的资源限制的能力。对于一个Pod来说，资源最基础的2个指标就是CPU和内存。资源限制有两种类型：

* requests：容器使用的最小资源要求，作用于schedule阶段，作为容器调度时分配的判断依赖，只有当节点上可分配的资源量>=request时，才允许将容器调度到该节点。requests参数不限制容器的最大可用资源。requests.cpu被转成docker的--cpu-shares参数，与cgroup.cpu.shared功能相同。requests.memory没有对应的docker参数，仅作为k8s调度的依据

* limits：容器使用的最大资源限制，不设置或者设置为0表示对使用的资源不做限制。当pod内存超过limit时，会被oom，当cpu超过limit时，不会被kill，但会被限制不超过limit值（因为cpu的时间片是动态调度）。limits.cpu会被转换成docker的-cpu-quota参数，与cgroup.cpu.cfs\_quota_us功能相同。limits.memory会被转换成docker的-memory参数，用来限制容器使用的最大内存。

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">    <span class="attr">image:</span> </span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">500m</span> <span class="comment"># 等同于0.5</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">500Mi</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

# configMap和secret

configMap和Secret是k8s提供的两种资源类型，它们可以用来实现业务配置的统一管理。一般来说会使用configMap存储一些不包含敏感信息的基本配置，secret用于管理敏感信息配置，例如密码、密钥等。

使用yaml定义一个configMap资源：

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure>

secret有三种类型：

* Service Accout：用来访问k8s API，由k8s 自动创建，并且会自动挂载到pod的/run/secrets/kubernetes.io/serveraccount目录中；

* Opaque：base64编码的Secret，用来存储密码，密钥等

* kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key1:</span> <span class="string">base64_encoded_value1</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="string">base64_encoded_value2</span></span><br></pre></td></tr></table></figure>

configMap和secret的使用：

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">env_name_1</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&lt;secret</span> <span class="string">resouce</span> <span class="string">name&gt;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">&lt;secret</span> <span class="string">resouce</span> <span class="string">key&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">env_name_2</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&lt;config</span> <span class="string">map</span> <span class="string">resource</span> <span class="string">name&gt;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">&lt;config</span> <span class="string">map</span> <span class="string">resource</span> <span class="string">key&gt;</span></span><br></pre></td></tr></table></figure>

# pod生命周期

一个pod可能处于如下的几种状态

| 状态值                    | 描述                                       |
| ---------------------- | ---------------------------------------- |
| Pending                | API Server已经创建该Pod，等待调度器调度               |
| ContainerCreating      | 拉取镜像启动容器中                                |
| Runing                 | Pod内容器均已创建，且至少有一个容器处于运行状态、正在启动状态或者正在重启状态 |
| Succeeded \| Completed | 容器内所有容器均已成功执行退出，且不再重启                    |
| Failed \| Error        | Pod内所有容器均已退出，但至少有一个容器退出为失败状态             |
| CrashLoopBackOff       | Pod内容器启动失败，比如配置文件丢失导致进程启动失败              |
| Unknown                | 由于某种原因无法获取该Pod的状态，可能由于网络通信不畅导致           |

pod支持两种hook，post-start hook 和pre-stop hook

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">      <span class="attr">image:</span></span><br><span class="line">      <span class="attr">lifecycle:</span></span><br><span class="line">        <span class="attr">postStart:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> </span><br><span class="line">        <span class="attr">preStop:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br></pre></td></tr></table></figure>

pre-stop hook只有在手动kill掉pod才会触发，如果是Pod自己down掉，则不会触发pre-stop hook

# Pod控制器（workload工作负载）

workload是用于实现管理pod的中间层，确保pod资源符合预期的状态，pod的资源出现故障时，会尝试进行重启，当根据重启策略无效时，则会重新新建pod资源。workload有以下几种类型：

* ReplicaSet：pod副本数量，确保pod副本数量符合预期状态，并且支持滚动式自动阔缩容

* Deployment：工作在ReplicaSet之上，用于管理无状态应用，目前来说最好的控制器，支持滚动更新和回滚功能

* DaemonSet：用于确保集群中的每一个节点只运行特定的pod服务，通常用于实现系统级后台服务

* Job：只要完成就立即退出，不需要重启或重建

* Cronjob：周期性任务控制，不需要持续后台运行

* StatefulSet：管理有状态应用

## Deployment

使用yaml定义一个deployment

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 指定pod副本数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># pod选择器，有对应label的pod都会归于这个deployment管理，不是pod的node selector</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># pod 模版，同定义pod的yaml文件</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span> <span class="comment">#这里定义的lable的key/value要和上面的select字段定义的相对应</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">nodeLabelKey:</span> <span class="string">nodeLabelValue</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">        <span class="attr">image:</span></span><br><span class="line">        <span class="attr">env:</span></span><br></pre></td></tr></table></figure>

deployment阔缩容命令：

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; scale deployment &lt;deployment name&gt; --replicas=&lt;n&gt;</span><br></pre></td></tr></table></figure>

deployment服务更新（镜像更新）

* 通过yaml配置文件的方式（建议）

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; apply -f &lt;xxx.yaml&gt;</span><br></pre></td></tr></table></figure>

* 通过命令行直接更新

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; set image deployment &lt;deployment name&gt; &lt;container name&gt;=&lt;image&gt;</span><br></pre></td></tr></table></figure>

deploy服务回滚

回滚只能通过命令行进行回滚，不能通过配置文件进行回滚

* 查看可回滚的历史记录

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment &lt;deployment name&gt;</span><br></pre></td></tr></table></figure>

* 回滚

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment &lt;deployment name&gt; --to-revision=&lt;revsion number&gt;</span><br></pre></td></tr></table></figure>

### deployment更新（回滚）策略配置

deployment的更新（回滚）是滚动更新（回滚）的，即一次只进行一部分pod更新（回滚），直到所有的pod都完成更新（回滚），deployment的更新（回滚）策略有以下几种可配置项：

* maxSurge：最大激增数，指更新过程中，最多可以比replicas预先设定值多出的pod数量，可以为固定值或百分比，默认为25%，计算时向上取整

* maxUnavailable：指更新过程中，最多有几个pod处于无法服务状态，可以为固定值或百分比，默认为25%，计算时向下取整

<font color="orange">deployment更新的底层实现其实是新建了一个ReplicaSet，这个ReplicaSet使用的最新版本的镜像，然后通过调整新ReplicaSet和老ReplicaSet的副本数来实现滚动升级。同时老的ReplicaSet不会立即删除，目的是为了方便回滚。</font>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">rollingUpdate:</span></span><br><span class="line">        <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">        <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">template:</span> </span><br><span class="line">      <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">nodeSelector:</span></span><br><span class="line">          <span class="attr">nodeLabelKey:</span> <span class="string">nodeLabelValue</span></span><br><span class="line">        <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">          <span class="attr">image:</span></span><br><span class="line">          <span class="attr">env:</span></span><br></pre></td></tr></table></figure>
<h1 id="Service负载均衡之Cluster-IP"><a href="#Service负载均衡之Cluster-IP" class="headerlink" title="Service负载均衡之Cluster IP"></a>Service负载均衡之Cluster IP</h1><p>通过deployment，我们已经可以创建一组Pod来提供具有高可用性的服务，虽然每个Pod都会分配一个单独的Pod IP， 然而却存在如下两个问题：</p>
<ul>
<li><p>Pod IP仅仅是集群内部的虚拟IP，在集群内部可以访问，外部却无法访问</p>
</li>
<li><p>Pod IP会随着Pod的销毁而消失，当ReplicaSet对Pod进行动态伸缩容时，Pod IP可能随时会发生变化，这样对于我们访问这个服务带来了难度</p>
</li>
</ul>
<p>Services是一组pod服务的抽象，相当于一组pod的load balancer，负责将请求分发到对应的pod。service会有一个IP，一般称为cluster ip，service对象通过selector进行标签选择，找到到对应的pod</p>
<p>使用yaml定义一个service</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 端口</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8002</span> <span class="comment"># pod 端口</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">podLabelName:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>
<p>创建好service后，在集群内部就可以直接使用service name + port对服务进行访问，因为集群内部的dns会记录相关解析规则</p>
<h1 id="Service负载均衡之NodePort"><a href="#Service负载均衡之NodePort" class="headerlink" title="Service负载均衡之NodePort"></a>Service负载均衡之NodePort</h1><p>Cluster IP也是一个虚拟地址，其目的是为了方便集群内部服务直接的通信，只能在k8s集群内部进行访问，如果需要集群外部访问集群内部服务，实现方式之一为使用NodePort方式。NodePort会默认在30000—32767之间，不指定会随机使用其中的一个。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8002</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">podLabelName:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
<h1 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h1><p>kube-proxy运行在每个节点上，监听API Server中服务对象的变化，再通过创建流量路由规则来实现网络的转发。kube-proxy支持三种模式：</p>
<ul>
<li><p>User space：让kube-proxy 在用户空间监听一个端口，所有的service都转发到这个端口，然后kube-proxy在内部应用层对其进行转发，所有报文都走一遍用户态，性能不高，在k8s v1.2版本后废弃</p>
</li>
<li><p>Iptables：当前默认模式，完全由iptables来实现，通过各个节点上的iptable规则来实现service的负载均衡，但是随着service数量增大，iptables模式由于线性查找匹配、全量更新等特点，其性能会显著下降</p>
</li>
<li><p>IPVS：与iptables同样基于Netfilter，但是采用的hash表，因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能。k8s 1.8版本开始引入，1.11版本开始稳定，需要开启宿主机的ipvs模块</p>
</li>
</ul>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>对于k8s的service，无论是Cluster-IP还是NodePort的形式，都是四层的负载，集群内的服务如果实现7层的负载均衡，这就需要借助与Ingress。Ingress控制器的实现方式有很多，例如nginx、contour、haproxy，trafik，istio。</p>
<p>ingress-nginx是7层的负载均衡器，根据用户编写的ingress规则（创建的Ingress的yaml文件），动态的去更改nginx服务的配置文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="comment"># 域名host</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">paths:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">serviceName:</span> <span class="string">&lt;service</span> <span class="string">name&gt;</span></span><br><span class="line">        <span class="attr">servicePort:</span> <span class="string">&lt;service</span> <span class="string">port&gt;</span></span><br></pre></td></tr></table></figure>
<p>Ingress实现逻辑</p>
<ul>
<li><p>Ingress controller通过api server，监听集群中Ingress规则变化</p>
</li>
<li><p>然后读取ingress规则（规则就是写明了哪个域名对应哪个service），按照自定义的规则，生成一段nginx配置</p>
</li>
<li><p>再写到nginx-ingress-contoller的pod里，nginx-ingress-controller的pod里运行着Nginx服务</p>
</li>
</ul>
<p>Ingress 可以看作是在内部Service上做的一层反向代理</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/04/03/devops/docker/docker%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/devops/docker/docker%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">docker网络</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-03 03:24:42 / Modified: 06:48:13" itemprop="dateCreated datePublished" datetime="2022-04-03T03:24:42-04:00">2022-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>545</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>我们在使用<code>docker run</code>创建Docker容器时，可以用<code>--net</code>选项指定容器的网络模式，docker有以下4中网络模式：</p>
<ul>
<li><p>bridage模式：docker容器默认的网络模式。它的原理类似交换机设备，而在linux中，能够起虚拟交互作用的，就是网桥（bridge）。它是一个工作在数据链路层的软件，主要功能是根据MAC地址将数据包转发到网桥的不同端口上。</p>
<p>有了网桥之后，容器在启动时，会执行如下操作：</p>
<ol>
<li><p>创建一对虚拟接口/网卡，也就是veth pair</p>
</li>
<li><p>veth pair一端桥接到默认的名称为<code>docker0</code>的网桥或者其他指定网桥上，并具有一个唯一的名字，如veth9953b75</p>
</li>
<li><p>veth pair一端放到新启动的容器内部，并修改名字作为eth0</p>
</li>
<li><p>从虚拟网桥可用地址段中（也就是bridge对应的network）获取一个空闲地址分配给容器内的eth0</p>
</li>
<li><p>容器内部配置默认路由到网桥</p>
</li>
</ol>
<p>如果容器内部需要访问外部网络，需要经过容器内部的eth0网卡、虚拟网桥、宿主机网卡最终访问到外网。如果容器内部需要访问其他容器网络，需要经过容器内部eth0网卡、虚拟网桥、其他容器内部etho0最终访问到其他容器。</p>
</li>
<li><p>host模式：容器内部不会创建网络命名空间（Network Namespace），容器共享宿主机的网络空间。</p>
</li>
<li><p>container模式：这个模式指定新创建的容器和已经存在的一个容器共享一个网络命名空间（Network Namespace）、网卡、ip。<font color="orange">这种模式在一些特殊的场景中非常有用，例如k8s的pod，k8s为pod创建一个基础设施容器，该pod下的其他容器都以container模式共享这个技术设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</font></p>
</li>
<li><p>none模式：只会在容器内创建网络命名空间（Network Namespace），不会创建虚拟网卡</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/04/03/devops/docker/docker%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/devops/docker/docker%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">docker 实现原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-03 00:02:13 / Modified: 03:24:24" itemprop="dateCreated datePublished" datetime="2022-04-03T00:02:13-04:00">2022-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>727</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Namespace资源隔离"><a href="#Linux-Namespace资源隔离" class="headerlink" title="Linux Namespace资源隔离"></a>Linux Namespace资源隔离</h1><p>Linux命名空间是全局资源的一种抽象，将资源发到不同的命名空间中，各个命名空间中的资源时相互隔离的。命名空间有以下几种类别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>系统调用参数</th>
<th>相关内核版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>Linux 2.4.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>Linux 2.6.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>Linux 2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>Linux 2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>始于Linux 2.6.24 完成于2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>CLONE_NEWUSER</td>
<td>始于Linux2.6.23 完成于3.8</td>
</tr>
</tbody>
</table>
</div>
<p>查看进程的namespace</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/&lt;pid&gt;/ns</span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 net -&gt; net:[4026532057]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 pid_for_children -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>
<h1 id="CGroup资源限制"><a href="#CGroup资源限制" class="headerlink" title="CGroup资源限制"></a>CGroup资源限制</h1><p>通过Namespace可以保证容器之间的隔离，但是无法控制容器可以占用多少资源，如果其中的某一个容器正在执行CPU计算密集型任务，那么就会影响其他容器任务的性能与执行效率，导致多个容器相互影响并且抢占资源。</p>
<p>CGroup（Control Group）就是能够隔离宿主机上的物理资源，例如CPU、内存、磁盘I/O和网络带宽。而我们需要做的就是把容器进程加入到指定的CGroup中。</p>
<h1 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS 联合文件系统"></a>UnionFS 联合文件系统</h1><p>Linux Namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器，这些容器可能会公用一个image。所以容器在启动的时候，不可能各自将这个image复制一份。Docker在内部使用镜像分层存储以及UnionFS来实现多个容器共用一个镜像。</p>
<ul>
<li><p>镜像分层存储：docker镜像是由一系列的层组成的，每层代表Dockerfile中的一条指令，比如下面的Dockerfile文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">15.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure>
<p>这个dockerfile文件最终生成镜像的时候会生成四层，这四层是不可写的，而通过镜像实例化容器的过程，其实就是在就是在这四层之上添加了一个可写层，也就是我们通常说的容器层。而对容器层的操作，主要是利用了写时复制（CoW，copy on write）的技术。例如，如果当前操作会改变下面四层的某一层，docker会先将该层拷贝到容器层，然后再在容器层中进行操作。</p>
</li>
<li><p>UnionFS 其实是一种为Linux操作系统设计的，用于把多个文件系统联合到同一个挂载点的文件系统服务。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/03/26/math/discrete_mathematics/dft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/math/discrete_mathematics/dft/" class="post-title-link" itemprop="url">dft</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-26 22:23:10" itemprop="dateCreated datePublished" datetime="2022-03-26T22:23:10-04:00">2022-03-26</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/03/26/program_language/python/effective_python/%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/program_language/python/effective_python/%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">类与接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-26 09:33:56 / Modified: 11:44:01" itemprop="dateCreated datePublished" datetime="2022-03-26T09:33:56-04:00">2022-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-python/" itemprop="url" rel="index">
                    <span itemprop="name">effective python</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>346</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型"><a href="#第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型" class="headerlink" title="第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型"></a>第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型</h1><p>一般我们在编写项目代码时，由于初始的需求简单，需要用到的数据结构也简单，所以我们会经常使用python提供的容器来用做类的内部状态记录。但是随着需求的迭代，我们可能会使用到数据结构可能会更变得复杂，这时，我们不能简单的对用于记录内部状态的容器进行嵌套，而是应该考虑将内部的某些状态封装成一个类，并在外部的接口类中对这些数据类进行组合。</p>
<h1 id="第38条：让简单的接口接受函数，而不是类的实例"><a href="#第38条：让简单的接口接受函数，而不是类的实例" class="headerlink" title="第38条：让简单的接口接受函数，而不是类的实例"></a>第38条：让简单的接口接受函数，而不是类的实例</h1><p>Python有很多内置的API，都允许我们传入某个函数来定制它的行为，这种函数被成为hook函数，API在执行的时候，会调用这些hook函数。例如，list类的sort方法的key参数。<font color="orange">在其他编程语音中，hook函数可能是通过抽象类或者接口来定义的（例如Java），但在python中一般是直接使用无状态的函数（即不会对内部状态进行修改）</font></p>
<h1 id="第39条：通过-classmethod多态来构造同一体系中的各类对象"><a href="#第39条：通过-classmethod多态来构造同一体系中的各类对象" class="headerlink" title="第39条：通过@classmethod多态来构造同一体系中的各类对象"></a>第39条：通过@classmethod多态来构造同一体系中的各类对象</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/03/05/program_language/python/effective_python/%E6%8E%A8%E5%AF%BC%E4%B8%8E%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/05/program_language/python/effective_python/%E6%8E%A8%E5%AF%BC%E4%B8%8E%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">推导与生成</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-05 23:07:53" itemprop="dateCreated datePublished" datetime="2022-03-05T23:07:53-05:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-17 08:53:16" itemprop="dateModified" datetime="2022-03-17T08:53:16-04:00">2022-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-python/" itemprop="url" rel="index">
                    <span itemprop="name">effective python</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第27条：用列表推导取代map与filter"><a href="#第27条：用列表推导取代map与filter" class="headerlink" title="第27条：用列表推导取代map与filter"></a>第27条：用列表推导取代map与filter</h1><p>Python里面有一种很精简的写法，可以根据某个序列或可迭代对象派生出一份新的列表。用这种写法写成的表达式，叫作列表推导。假设我们要用列表中每个元素的平方值构建一份新的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure>
<p>这种功能也可以使用内置函数map实现，它能够从多个列表中分别取出当前位置上的元素，并把它们当作参数传给映射函数，以求出新列表在这个位置上的元素值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a)</span><br></pre></td></tr></table></figure>
<font color="orange">如果映射关系比较简单，那么用列表推导来写还是要比用map简单一些，因为用map的时候，必须先把映射逻辑定义为lambda函数，这看上去稍微有点繁琐。</font>

<p>列表推导还有一个地方比map好，就是它能够方便地过滤原列表，把某些输入值对应的计算结果从输出结果中排除。例如，假设新列表只需要纳入原列中那些偶数的平方值，那么我们可以在推导的时候再添加一个条件表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这种功能也可以通过内置的filter与map函数来实现，但是这两个函数相结合的写法要比列表推导难懂一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt = <span class="built_in">map</span>(<span class="keyword">lambda</span> x : x**<span class="number">2</span>, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br></pre></td></tr></table></figure>
<p>上面这个写法是先用filter对a中的元素进行过滤形成新的列表，然后在对这个新的列表用map函数生成最终结果。</p>
<font color="orange">字典与集合也有相应的推导机制，分别叫做字典推导与集合推导，可以根据原字典与原集合创建新字典与新集合。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_squares_dict = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">threes_cubed_set = &#123;x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果改用map与filter实现，那么还必须调用相应的构造器（constructor），这会让代码变得很长，需要分成多行才能写得下。这样看起来比较乱，不如使用推导机制的代码清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alt_dict = <span class="built_in">dict</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x, x**<span class="number">2</span>), <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a)))</span><br><span class="line">alt_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x, x**<span class="number">3</span>), <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, a)))</span><br></pre></td></tr></table></figure>
<h1 id="第28条：控制推导逻辑的子表达式不要超过两个"><a href="#第28条：控制推导逻辑的子表达式不要超过两个" class="headerlink" title="第28条：控制推导逻辑的子表达式不要超过两个"></a>第28条：控制推导逻辑的子表达式不要超过两个</h1><p>列表推导除了最基本的用法外，列表推导还支持多层循环。例如，要把二维列表转化为普通的一维列表，那么可以在推导时，使用两条for子表达式。这些子表达式会按照从左到右的顺序解读。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br></pre></td></tr></table></figure>
<p>这样写简单易懂，也是多层循环在列表推导中的合理用法。多层循环还可以用来重制那种两层深的结构。例如，要根据二维矩阵里每个元素的平方值来构建一个新的二维矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br></pre></td></tr></table></figure>
<p>如果推导过程中还要再加一层循环，那么语句就会变得很长，必须把它分成多行来写，例如下面是把一个三维矩阵转化成普通一维列表的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_lists = [</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]],</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">flat = [x <span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists </span><br><span class="line">        <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</span><br></pre></td></tr></table></figure>
<font color="orange">在这种情况下，采用列表推导来实现，其实并不会比传统的for循环节省多少代码。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flat = []</span><br><span class="line"><span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists:</span><br><span class="line">    <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1:</span><br><span class="line">        flat.extend(sublist2)</span><br></pre></td></tr></table></figure>
<p>推导的时候，可以使用多个if条件，如果这些if条件出现在同一层循环内，那么它们之间默认是and关系，也就是必须同时成立。例如，如果要用原列表中大于4且是偶数的值来构建新列表，那么既可以连用两个if，也可以只用一个if，下面两种写法效果相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>在推导时，每一层的for子表达式都可以带有if条件。假如要根据原矩阵构建新的矩阵，把其中各元素之和大于等于10的那些行选出来，而且只保留其中能够被3整除的那些元素。这个逻辑用列表推导来写，并不需要太多的代码，但是这些代码理解起来会很困难：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">filterd = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> <span class="built_in">sum</span>(row) &gt;= <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<font color="orange">总之，在表示推导逻辑时，最多只应该写两个子表达式（例如两个if条件、两个for循环，或者一个if条件与一个for循环）。</font> 只要实现的逻辑比这还复杂，那就应该采用普通的if和for语句来实现。

# 第29条：用赋值表达式消除推导中的重复代码

推导list、dict与set等结构时，经常要在多个地方用到同一个计算结果。例如，我们要给制作紧固件的公司编写程序以管理订单。顾客下单后，我们要判断当前库存能否满足这份订单，也就是说，要和产每种产品的数量有没有达到可以发货的最低限制（8个为一批，至少要一批，才能发货）。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stock = &#123;</span><br><span class="line">    <span class="string">&#x27;nails&#x27;</span>: <span class="number">125</span>,</span><br><span class="line">    <span class="string">&#x27;screws&#x27;</span>: <span class="number">35</span>,</span><br><span class="line">    <span class="string">&#x27;wingnuts&#x27;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&#x27;washers&#x27;</span>: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order = [<span class="string">&#x27;screws&#x27;</span>, <span class="string">&#x27;wingnuts&#x27;</span>, <span class="string">&#x27;clips&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batches</span>(<span class="params">count, size</span>):</span></span><br><span class="line">    <span class="keyword">return</span> count // size</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> order:</span><br><span class="line">    count = stock.get(name, <span class="number">0</span>)</span><br><span class="line">    batches = get_batches(count, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> batches:</span><br><span class="line">        result[name] = batches</span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="string">&#x27;screws&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;wingnuts&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

这段循环逻辑，如果改用字典推导来写，会简单一些：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>) </span><br><span class="line">         <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">         <span class="keyword">if</span> get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>)&#125;</span><br></pre></td></tr></table></figure>

这样写虽然比刚才简短，但问题是，它把`get_batches(stock.get(name, 0), 8)`写了两遍。有个简单的办法可以解决这个问题，那就是在推导的过程中使用Python3.8新引入的 `:=`操作符进行赋值表达

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: batches <span class="keyword">for</span> name <span class="keyword">in</span> order </span><br><span class="line">         <span class="keyword">if</span> (batches := get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>))&#125;</span><br></pre></td></tr></table></figure>

在推导过程中，<font color="orange">描述新值的那一部分也可以出现赋值表达式，但如果在其他部分引用了定义在那一部分的变量，那么程序可能就会在运行时出错：</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: (tenth := count // <span class="number">10</span>)</span><br><span class="line">          <span class="keyword">for</span> name, count <span class="keyword">in</span> stock.items() <span class="keyword">if</span> tenth &gt; <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Traceback ...</span><br><span class="line">NameError: name <span class="string">&#x27;tenth&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>但是，如果把赋值表达式移动到<code>if</code>条件里面，就可以解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: tenth <span class="keyword">for</span> name, count <span class="keyword">in</span> stock.items() </span><br><span class="line">          <span class="keyword">if</span> (tenth := count // <span class="number">10</span>) &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值"><a href="#第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值" class="headerlink" title="第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值"></a>第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值</h1><p>如果函数要返回的是个包含许多结果的序列，那么最简单的办法就是把这些结果放到列表中。例如，我们要返回字符串里每个单词的首字母在字符串中所对应的下标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, latter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> latter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            result.apppend(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">the_text = <span class="string">&#x27;Four score and seven years ago...&#x27;</span></span><br><span class="line">result = index_words(the_text)</span><br><span class="line">print(result[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>
<p>上面的<code>index_words</code>函数也可以改用生成器来实现。<font color="orange">生成器由包含yield表达式的函数创建。</font>下面就定义一个生成器函数，实现与刚才那个函数相同的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words_iter</span>(<span class="params">the_text</span>):</span></span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> index + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<font color="orange">调用生成器函数并不会让其中的代码立刻得到执行，它会返回一个迭代器（iterator）。把迭代器传给Python内置的next函数，就可以将生成器函数推进到它的下一条yield表达式。生成器会把yield表达式的值通过迭代器返回给调用者。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = index_words_iter(the_text)</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>如果确实要制作一份列表，那可以把生成器函数返回的迭代器传给内置的list函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">list</span>(index_words_iter(the_text))</span><br></pre></td></tr></table></figure>
<p><code>index_words_iter</code>相对于<code>index_words</code>来说，不必一次性把所有结果都保存到列表中，在数据的数据较多的情况下，<code>index_words</code>有可能因为耗尽内存而导致程序崩溃。</p>
<p>使用这些生成器函数时，只有一个地方需要注意，就是调用者无法重复使用函数所返回的迭代器，因为迭代器是有状态的（参见第31条）。</p>
<h1 id="第31条：谨慎地迭代函数所接受的可迭代参数"><a href="#第31条：谨慎地迭代函数所接受的可迭代参数" class="headerlink" title="第31条：谨慎地迭代函数所接受的可迭代参数"></a>第31条：谨慎地迭代函数所接受的可迭代参数</h1><p>如果函数接受的参数是个可迭代对象，那么我们可能会在函数中对其迭代多次。例如，我们要分析美国德克萨斯州的游客数量。原始数据保存在一份列表中，其中的每个元素表示每年有多少游客（单位是百万）。我们要统计每个城市的游客数占游客总数的百分比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    total = <span class="built_in">sum</span>(numbers)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> numbers:</span><br><span class="line">        percent = <span class="number">100</span> * value / total</span><br><span class="line">        result.append(percent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>在<code>normalize</code>函数中会对<code>numbers</code>参数进行两次迭代，一次是在<code>sum</code>函数的调用中，一次是在<code>for</code>循环中。</p>
<p>如果我们给<code>nomalize</code>函数传入参数的是一个列表，我们可以的得到正确的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visits = [<span class="number">15</span>, <span class="number">35</span>, <span class="number">80</span>]</span><br><span class="line">percentages = normalize(visits)</span><br><span class="line">print(percentages)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">11.538</span>, <span class="number">26.924</span>, <span class="number">61.538</span>]</span><br></pre></td></tr></table></figure>
<p>但是如果我们传给<code>nomalize</code>函数的是个迭代器，例如在数据规模较大，需要从文件中读取数据时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_visits</span>(<span class="params">data_path</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_path) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">int</span>(line)</span><br></pre></td></tr></table></figure>
<p>奇怪的是，对<code>read_visits</code>所返回的迭代器调用<code>normalize</code>函数之后，并没有得到结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = read_visits(<span class="string">&#x27;my_numbers.txt&#x27;</span>)</span><br><span class="line">percentages = normalize(it)</span><br><span class="line">print(percentages)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>出现这种状况的原因在于，迭代器只能进行一次迭代，并且迭代后不可重置。在<code>sum</code>函数中，已经对迭代器进行过一次迭代了，所以在<code>for</code>循环中由于没有数据可迭代，所以也就不会进行循环内部。</p>
<p>一种解决办法是让<code>normalize</code>函数接受另外一个函数，使它每次要使用迭代器时，都要向那个函数去索要：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize_func</span>(<span class="params">get_iter</span>):</span></span><br><span class="line">    total = <span class="built_in">sum</span>(get_iter())</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> get_iter()</span><br><span class="line">        percent = <span class="number">100</span> * value / total</span><br><span class="line">        result.append(percent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">percentages = normalize_func(<span class="keyword">lambda</span>: read_visits(<span class="string">&#x27;my_numbers.txt&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这么做虽然可行，但是每次调用<code>normalize_func</code>都需要传入一个函数，<font color="orange">更好的方法是自定义一种容器类，并让其实现迭代器协议（iterator protocol）。</font></p>
<font color="orange">Python的for循环及相关的表达式，正是按照迭代器协议来遍历容器内容的。</font>Python执行`for x in foo`这样的语句时，实际上会调用`iter(foo)`，也就是把foo传给内置的iter函数。这个函数会触发`foo.__iter__`的特殊方法，该方法必须返回一个迭代器对象（即要实现`__next__`特殊方法）。最后，Python会用迭代器对象反复调用内置的`next`函数，知道迭代完成。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadVisits</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data_path</span>):</span></span><br><span class="line">        self.data_path = data_path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.data_data_path) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">int</span>(line)</span><br></pre></td></tr></table></figure>

我们只需要把新的容器传给最早的那个normalize函数即可，函数的代码无需修改：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visits = ReadVisits(p[<span class="number">11.538</span>, <span class="number">26.924</span>, <span class="number">61.538</span>]ath)</span><br><span class="line">percentage = normalize(visits)</span><br><span class="line">print(percentages)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">11.538</span>, <span class="number">26.924</span>, <span class="number">61.538</span>]</span><br></pre></td></tr></table></figure>

# 第32条：考虑用生成器表达式改写数据量较大的列表推导

列表推导可以根据输入序列中的每个元素创建一个包含派生元素的新列表。如果输入的数据量比较小，那么这么做没有问题，但如果数据量很大，那么程序就有可能因为内存耗尽而崩溃。例如，我们要读取一份文件并返回每行的字符数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = [<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>)]</span><br></pre></td></tr></table></figure>

上面的代码有可能因为文件行数太多而导致list过长。<font color="orange">要想处理大规模的数据，可以使用生成器表达式来做，它扩展了列表推导和生成器机制。程序在对生成器表达式求值时，并不会让它把包含输出结果的那个序列立即构建出来，而是会把它当成一个迭代器，该迭代器每次可以根据表达式中的逻辑给出一个结果。</font>

<font color="orange">生成器表达式的写法与列表推导类似，只不过它是写在一对圆括号里，而不是方括号里：</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>
<p>生成器表达式还有个强大的特性，就是可以组合起来，例如，可以用刚才那条生成器表达式所形成的it迭代器作为输入，编写一条新的生成器表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roots = (x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure>
<h1 id="第33条：通过yield-from把多个生成器连起来用"><a href="#第33条：通过yield-from把多个生成器连起来用" class="headerlink" title="第33条：通过yield from把多个生成器连起来用"></a>第33条：通过yield from把多个生成器连起来用</h1><p>生成器（yield）有很多好处，能够解决很多常见的问题。生成器的用途很广，所以许多程序都会频繁使用它们，而且是一个连一个地用。</p>
<p>例如，我们要编写一个图形程序，让它在屏幕上面移动图像，从而形成动画效果。假设要实现这样一段动画：图片先快速移动一段时间，然后暂停，接下来慢速移动一段时间。我们用生成器来表示图片在当前时间段内应该保持的速度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">period, speed</span>):</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(period):</span><br><span class="line">        <span class="keyword">yield</span> speed</span><br></pre></td></tr></table></figure>
<p>为了把完整的动画制作出来，我们需要调用三次move：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span>():</span></span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">4</span>, <span class="number">5.0</span>)</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">3</span>, <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">2</span>, <span class="number">3.0</span>)</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br></pre></td></tr></table></figure>
<p>上面这种写法的问题在于，animate函数里有很多重复的地方。比如它反复使用for结构来操作生成器，而且每个for结构都使用相同的yield表达式。为了解决这个问题，我们可以改用<code>yield from</code>形式的表达式来实现。这种形式，会先从嵌套进去的小生成器里面取值，如果该生成器已经用完，那么程序的控制流程就会回到<code>yield from</code>所在的这个函数之中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">4</span>, <span class="number">5.0</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">3</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">2</span>, <span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<p>上面使用<code>yield from</code>的代码看上去更清晰、更直观，<font color="orange">并且这种实现方式的运行效率要更快。</font></p>
<h1 id="第34条：不要用send给生成器注入数据"><a href="#第34条：不要用send给生成器注入数据" class="headerlink" title="第34条：不要用send给生成器注入数据"></a>第34条：不要用send给生成器注入数据</h1><h1 id="第35条：不要通过throw变换生成器的状态"><a href="#第35条：不要通过throw变换生成器的状态" class="headerlink" title="第35条：不要通过throw变换生成器的状态"></a>第35条：不要通过throw变换生成器的状态</h1><font color="orange">说实话，第34条和第35条没怎么看懂，第一主要是生成器的这两个高级特性使用的场景也并不多，第二是感觉作者的代码示例也不太贴合实际场景中会写的代码。</font>

<h1 id="第36条：考虑用itertools处理迭代器与生成器"><a href="#第36条：考虑用itertools处理迭代器与生成器" class="headerlink" title="第36条：考虑用itertools处理迭代器与生成器"></a>第36条：考虑用itertools处理迭代器与生成器</h1><p>Python内置的itertools模块中有很多函数，可以用来对迭代器进行一些高级处理。下面分三大类，列出其中最重要的函数。</p>
<ul>
<li><p><strong>连接多个迭代器</strong></p>
<ul>
<li><p><code>chain</code> : 可以把多个迭代器从头连接到尾形成一个新的迭代器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it1 = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">it2 = <span class="built_in">iter</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">it3 = itertools.chain(it1, it2)</span><br><span class="line">print(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>repeat</code> : 可以制作这样的一个迭代器，它会不停得输出某个值，或者通过第二个参数来控制最多能输出几次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.repeat(<span class="string">&#x27;hello&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cycle</code> : 可以制作这样的一个迭代器，它会循环地输出某段内容之中的各个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.cycle([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">result = [<span class="built_in">next</span>(it) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tee</code> : 可以让一个迭代器分裂成多个平行迭代器，具体个数由第二个参数指定。如果这些迭代器推进的速度不一样，那么程序可能要用大量内存做缓存，以存放进度落后的迭代器会用到的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it1, it2, it3 = itertools.tee([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>)</span><br><span class="line">print(<span class="built_in">list</span>(it1))</span><br><span class="line">print(<span class="built_in">list</span>(it2))</span><br><span class="line">print(<span class="built_in">list</span>(it3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>zip_longest</code> : 它与内置的zip函数类似（参见第8条），但区别是，如果源迭代器的长度不同，那么它会用<code>fillvalue</code>参数的值来填补提前耗尽的那些迭代器所留下的空缺。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">normal = <span class="built_in">zip</span>(keys, values)</span><br><span class="line">print(<span class="string">&#x27;zip:&#x27;</span>, <span class="built_in">list</span>(normal))</span><br><span class="line"></span><br><span class="line">it = itertools.zip_longest(key, values, fillvalue=<span class="string">&#x27;nope&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;zip_longest:&#x27;</span>, <span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">zip</span>: [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line">zip_longest: [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;nope&#x27;</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>过滤迭代器中的元素</strong></p>
<ul>
<li><p><code>islice</code> : 可以在<font color="orange">不拷贝数据</font>的前提下，按照下标切割源迭代器，这种切割方式与标准的序列切片以及步进机制类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">first_five = itertools.islice(it, <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&#x27;First Five:&#x27;</span>, <span class="built_in">list</span>(first_five))</span><br><span class="line"></span><br><span class="line">middle_odds = itertools.islice(it, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;Middle odds:&#x27;</span>, <span class="built_in">list</span>(middle_odds))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">First five: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">Middle odds: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>takewhile</code> : 会一值从源迭代器里获取元素，直到某元素让测试函数返回False为止：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it1 = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">it2 = itertools.takewhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">7</span>, it1)</span><br><span class="line">print(<span class="built_in">list</span>(it2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dropwhile</code> : 与takewhile相反，dropwhile会一直跳过源序列里的元素，直到某元素让测试函数返回True为止，然后它会从这个地方开始逐个取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it1 = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">it2 = itertools.dropwhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">7</span>, it1)</span><br><span class="line">print(<span class="built_in">list</span>(it2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filterfalse</code> : 和内置的filter函数相反，它会逐个输出源迭代器里使得测试函数返回False的那些元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">evens = <span class="keyword">lambda</span> x : x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">filter_result = <span class="built_in">filter</span>(evens, it)</span><br><span class="line">print(<span class="string">&#x27;Filter:&#x27;</span>, <span class="built_in">list</span>(filter_result))</span><br><span class="line"></span><br><span class="line">filter_false_result = itertools.filterfalse(evens, it)</span><br><span class="line">print(<span class="string">&#x27;Filter false:&#x27;</span>, <span class="built_in">list</span>(filter_false_result))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Filter: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">Filter false: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>用源迭代器中的元素合成新元素</strong></p>
<ul>
<li><p><code>accumulate</code> : accumulate 会从源代码迭代器取出一个元素，并把已经累计的结果与这个元素一起传给表示累加逻辑的函数，然后输出那个函数的计算结果，并把结果当成新的累计值。<font color="orange">这与内置的functools模块中的reduce函数，实际上是一样的，只不过这个函数每次只给出一项累加值。如果调用者没有指定表示累加逻辑的函数，那么默认的逻辑就是两值相加。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">sum_reduce = itertools.accumulate(it)</span><br><span class="line">print(<span class="string">&#x27;Sum:&#x27;</span>, <span class="built_in">list</span>(sum_reduct))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_modulo_20</span>(<span class="params">first, second</span>):</span></span><br><span class="line">    output = first + second</span><br><span class="line">    <span class="keyword">return</span> output % <span class="number">20</span></span><br><span class="line">modulo_reduce = itertools.accumulate(it, sum_modulo_20)</span><br><span class="line">print(<span class="string">&#x27;Modulo:&#x27;</span> <span class="built_in">list</span>(module_reduce))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Sum: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, ]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>product</code> : 会从一个或多个源迭代器里获取元素，并计算笛卡尔积，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">single = itertools.product([<span class="number">1</span>, <span class="number">2</span>], repeat=<span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;Single:&#x27;</span>, <span class="built_in">list</span>(single))</span><br><span class="line"></span><br><span class="line">multiple = itertools.product([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;Multiple:&#x27;</span>, <span class="built_in">list</span>(multiple))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Single: [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line">Multiple: [(<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>product</code> : 会从源迭代器中能给出的全部元素，并逐个输出由其中N个元素组成的有序排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line">print(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>combinations</code> : 会从源迭代器中能给出的全部元素，并逐个输出由其中N个元素组成的无序组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line">print(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>combinations_with_replacement</code> : 和combination类似，但是它允许同一个元素在组合里多次出现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line">print(<span class="built_in">list</span>(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/02/20/DDIA/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/DDIA/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">数据复制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-20 15:13:27" itemprop="dateCreated datePublished" datetime="2022-02-20T15:13:27-05:00">2022-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 03:34:17" itemprop="dateModified" datetime="2024-10-24T03:34:17-04:00">2024-10-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DDIA/" itemprop="url" rel="index">
                    <span itemprop="name">DDIA</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>29 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>复制主要指通过互联网络在多台机器上<font color="orange">保存相同数据的副本</font>，通过数据复制方案，人们通常希望达到以下目的：</p>
<ul>
<li><p>使数据在地理位置上更接近用户，从而降低访问延迟</p>
</li>
<li><p>当部分组件出现故障，系统依然可以继续工作，从而提高可用性</p>
</li>
<li><p>扩展至多台机器以同时提供数据访问服务，从而提高吞吐量</p>
</li>
</ul>
<p>本章讨论的内容都是在假设数据规模比较小，集群的每一台机器都可以保存数据集的完整副本。在接下来的第6章中，我们讨论单台机器无法容纳整个数据集的情况（即必须分区）。在后面的章节中，我们还将讨论复制过程中可能出现的各种故障，以及该如何处理这些故障。</p>
<p>如果复制的数据一成不变，那么复制就非常容易：只需将数据复制到每个节点，一次即可搞定。然而所有的技术挑战都在于处理那些持续更改的数据，而这正是本章讨论的核心。我们将讨论是三种流行的复制变化数据的方法：主从复制、多节点复制和无主节点复制。几乎所有的分布式数据库都使用上述方法中的某一种，而三种方法各有优缺点。</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>每个保存数据库完整数据集的节点称之为副本。当有了多个副本，不可避免地会引入一些问题：如何确保所有副本之间的数据是一致的？</p>
<p>对于每一笔数据写入，所有副本都需要随之更新，否则，某些副本将出现不一致。最常见的解决方案是基于主节点的复制，也即主从复制。主从复制的工作原理如下：</p>
<ol>
<li><p>指定某一个副本为主副本（或主节点）。当客户写数据库时，必须将写请求发送给主副本，主副本首先将数据写入本地存储。</p>
</li>
<li><p>其他副本则全称为从副本（或从节点）。主副本把数据写入本地存储后，<font color="orange">将数据更改为复制的日志或更改流发送给所有从副本</font>。每个从副本获得更改日志后将其应用到本地，且严格保持与主副本相同的写入顺序。</p>
</li>
<li><p>客户端从数据库中读数据时，既可以在主副本也可以在从副本上执行查询。</p>
</li>
</ol>
<p><img src="/2022/02/20/DDIA/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/fig5-1.png" alt="主从复制"></p>
<p>许多关系型数据库都内置支持主从复制，例如PostgresSQL、Mysql、SQL Server。一些非关系型数据库如MongoDB、RethinkDB和Espresso也支持主从复制。另外，主从复制技术也不仅限于数据库，还广泛应用于分布式消息队列如Kafka和RabbitMQ，以及一些网络文件系统和复制块设备（如DRBD）</p>
<h2 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h2><p>复制非常重要的一个设计选项是同步复制还是异步复制。对于关系数据库系统，同步或异步通常是一个可配置的选项；而其他系统则可能是硬性指定或者只能二选一。</p>
<p>结合一个例子，假设网站用户需要更新首页的头像图片。其基本流程是，客户将更新请求发送给主节点，主节点接收到请求，接下来将数据更新转发给从节点。最后，由主节点来通知客户端更新完成。</p>
<p><img src="/2022/02/20/DDIA/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/fig5-2.png" alt="主从复制"></p>
<p>在上图中，从节点1的复制是同步的，即主节点需等待直到从节点1确认完成了写入，然后才会向用户报告完成，并且将最新的写入对其他客户端可见。而从节点2的复制是异步的：主节点发送完消息之后立即返回，不用等待从节点2完成确认。</p>
<p>从节点2在接收到复制日志并完成数据同步有一段延迟，通常情况下，复制速度会非常快，例如多数数据库系统可以在一秒之内完成所有从节点的更新，但是，系统其实并没有保证一定会在多长时间内完成复制。有些情况下，从节点可能落后主节点几分钟甚至更长时间，例如，由于从节点刚从故障中恢复，或者系统已经接近最大设计上限，或者节点之间的网络出现问题。</p>
<p>同步复制的优点是，一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。缺点则是，如果同步的从节点无法完成确认（例如由于从节点发生崩溃，或者网络故障，或任何其他原因），写入就不能视为成功。节点会阻塞所有的写操作，直到同步副本确认完成。</p>
<p>因此，<font color="orange">把所有的节点都配置为同步复制有些不切实际</font>。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。实践中，如果数据库启用了同步复制，通常意味着其中某一个从节点是同步的，而其他节点则是异步模式。万一同步的从节点变得不可用或性能下降，则将另一个异步的从节点提升为同步模型。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。这种配置有时也称为<font color="orange">半同步</font>。</p>
<p>主从复制还经常会被配置为全异步模式。此时如果主节点发送失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。这意味着即使向客户端确认了写操作，却无法保证数据一定会持久化存储到。但全异步配置的优点则是，不管从节点上数据多么滞后，主节点总是可以继续响应写请求，系统的吞吐性能更好。</p>
<p>全异步模式这种弱化的持久性听起来是一个非常不靠谱的折中设计，但是异步复制还是被广泛使用，特别是那些从节点数量巨大或者分布于广域地理环境。</p>
<h2 id="配置新的从节点"><a href="#配置新的从节点" class="headerlink" title="配置新的从节点"></a>配置新的从节点</h2><p>如果出现一下情况时，如需要增加副本数以提高容错能力，或者替换失败的副本，就需要考虑增加新的从节点，但如何确保新的从节点和主节点保持数据一致呢？</p>
<p>简单地将数据文件从一个节点复制到另一个节点通常是不够的，主要是因为客户端仍在不断向数据库写入新数据，数据始终处于不断变化之中，因此常规的文件拷贝方式将会导致不同节点上呈现不同时间点的数据，这不是我们所期待的。</p>
<p>或许应该考虑锁定数据库（使其不可写）来使磁盘上的文件保持一致，但这会违反高可用的设计目标，好在我们可以做到不停机、数据服务不中断的前提下完成从节点的设置。逻辑上的主要操作步骤如下：</p>
<ol>
<li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。</li>
<li>将此快照拷贝到新的从节点</li>
<li>从节点连接到主节点请求快照点所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联。</li>
<li>获取日志之后，从节点来应用这些快照点之后所有数据变更，这个步骤称之为<font color="orange">追赶</font>。</li>
</ol>
<p>建立新的从副本具体操作步骤可能因数据库系统而异，某些系统中，这个过程是全自动化的，而在某些系统中由于所设计的步骤、流程可能会比较复杂，甚至需要管理员手动介入。</p>
<h2 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h2><p>系统中的任何节点都可能因故障或者计划内的维护(例如重启节点以安装内核安全补丁)而导致中断甚至停机。如果能够在不停机的情况下重启某个节点，这会对运维带来巨大的便利。我们的目标是，尽管个别节点会出现中断，但要保持系统总体的持续运行，并尽可能减小节点中断带来的影响。</p>
<h3 id="从节点失效：追赶式恢复"><a href="#从节点失效：追赶式恢复" class="headerlink" title="从节点失效：追赶式恢复"></a>从节点失效：追赶式恢复</h3><p>根据副本的复制日志，从节点可以知道在发生故障之前所处理的最后一笔事务，然后连接到主节点，并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后，将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。</p>
<h3 id="主节点失效：节点切换"><a href="#主节点失效：节点切换" class="headerlink" title="主节点失效：节点切换"></a>主节点失效：节点切换</h3><p>处理主节点故障的情况则比较棘手：需要选择某个从节点将其提升为主节点，这一过程称之为切换。故障切换可以手动进行，例如通知管理员主节点发生失效，采取必要的步骤来创建新的主节点，或者以自动方式进行。自动切换的步骤通常如下：</p>
<ol>
<li><p>确认主节点失效。大多数系统都采用了基于超时的机制：节点间频繁地互相发生发送心跳存活消息，如果发现某一个节点在一段比较长时间内（例如30<strong>s</strong>) 没有响应，即认为该节点发生失效。</p>
</li>
<li><p>选举新的主节点。可以通过选举的方式（超过多数的节点达成共识）来选举新的主节点，或者由之前选定的某控制节点来指定新的主节点。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。</p>
</li>
<li><p>重新配置系统使新主节点生效，现在需要将写请求发送给新的主节点，如果原主节点之后重新上线，可能仍然自认为是主节点，而没有意识到其他节点已经达成共识迫使其下台。这时系统要确保原主节点降级为从节点，并认可新的主节点。</p>
</li>
</ol>
<p>然而，上述切换过程依然充满了很多变数：</p>
<ul>
<li><p>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线并加入到集群，新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识的角色变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的解决方案是，原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺</p>
</li>
<li><p>在某些故障情况下，可能会发生两个节点同时都自认为是主节点。这种情况被称为脑裂，它非常危险：两个主节点都可能接受写请求，并且没有很好解决冲突的办法，最后数据可能会丢失或者破坏。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点</p>
</li>
</ul>
<p>坦白讲，<font color="orange">对于这些问题没有简单的解决方案</font>。因此，即使系统可能支持自动故障切</p>
<p>换，有些运维团队仍然更愿意以手动方式来控制整个切换过程。上述这些问题，包括节点失效、网络不可靠、副本一致性、持久性、可用性与延迟之间各种细微的权衡，实际上正是分布式系统核心的基本问题</p>
<h1 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h1><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>最简单的情况，主节点记录所执行的每个写请求（操作语句）并将该操作语句作为日志志发送给从节点。对于关系数据库，这意味着每个<strong>INSERT</strong>、<strong>UPDATE</strong>或<strong>DELEH</strong>语句都会转发给从节点，并且每个从节点都会分析并执行这些<strong>SQL</strong>语句，如同它们是来自客户端那样。</p>
<p>听起来很合理也不复杂，但这种复制方式有一些不适用的场景：</p>
<ul>
<li><p>任何调用非确定性函数的语句，如<strong>NOW</strong> ()获取当前时间，或<strong>RAND</strong> ()获取一个随机</p>
<p>数等，可能会在不同的副本上产生不同的值</p>
</li>
<li><p>如果语句中使用了自增列，或者依赖于现有数据</p>
</li>
</ul>
<p>有可能采取一些特殊措施来解决这些问题，但这里面存在太多边界条件需要考虑，因此<font color="orange">目前通常首选的是其他复制实现方案</font>。</p>
<h3 id="基于预写日志（WAL）的复制"><a href="#基于预写日志（WAL）的复制" class="headerlink" title="基于预写日志（WAL）的复制"></a>基于预写日志（WAL）的复制</h3><p>从节点收到日志进行处理，建立和主节点内容完全相同的数据副本。其主要缺点是日志描述的数据结果非常底层：一个<strong>WAL</strong>包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密耦合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无法支持主从节点上运行不同版本的软件。</p>
<h3 id="基于行的逻辑日志复制"><a href="#基于行的逻辑日志复制" class="headerlink" title="基于行的逻辑日志复制"></a>基于行的逻辑日志复制</h3><p>另一种方法是复制和存储引擎采用不同的日志格式，这样复制与存储逻辑剥离。这种</p>
<p>复制日志称为逻辑日志，以区分物理存储引擎的数据表示。</p>
<p>关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：</p>
<ul>
<li><p>对于行插入，日志包含所有相关列的新值</p>
</li>
<li><p>对于行刪除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如</p>
<p>果表上没有定义主键，就需要记录所有列的旧值</p>
</li>
<li><p>对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或</p>
<p>至少包含所有已更新列的新值）</p>
</li>
</ul>
<p>如果一条事务涉及多行的修改，则会产生多个这样的日志记录，并在后面跟着一条记</p>
<p>录，指出该事务已经提交。<strong>MySQL</strong>的二进制日志<strong>binlog</strong> (当配置为基于行的复制时）</p>
<p>使用该方式。</p>
<p>由于逻辑日志与存储引擎逻辑解耦，因此可以更容易地保持向后兼容，从而使主从节</p>
<p>点能够运行不同版本的软件甚至是不同的存储引擎。</p>
<h3 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h3><p>到目前为止所描述的复制方法都是由数据库系统来实现的，不涉及任何应用程序代码。通常这是大家所渴望的，不过，在某些情况下，我们可能需要更高的灵活性。例如，只想复制数据的一部分，或者想从一种数据库复制到另一种数据库，则需要将复制控制交给应用程序层。</p>
<p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。</p>
<h1 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h1><p>不幸的是，如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主节点，则应用可能会读到过期的信息。这种不一致只是一个暂时的状态，如果停止写数据库，经过一</p>
<p>段时间之后，<font color="orange">从节点最终会赶上并与主节点保持一致。这种效应也被称为最终一致性</font>。</p>
<p>正常情况下，主节点和从节点上完成写操作之间的时间延迟（复制滞后）可能不足1秒，这样的滞后，在实践中通常不会导致太大影响。但是，如果系统已接近设计上限，或者网络存在问题，则滞后可能轻松增加到几秒甚至几分钟不等。当滞后时间太长时，导致的不一致性不仅仅是一个理论存在的问题，而是个实实在在的现实问题。</p>
<h2 id="读自己的写"><a href="#读自己的写" class="headerlink" title="读自己的写"></a>读自己的写</h2><p>许多应用让用户提交一些数据，接下来査看他们自己所提交的内容，提交新数据须发送到主节点，但是当用户读取数据时，数据可能来自从节点。然而对于异步复制存在这样一个问题，用户在写入不久即查看数据，则新数据可能尚未到达从节点。对用户来讲，看起来似乎是刚刚提交的数据丢失了。对于这种情况，我们需要<font color="orange">写后读一致性，机制保证如果用户重新加载页面，他们总能看到自己最近提交的更新</font>。但对其他用户则没有任何保证，这些用户的更新可能会在稍后才能刷新看到。</p>
<p>基于主从复制的系统该如何实现写后读一致性呢？有多种可行的方案，以下例举一二：</p>
<ul>
<li>如果用户访问可能会被自己修改的内容，从主节点读取；否则，在从节点读取。这背后就要求有一些方法在实际执行查询之前，就已经知道内容是否可能会被用户自己修改。例如，社交网络上的用户首页信息通常只能由所有者编辑，而其他人无法编辑。因此，这就形成一个简单的规则：总是从主节点读取用户自己的首页配置文件，而在从节点读取其他用户的配置文件。</li>
</ul>
<h2 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h2><p>如果用户从不同副本进行了多次读取，则很有可能出现一下情况：第一次查询返回了比较新的结果，但第二次查询时，由于副本滞后较多，返回给用户的数据相对于第一次变少了，对于用户来说感知到的情况就是数据被删除了。</p>
<p>单调读一致性可以确保不会发生这种异常，这是一个比强一致性弱，比最终一致性强的保证。当读取数据时，<font color="orange">单调读一致性保证，如果某个用户依次进行多次读取，则他绝不会看到回滚现象，即在读取较新值之后又发生读旧值的情况</font>。</p>
<p>实现单调读的一种方式是，确保每个用户总是从固定的冋一副本执行读取（而不同的用户可以从不同的副本读取）。例如，基于用户<strong>ID</strong>的哈希的方法而不是随机选择副本。但如果该副本发生失效，则用户的査询必须重新路由到另一个副本。</p>
<h2 id="前缀一致读"><a href="#前缀一致读" class="headerlink" title="前缀一致读"></a>前缀一致读</h2><p>在多人聊天的场景下，人与人之间聊天的顺序对于用户来说是很重要的，但是由于复制滞后的问题，用户可能会先收到其他用户在时间上相对后发出的消息，导致产生逻辑混乱。</p>
<p>防止这种异常需要引入另一种保证：<font color="orange">前缀一致读。该保证是说，对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照当时写入的顺序</font>。</p>
<p>这是分区（分片）数据库中出现的一个特殊问题，细节将在第6章中讨论。如果数据库总是以相同的顺序写入，则读取总是看到一致的序列，不会发生这种反常。然而，在许多分布式据库中，不同的分区独立运行（异地多活），因此不存在全局写入顺序。这就导致当用户从数据库中读数据时，可能会看到数据库的某部分旧值和另一部分新值。</p>
<p>一个解决方案是确保任何具有因果顺序关系的写入都交给一个分区来完成，但该方案真实实现效率会大打折扣。现在有一些新的算法来显式地追踪事件因果关系。</p>
<h1 id="复制滞后的解决方案"><a href="#复制滞后的解决方案" class="headerlink" title="复制滞后的解决方案"></a>复制滞后的解决方案</h1><p>使用最终一致性系统时，最好事先就思考这样的问题：如果复制延迟增加到几分钟甚至几小时，那么应用层的行为会是什么样子？如果答案是“没问题”，那没得说。但是，如果带来糟糕的用户体验，那么在设计系统时，就要考虑提供一个更强的一致性保证，比如写后读。</p>
<p>正如前面所讨论的，在应用层可以提供比底层数据库更强有力的保证。例如只在主节点上进行特定类型的读取，而代价则是，应用层代码中处理这些问题通常会非常复杂，且容易出错。</p>
<p>如果应用程序开发人员不必担心这么多底层的复制问题，而是假定数据库在“做正确的情”，情况就变得很简单。<font color="orange">而这也是事务存在的原因，事务是数据库提供更强保证的一种方式</font>。</p>
<p>单节点上支持事务已经非常成熟。然而，在转向分布式数据库（即支持复制和分区）的过程中，有许多系统却选择放弃支持事务，并声称事务在性能与可用性方面代价过髙。后面的章节将会更深入的理解事务。</p>
<h1 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h1><p>主从复制存在一个明显的缺点：系统只有一个主节点，而所有写入都必须经由主节点。如果由于某种原因，例如与主节点之间的网络中断而导致主节点无法连接，主从复制方案就会影响所有的写入操作。</p>
<p>对主从复制模型进行自然的扩展，则可以配置多个主节点，每个主节点都可以接受写操作，处理写的每个主节点都必须将该数据更改转发到所有其他节点。这就是多主节点复制。此时，每个主节点还同时扮演其他主节点的从节点。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>在一个数据中心内部使用多主节点基本没有太大意义，其复杂性已经超过所能带來的好处。但是，在以下场景这种配置则是合理的：</p>
<h3 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h3><p>为了容忍整个数据中心级别故障或者更接近用户，可以把数据库的副本横跨多个数据中心。而如果使用常规的基于主从的复制模型，主节点势必只能放在其中的某一个数据中心，而所有写请求都必须经过该数据中心。有了多主节点复制模型，则可以在每个数据中心都配置主节点，在毎个数据中心内，采用常规的主从复制方案；而在数据中心之间，由各个数据中心的主节点来负责同其他数据中心的主节点进行数据的交换、更新。</p>
<p>有些数据库已内嵌支持了多主复制，但有些则借助外部工具来实现，例如<strong>MySQL</strong>的</p>
<p><strong>Tungsten</strong> <strong>Replicator</strong>,<strong>PostgreSQL</strong>的<strong>BDR</strong>以及<strong>Oracle</strong>的<strong>GoldenGate</strong>，由于多主复制在许多数据库中还只是新增的髙级功能，所以可能存在配置方面的细小缺陷，在与其他数据库功能（例如自增主键，触发器和完整性约束等）交互时有时会出现意想不到的副作用。出于这个原因，一些人认为多主复制比较危险，应该谨慎使用或者避免使用。</p>
<h3 id="离线客户端操作"><a href="#离线客户端操作" class="headerlink" title="离线客户端操作"></a>离线客户端操作</h3><p>比如手机，笔记本电脑和其他设备上的日历应用程序。无论设备当前是否联网，都需要能够随时査看当前的会议安排（对应于读请求）或者添加新的会议（对应于写请求）。在离线状态下进行的任何更改，会在下次设备上线时，与服务器以及其他设备同步。</p>
<p>这种情况下，毎个设备都有一个充当主节点的本地数据库（用来接受写请求），然后在所有设备之间采用异步方式同步这些多主节点上的副本，同步滞后可能是几小时或者数天，具体时间取决于设备何时可以再次联网。</p>
<p>从架构层面来看，上述设置基本上等同于数据中心之间的多主复制，只不过是个极端情况，即一个设备就是数据中心，而且它们之间的网络连接非常不可靠。有一些工具可以使多主配置更为容易，如<strong>CouchDB</strong>就是为这种操作模式而设计的。</p>
<h3 id="协作编辑"><a href="#协作编辑" class="headerlink" title="协作编辑"></a>协作编辑</h3><p>实时协作编辑应用程序允许多个用户同时编辑文档。我们通常不会将协作编辑完全等价于数据库复制问题，但二者确实有很多相似之处。当一个用户编辑文档时，所做的更改会立即应用到本地（本地主节点），然后异步复制到服务器以及编辑同一文档的其他用户。</p>
<p>如果要确保不会发生编辑冲突，则应用程序必须先将文档锁定，然后才能对其进行编辑。如果另一个用户想要编辑同一个文档，首先必须等到第一个用户提交修改并释放锁。这种协作模式相当于主从复制模型下在主节点上执行事务操作</p>
<h2 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h2><p>多主复制的最大问题是可能发生写冲突，这意味着必须有方案来解决冲突。例如，两个用户同时编辑文档，用户1将页面的标题从<strong>A</strong>更改为<strong>B</strong> , 与此同时用户2却将标题从<strong>A</strong>改为<strong>C</strong>。每个用户的更改都顺利地提交到本地主节点。但是，当更改被异步复制到对方时，却发现存在冲突。</p>
<h3 id="同步于异步冲突检测"><a href="#同步于异步冲突检测" class="headerlink" title="同步于异步冲突检测"></a>同步于异步冲突检测</h3><p>如果是主从复制数据库，第二个写请求要么会被阻塞直到第一个写完成，要么被中止（用户必须重试），然而在多主节点的复制模型下，这两个写请求都是成功的，并且只能在稍后的时间点上才能异步检测到冲突，那时再要求用户层来解决冲突为时已晚。</p>
<p>理论上，也可以做到同步冲突检测，即等待写请求完成对所有副本的同步，然后再通知用户写入成功。但是，这样做将会失去多主节点的主要优势：允许每个主节点独立接受写请求。如果确实想要同步方式冲突检测，或许应该考虑采用单主节点的主从复制模型。</p>
<h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>处理冲突最理想的策略是避免发生冲突，<font color="orange">即如果应用层可以保证对特定记录的写请求总是通过同一个主节点，这样就不会发生写冲突。现实中，由于不少多主节点复制模型所实现的冲突解决方案存在瑕疵，因此，避免冲突反而成为大家普遍推荐的首选方案</font>。</p>
<p>例如，多人协作文档系统中，对同一文档的写操作都在一个数据中心的主节点上，不同文档的写操作可以放在不同数据中心。从用户的角度来看，这基本等价于主从复制模型。</p>
<p>但是，有时可能需要改变事先指定的主节点，例如由于该数据中心发生故障，不得不将流量重新路由到其他数据中心。</p>
<h3 id="收敛于一致状态"><a href="#收敛于一致状态" class="headerlink" title="收敛于一致状态"></a>收敛于一致状态</h3><p>对于主从复制模型，数据更新符合顺序性原则，即如果同一个字段有多个更新，则最后一个写操作将决定该字段的最终值。</p>
<p>对于多主节点复制模型，由于不存在这样的写入顺序，所以最终值也会变得不确定。例如上面同步编辑文档的例子，主节点1接受到请求把标题更新为<strong>B</strong> , 然后更新为<strong>C</strong> ;而在主节点2,则是相反的更新顺序。两者都无法辩驳谁更正确。</p>
<p>如果每个副本都只是按照它所看到写入的顺序执行，那么数据库最终将处干不一致状态这绝对是不可接受的，所有的复制模型至少应该确保数据在所有副本中最终状态一定是一致的。因此，数据库必须以一种收敛趋同的方式来解决冲突，这也意味着<font color="orange">当所有更改最终被复制、同步之后，所有副本的最终值是相同的</font>。（可以理解为多主节点复制的最终一致性？）</p>
<p>实现收敛的冲突解决有以下可能的方式：</p>
<ul>
<li><p>给每个写入分配唯一的<strong>ID</strong>, 例如，一个时间戳，一个足够长的随机数，一个<strong>UUID</strong>或者一个基于键-值的哈希，挑选最高<strong>ID</strong>的写入作为胜利者，并将其他写入丢弃。如果基于时间戳，这种技术被称为<strong>最后写入者获胜</strong>。虽然这种方法很流行，但是很容易造成数据丢失。我们将在后面详细解释。</p>
</li>
<li><p>为每个副本分配一个唯一的<strong>ID</strong>，并制定规则，例如序号髙的副本写入始终优先于序号低的副本。这种方法也可能会导致数据丢失</p>
</li>
<li><p>以某种方式将这些值合并在一起。例如，按字母顺序排序，然后拼接在一起，例如上面文档标题编辑的例子合并后的结果可能变成：BC</p>
</li>
<li><p>利用预定义好的格式来记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突（可能会提示用户）</p>
</li>
</ul>
<h3 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h3><p><font color="orange">解决冲突最合适的方式可能还是依靠应用层，所以大多数多主节点复制模型都有工具来让用户编写应用代码来解决冲突。可以在写入时或在读取时执行这些代码逻辑</font>：</p>
<ul>
<li><p>在写入时执行</p>
<ul>
<li><p>只要数据库系统在复制变更日志时检测到冲突，就会调用应用层的冲突处理程</p>
<p>序。例如，<strong>Bucardo</strong>支持编写一段<strong>Perl</strong>代码。这个处理程序通常不能在线提示用</p>
<p>户，而只能在后台运行，这样速度更快</p>
</li>
</ul>
</li>
<li><p>在读取时执行</p>
<ul>
<li><p>当检测到冲突时，所有冲突写入值都会暂时保存下来。下一次读取数据时，会将</p>
<p>数据的多个版本读返回给应用层。应用层可能会提示用户或自动解决冲突，并将</p>
<p>最后的结果返回到数据库。<strong>CouchDB</strong>采用了这样的处理方式。</p>
</li>
</ul>
</li>
</ul>
<h3 id="自动冲突解决"><a href="#自动冲突解决" class="headerlink" title="自动冲突解决"></a>自动冲突解决</h3><p>冲突解决的规则可能会变得越来越复杂，且自定义代码很容易出错，有一些有意思的研究尝试自动解决并发修改所引起的冲突：</p>
<ul>
<li><p>无冲突的复制数据类型 (<strong>Conflict**</strong>-<strong>**freeReplicated</strong> <strong>Datatypes</strong>,<strong>CRDT</strong>)。<strong>CRDT</strong>是可以由多个用户同时编辑的数据结构，包括<strong>map</strong>、<strong>ordered</strong> <strong>list</strong>、计数器等，并且以内置的合理方式自动地解决冲突</p>
</li>
<li><p>可合并的持久数据结构（<strong>Mergeable</strong> <strong>persistent</strong> <strong>data</strong>) 。它跟踪变更历史，类似于<strong>Git</strong>版本控制系统，并提出三向合并功能。</p>
</li>
<li><p>操作转换 (<strong>Operational  transformation</strong>) 。它是<strong>Etherpad</strong>和<strong>Google Docs</strong>等协作编辑应用背后的冲突解决算法。专为可同时编辑的有序列表而设计，如文本文档的字符列表。</p>
</li>
</ul>
<p>这些算法总体来讲还处于早期阶段，但将来它们可能会被整合到更多的数据系统中。这些自动冲突解决方案可以使主复制模型更简单、更容易被应用程序来集成。</p>
<h1 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h1><p>复制的拓扑结构描述了写请求从一个节点的传播到其他节点的通信路径。如果有两个主节点，则只存在一个合理的拓扑结构：主节点1必须把所有的写同步到主节点2，反之亦然。但如果存在两个以上的主节点，则会有多个可能的同步拓扑结构。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwordAndTea"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SwordAndTea" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SwordAndTea" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">215k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">11:56</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
