<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="SwordAndTea&#39;s Blog">
<meta property="og:url" content="http://swordandtea.github.io/page/3/index.html">
<meta property="og:site_name" content="SwordAndTea&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SwordAndTea">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>SwordAndTea's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SwordAndTea's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/31/machine_learning/linear_model/softmax-regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/31/machine_learning/linear_model/softmax-regression/" class="post-title-link" itemprop="url">softmax_regress</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-31 16:17:48" itemprop="dateCreated datePublished" datetime="2021-01-31T16:17:48+08:00">2021-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-03 20:21:05" itemprop="dateModified" datetime="2021-04-03T20:21:05+08:00">2021-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index">
                    <span itemprop="name">machine learning</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>在多分类问题中，一些分类器是利用多个二分类器来做分类的，有些模型则能直接进行多分类学习。softmax-regress就是一种能够直接进行多分类学习的线形分类模型（虽然叫regress，但本身是分类模型，有点像logistic-regression）。</p>
<h1 id="one-hot-encoding"><a href="#one-hot-encoding" class="headerlink" title="one-hot encoding"></a>one-hot encoding</h1><p>对于多分类学习任务，我们通常会把可能的分类结果种类用数字来表示，例如对于一个可能有3种分类结果的学习任务，我们可以使用$\{1, 2, 3\}$来分别表示第一类到第三类。如果使用这个自然序编码来对分类结果种类进行编码，那么对于每一个训练样本，我们需要的输出就只有一个。</p>
<p>使用自然序编码时，如果分类结果之间本身没有自然序的关系， 对于模型的输出和样本真实的标签之间的距离将不好表示。例如对于某个样本来说，模型的输出结果是1，表示第二类，但样本真实的标签为3，表示第3类，此时如果将距离定义为$|1-3| = 2$，这在分类结果之间本身没有自然序的关系的情况下显然是不太合理的。</p>
<p>另外一种表示分类结果的方法就是one-hot encoding。one-hot encoding将每一种分类结果用一个向量表示，例如，还是对于一个可能有3种分类结果的学习任务，我们可以使用$\{\{1, 0, 0\}, \{0, 1, 0\}, \{0, 0, 1\}\}$来分别表示第一类到第三类，这样每个种类之间可以看作是没有直接关系的（种类的表示向量之间两两正交）。</p>
<p>所以，对于种类之间有自然序关系的分类学习任务，可以使用自然序来对结果进行编码。但是如果种类之间没有自然序关系，应该尽量使用one-hot encoding。</p>
<p>softmax-regression模型使用的就是one-hot encoding来对分类结果进行表示。</p>
<h1 id="softmax-regression-网络结构"><a href="#softmax-regression-网络结构" class="headerlink" title="softmax-regression 网络结构"></a>softmax-regression 网络结构</h1><p>对于一个有n个输入特征，m个可能分类结果的网络来说，其结构为：</p>
<script type="math/tex; mode=display">
o_1 = x_1w_{11} + x_2w_{21} + \dots + x_nw_{n1} + b_1 \\
o_2 = x_1w_{12} + x_2w_{22} + \dots + x_nw_{n2} +b_2 \\
\dots \\
o_m = x_1w_{1m} + x_2w_{2m} + \dots + x_nw_{nm} + b_m</script><p>由此可见一个softmax-regression网络是一个单层的全连接网络。</p>
<p><img src="/2021/01/31/machine_learning/linear_model/softmax-regression/softmax_regression_net_structure.png" alt="net structure" style="zoom:50%;"></p>
<h1 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h1><p>在softmax-regression的网络中，我们可将每个输出看作一个样本可能是某一类别的概率，输出结果最大的那个就是最有可能的分类结果。但是最为概率，就需要输出的值位于$[0, 1]$之间，并且所有值之和为1。这对于使用线形模型的输出来说有些困难。所以为了保证让网络输出的结果能够作为概率，需要对输出作为进一步处理，保证输出的结果必须为非负并且和为1。softmax函数就是一个这样的函数:</p>
<script type="math/tex; mode=display">
y_i = softmax(o_i) = \frac{e^{(oi)}}{\sum_{j=0}^{m} e^{(o_j)}}</script><font color="orange">虽然softmax函数不是一个线性函数，但是softmax-regression的输出仍然是由输入特征的线形变换（仿射变换）决定的，所以softmax-regression仍然是一个线形模型。</font>



<h1 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h1><p>交叉熵是一个信息论中的概念，它衡量了预测的概率分布和真实的概率分布之间的差异。在softmax-regression中，可以将网络预测的输出看作预测的概率分布，将样本的真实类别对应的ont-hot编码看作是真实概率分布，这样就可以定义模型的损失函数了。其定义如下：</p>
<script type="math/tex; mode=display">
l(\hat{y}, y) = - \sum_{j=0}^M y_j \space log \space \hat{y_j}</script><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>有了模型和损失函数后，就可以使用随机梯度下降法（Stochastic Gradient Descent）对模型进行训练了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> liner_regression.fashion_mnist_dataset <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># read data</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_data_iter, test_data_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initial model parameters</span></span><br><span class="line"><span class="comment"># each image in dataset is a 28 * 28 image, in this section, we will flatten each image,</span></span><br><span class="line"><span class="comment"># treat them as vectors of length 784</span></span><br><span class="line"><span class="comment"># so X&#x27;s size is 256 * 784, W&#x27;s size is 784 * 10, b&#x27;s size is 1 * 10, y&#x27;s size is 256 * 10 (y = softmax(XW + b))</span></span><br><span class="line">num_inputs = <span class="number">28</span> * <span class="number">28</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = tf.Variable(tf.random.normal(shape=(num_inputs, num_outputs), mean=<span class="number">0</span>, stddev=<span class="number">0.01</span>))</span><br><span class="line">b = tf.Variable(tf.zeros(num_outputs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define softmax operation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">linear_result: tf.Variable</span>):</span></span><br><span class="line">    <span class="comment"># if linear_result is n * m matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># exped is n * m matrix</span></span><br><span class="line">    exped = tf.exp(linear_result)</span><br><span class="line">    <span class="comment"># sum_of_each_line is n * 1 matrix, if keepdims=False, then sum_of_each_line will be 1 * n matrix</span></span><br><span class="line">    sum_of_each_line = tf.reduce_sum(exped, <span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> exped / sum_of_each_line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define modal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">data_x, param_w, param_b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> softmax(tf.matmul(data_x, param_w) + param_b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define loss, use cross-entropy loss</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span>(<span class="params">predicted_y, label_y</span>):</span></span><br><span class="line">    <span class="comment"># predicted_y is a n * m matrix, then label_y is a 1 * n matrix</span></span><br><span class="line">    <span class="comment"># in this example, predicted_y is 256 * 10, label_y = 1 * 256</span></span><br><span class="line">    <span class="keyword">return</span> -tf.math.log(tf.boolean_mask(predicted_y, tf.one_hot(label_y, depth=predicted_y.shape[-<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define optimizer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stochastic_gradient_descent</span>(<span class="params">params, gradients, batch_size, learning_rate: <span class="built_in">float</span></span>):</span></span><br><span class="line">    <span class="comment"># Because our loss is calculated as a sum over the mini-batch of examples,</span></span><br><span class="line">    <span class="comment"># we normalize our step size by the batch size (batch_size),</span></span><br><span class="line">    <span class="comment"># so that the magnitude of a typical step size does not depend heavily on our choice of the batch size.</span></span><br><span class="line">    <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(params, gradients):</span><br><span class="line">        param.assign_sub(grad * learning_rate / batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># classification accuracy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span>(<span class="params">predicted_y, label_y</span>):</span></span><br><span class="line">    <span class="comment"># predicted_y is a n * m matrix, then label_y is a 1 * n matrix</span></span><br><span class="line">    <span class="comment"># in this example, predicted_y is 256 * 10, label_y = 1 * 256</span></span><br><span class="line">    <span class="comment"># tf.argmax returns the index with the largest value across axes of a tensor.</span></span><br><span class="line">    predicted_y = tf.argmax(predicted_y, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cmp is a 1 * n `boolean` matrix</span></span><br><span class="line">    cmp = tf.cast(predicted_y, label_y.dtype) == label_y</span><br><span class="line">    <span class="comment"># return num of right predictions and the total num of predictions</span></span><br><span class="line">    <span class="keyword">return</span> tf.reduce_sum(tf.cast(cmp, label_y.dtype)), label_y.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        num_right_predictions = <span class="number">0</span></span><br><span class="line">        num_total_predictions = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> train_data_iter:</span><br><span class="line">            <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> g:</span><br><span class="line">                x = tf.reshape(x, shape=(x.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">                y_hat = net(x, W, b)</span><br><span class="line">                l = cross_entropy(y_hat, y)</span><br><span class="line"></span><br><span class="line">            dw, db = g.gradient(l, [W, b])</span><br><span class="line">            stochastic_gradient_descent([W, b], [dw, db], batch_size, <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">            right_pred, total_pred = accuracy(y_hat, y)</span><br><span class="line">            num_right_predictions += right_pred</span><br><span class="line">            num_total_predictions += total_pred</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&#x27;accuracy after one epoch is : &#x27;</span>, <span class="built_in">float</span>(num_right_predictions) / <span class="built_in">float</span>(num_total_predictions))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main&quot;</span>:</span><br><span class="line">    train()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/15/others/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/others/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">常用git命令总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-15 17:29:14" itemprop="dateCreated datePublished" datetime="2021-01-15T17:29:14+08:00">2021-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-11 15:57:19" itemprop="dateModified" datetime="2021-05-11T15:57:19+08:00">2021-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="clone-仓库相关"><a href="#clone-仓库相关" class="headerlink" title="clone 仓库相关"></a>clone 仓库相关</h1><p>git clone仓库有两种形式，一种是以ssh协议的形式，另外一种是以https协议的形式。使用ssh协议的形式时，需要将ssh公钥上传到github或者gitlab。使用https协议需要在clone的时候输入github或者gitlab的账号和密码。</p>
<ul>
<li><code>git clone [-b &lt;branch name&gt;] &lt;repository url&gt;</code> <ul>
<li>-b 执行需要拉取的分支，不指定则拉取master分支</li>
</ul>
</li>
<li><code>git clone https://&lt;username&gt;:&lt;password&gt;@&lt;repository url&gt;</code><ul>
<li>在使用https协议拉取仓库的时候，直接在url中指定账户和密码，@作为分割符，如果账户或者密码中含有“@”符，则需要将其替换为“%40”</li>
</ul>
</li>
</ul>
<h1 id="工作区、暂存区状态相关"><a href="#工作区、暂存区状态相关" class="headerlink" title="工作区、暂存区状态相关"></a>工作区、暂存区状态相关</h1><ul>
<li><code>git status</code><ul>
<li>查看工作区和暂存区的文件状态</li>
</ul>
</li>
<li><code>git add &lt;filename&gt;</code><ul>
<li>将工作区的某个文件添加到暂存区</li>
</ul>
</li>
<li><code>git add .</code><ul>
<li>将工作区全部文件添加到暂存区</li>
</ul>
</li>
<li><p><code>git commit -m&quot;[commit message]&quot;</code></p>
<ul>
<li>提交暂存区的文件修改到本地仓库</li>
</ul>
</li>
<li><p><code>git rm &lt;filename&gt;</code></p>
<ul>
<li>取消对文件的追踪</li>
</ul>
</li>
</ul>
<h1 id="提交历史相关"><a href="#提交历史相关" class="headerlink" title="提交历史相关"></a>提交历史相关</h1><ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit [filename]</code><ul>
<li>查看当前分支的提交历史</li>
<li>—graph：以图表的新式</li>
<li>—pretty=oneline：只显示commit信息，不显示提交作者和时间等其他信息</li>
<li>—abbrev-commit：commit id以简写的形式展示</li>
<li>filename: 可选项，只显示某个文件的提交历史</li>
</ul>
</li>
<li><code>git reflog</code><ul>
<li>查看操作记录，<font color="red">借助该命令可以取消版本回退。</font></li>
</ul>
</li>
<li><code>git reset [--soft|--mixed|--hard] HEAD^</code><ul>
<li>将当前分支的提交回退到上一个提交</li>
<li>—soft：当前提交修改会保存到暂存区，并且<font color="orange">当前工作区和暂存区的修改也会保留</font></li>
<li>—mix：当前提交的修改会保存到工作区，并且<font color="orange">当前暂存区的修改都会移到工作区</font></li>
<li>—hard: 丢弃当前提交的修改，并且<font color="red">丢弃当前工作区和暂存区的修改</font></li>
<li><font color="orange">--mix是默认的选项</font></li>
<li>一个快速清除当前暂存区和工作区的命令：<code>git add . &amp;&amp; git reset --hard HEAD</code>。注意没有”^”，否则就回退到了上个提交</li>
</ul>
</li>
<li><code>git reset [--soft|--mixed|--hard] HEAD~&lt;number&gt;</code><ul>
<li>回退当前分支提交到上number个版本</li>
</ul>
</li>
<li><code>git reset [--soft|--mixed|--hard] HEAD &lt;commit id&gt;</code><ul>
<li>回退当前分支提交到指定的commit id</li>
</ul>
</li>
<li><code>git checkout &lt;commit id&gt; &lt;filename&gt;</code><ul>
<li>只将某个文件回退到某个版本</li>
</ul>
</li>
</ul>
<h1 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h1><ul>
<li><code>git branch</code><ul>
<li>查看本地有哪些分支</li>
</ul>
</li>
<li><code>git branch &lt;branch name&gt;</code><ul>
<li>创建分支，但是目前仍然位于当前分支</li>
</ul>
</li>
<li><code>git branch &lt;branch name&gt; &lt;commit id&gt;</code><ul>
<li>基于commit id创建分支，目前仍位于当前分支</li>
</ul>
</li>
<li><code>git checkout -b &lt;branch name&gt;</code><ul>
<li>创建并切换分支</li>
</ul>
</li>
<li><code>git checkout -b &lt;branch name&gt; &lt;commit id&gt;</code><ul>
<li>基于某个commit id创建并切换分支</li>
</ul>
</li>
<li><code>git checkout &lt;branch name&gt;</code><ul>
<li>切换分支，<font color="orange">如果本地没有对应分支但是远程仓库有</font>，则将对应的远程分支拉取到本地并切换到对应分支</li>
</ul>
</li>
<li><code>git branch -d &lt;branch name&gt;</code><ul>
<li>删除分支，如果分支有提交但是没有合入其他分支，会报错</li>
</ul>
</li>
<li><p><code>git branch -D &lt;branch name&gt;</code></p>
<ul>
<li>强制删除某个分支</li>
</ul>
</li>
<li><p><code>git checkout -f &lt;branch name&gt;</code></p>
<ul>
<li>强行切换到某个分支，<font color="red">如果当前工作区和暂存区有内容，将丢弃这些内容</font></li>
</ul>
</li>
</ul>
<h1 id="合并相关"><a href="#合并相关" class="headerlink" title="合并相关"></a>合并相关</h1><ul>
<li><p><code>git merge &lt;branch name&gt;</code></p>
<ul>
<li>将branch name对应的分支合并到当前分支</li>
<li>如果合并有冲突，需要手动解决冲突（到有冲突的文件进行编辑）后，执行add和commit</li>
</ul>
</li>
</ul>
<h1 id="远程仓库相关"><a href="#远程仓库相关" class="headerlink" title="远程仓库相关"></a>远程仓库相关</h1><ul>
<li><code>git remote add origin &lt;remote repository url&gt;</code><ul>
<li>关联远程仓库</li>
</ul>
</li>
<li><code>git remote remove origin</code><ul>
<li>取消关联远程仓库</li>
</ul>
</li>
<li><code>git push origin &lt;branch&gt;</code><ul>
<li>将本地分支的commit推送到到远程分支</li>
</ul>
</li>
<li><code>git push --force-with-lease origin &lt;branch&gt;</code><ul>
<li>以最小强制更新的手段，将本地分支推送到远程分支</li>
<li><font color="red">尽量不要强制推送远程分支，尤其是其他人开发的分支</font></li>
</ul>
</li>
<li><code>git push origin --delete &lt;branch&gt;</code><ul>
<li>删除远程分支</li>
</ul>
</li>
</ul>
<h1 id="子模块相关"><a href="#子模块相关" class="headerlink" title="子模块相关"></a>子模块相关</h1><ul>
<li><code>git submodule add &lt;repository&gt; &lt;dir&gt;</code><ul>
<li>添加子模块，子模块的链接为url，添加到相对于当前目录的dir目录下</li>
</ul>
</li>
<li><code>git submodule init</code><ul>
<li>读取本地子模块配置文件</li>
</ul>
</li>
<li><code>git submodule update</code><ul>
<li>拉取子模块</li>
</ul>
</li>
<li><p><code>git submoduel update &lt;submodule dir path&gt;</code></p>
<ul>
<li>拉取指定的子模块</li>
</ul>
</li>
<li><p><code>git clone --recurse-submodules</code></p>
<ul>
<li>拉取带有子模块的仓库时，同时也拉取子模块</li>
</ul>
</li>
</ul>
<h1 id="tag相关"><a href="#tag相关" class="headerlink" title="tag相关"></a>tag相关</h1><ul>
<li><code>git tag</code><ul>
<li>查看所有的标签</li>
</ul>
</li>
<li><code>git tag &lt;tag name&gt;</code><ul>
<li>创建一个轻量标签，轻量标签建议在创建临时标签时使用</li>
</ul>
</li>
<li><code>git tag -a &lt;tag name&gt; -m &lt;tag message&gt;</code><ul>
<li>创建一个附注标签，正式标签使用</li>
</ul>
</li>
<li><code>git show &lt;tag name&gt;</code><ul>
<li>查看标签信息和与之对应的提交信息</li>
</ul>
</li>
<li><code>git push origin &lt;tag name&gt;</code><ul>
<li>将标签推送到远程仓库</li>
</ul>
</li>
<li><code>git tag -d &lt;tag name&gt;</code><ul>
<li>删除本地标签</li>
</ul>
</li>
<li><code>git push origin --delete &lt;tag name&gt;</code><ul>
<li>删除远程标签</li>
</ul>
</li>
</ul>
<h1 id="rebase相关"><a href="#rebase相关" class="headerlink" title="rebase相关"></a>rebase相关</h1><ul>
<li><code>git rebase &lt;branch name&gt;</code><ul>
<li>将当前分支rebase到branch name对应的分支</li>
</ul>
</li>
<li><code>git rebase -i HEAD~&lt;num&gt;</code><ul>
<li>将当前提交和当前提交前的共num个提交合并为</li>
</ul>
</li>
<li><code>git rebase --abort</code><ul>
<li>rebase 有冲突时，取消rebase</li>
</ul>
</li>
<li><code>git rebase --continue</code><ul>
<li>rebase 冲击解决后，继续执行rebase操作</li>
</ul>
</li>
</ul>
<h1 id="stash-相关"><a href="#stash-相关" class="headerlink" title="stash 相关"></a>stash 相关</h1><p>stash 通常用于当前在一个分支有代码的更新放在工作区或者暂存区，但是需要临时去处理其他分支的代码，又不行在当前分支进行提交操作，那么可以先将当前分支中工作区和暂存区的代码stash起来，之后再pop回来。</p>
<ul>
<li><code>git stash save &lt;message&gt;</code><ul>
<li>将当前工作区和暂存区的修改保存到其他地方，并将当前工作区和暂存区清空</li>
</ul>
</li>
<li><code>git stash list</code><ul>
<li>查看stash 的列表</li>
</ul>
</li>
<li><code>git stash pop [index | stash_id]</code> <ul>
<li>如果不传index或者stash id参数，将stash列表的最后一个stash恢复到工作区和暂存区，并将该stash从stash list中删除</li>
<li><font color="red">stash list的存储结构是一个栈结构，最后stash的stash id最小，也最新被pop出来</font></li>
<li>如果传入index或者stash id参数，则将其对应的stash恢复到工作去和暂存区，并将该stash从stash list中删除</li>
</ul>
</li>
<li><code>git stash apply [index | stash_id]</code><ul>
<li>除了不删除对应的stash外，其他 和 <code>git stash pop</code>相同</li>
</ul>
</li>
<li><code>git stash drop [stash id]</code><ul>
<li>删除一个存储进度</li>
</ul>
</li>
<li><code>git stash clear</code><ul>
<li>清除stash list</li>
</ul>
</li>
</ul>
<h1 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h1><ul>
<li><code>.gitignore</code><ul>
<li>记录git应该不对哪些文件进行跟踪的配置</li>
</ul>
</li>
<li><code>.gitmoduels</code><ul>
<li>记录子模块信息的文件</li>
</ul>
</li>
<li><code>.gitattributes</code><ul>
<li>git-lfs应该处理的文件信息</li>
</ul>
</li>
<li><code>.gitlab-ci.yml</code><ul>
<li>gitlab ci配置文件</li>
</ul>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>git-lfs<ul>
<li>git大文件处理工具</li>
</ul>
</li>
<li>分离头指针<ul>
<li>当前HEAD指针所指向的commit没有和任何分支关联，这种情况一般出现在直接从某个commit checkout出来的情况（即执行了<code>git checkout &lt;commit id&gt;</code> ）。<font color="red">如果在分离头指针进行了代码修改并提交后，再切换到其他分支，那么这个提交就会丢失，活都白干了。</font>正确做法是为该分离的头指针创建branch进行关联，这时执行<code>git checkout -b &lt;branch&gt;</code>即可。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/06/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">原型模式与单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-06 17:09:24" itemprop="dateCreated datePublished" datetime="2021-01-06T17:09:24+08:00">2021-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:02:33" itemprop="dateModified" datetime="2021-03-03T17:02:33+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原型模式简介"><a href="#原型模式简介" class="headerlink" title="原型模式简介"></a>原型模式简介</h1><p>原型模式将对象的复制过程交给被复制的实际对象本身。原型模式为所有支持复制的对象声明了一个通用接口，该接口能够让你克隆对象。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/02/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">生成器模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-02 16:27:31" itemprop="dateCreated datePublished" datetime="2021-01-02T16:27:31+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:02:18" itemprop="dateModified" datetime="2021-03-03T17:02:18+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>生成器模式使你能够<font color="red">分步</font>创建复杂对象。假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中。</p>
<p>例如你想要示例化一个有车库、带游泳池和花园的房子对象。</p>
<p>一种实现方式是：设计一个”House”的基类，并让每种类型的房子继承自这个”House”基类，例如”HouseWithGarage”、”HouseWithGarden”、”HouseWithGarageAndGraden”等等。但是这种方式的结果就是你可能需要编写许多子类代码。</p>
<p>另外一种实现方式：无需生成子类，只设计一个”House”的类，同时这个”House”类拥有一个包括所有可能参数的超级构造函数，例如<code>House(bool hasGarage, bool hasGraden, bool hasSwimmingPool, ...)</code>。这种方式可以避免生成子类，但是如果需要增加一种房子类型，那么就不得不修改构造函数，这可能会导致使用之前构造函数的代码失效。另外这个超级构造函数中可能大多数参数最后都没有实际被使用到，导致构造函数的调用形式不简洁。</p>
<p>这种情况就可以考虑使用生成器模式了。</p>
<h2 id="生成器模式简介"><a href="#生成器模式简介" class="headerlink" title="生成器模式简介"></a>生成器模式简介</h2><p>生成器模式将构造对象的代码从产品类中抽取出来，并将其放在一个名为生成器的独立类中。当创建对象的时候，是需要按需调用生成器提供的构造步骤即可。在一下情况下，你需要设计多种类型的生成器来构建出有相同接口但是表现形式不同的对象。</p>
<p>另外，你可以将用于创建对象的一系列的生成器调用步骤抽取出来形成一个单独的主管类。主管类非常适合放入各种例行构造流程，以便在程序中反复使用。</p>
<h2 id="生成器代码样例"><a href="#生成器代码样例" class="headerlink" title="生成器代码样例"></a>生成器代码样例</h2><p>一个创建汽车和汽车使用手册的设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//other class a car builder that need</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarEngine</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GPS</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//a pure abstract class to use as an interface</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setSeats</span><span class="params">(<span class="keyword">int</span> number)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(<span class="keyword">const</span> CarEngine &amp;engine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setGPS</span><span class="params">(<span class="keyword">const</span> GPS &amp;gps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>;</span></span><br><span class="line"><span class="comment">//a car builder that build car itself</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarCarBuilder</span>:</span> <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car *_car;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_car) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _car;</span><br><span class="line">        &#125;</span><br><span class="line">        _car = <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setSeats</span><span class="params">(<span class="keyword">int</span> number)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//set seat for car itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(<span class="keyword">const</span> CarEngine &amp;engine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//set engine for car itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setGPS</span><span class="params">(<span class="keyword">const</span> GPS &amp;gps)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//set gps for car itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _car;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarManual</span>;</span></span><br><span class="line"><span class="comment">//a car builder that build car&#x27;s manual</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarManualBuilder</span>:</span> <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CarManual *_manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_manual) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _manual;</span><br><span class="line">        &#125;</span><br><span class="line">        _manual = <span class="keyword">new</span> CarManual()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> setSeats() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">//add description for how to use seats in manual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> setEngine(<span class="keyword">const</span> CarEngine &amp;engine) <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">//add car engine description in manual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> setGPS(<span class="keyword">const</span> GPS &amp;pgs) <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">//add gps use guide in manual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> CarManual* getResult() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _manual;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a manager class that use builder to build car</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarCarBuilderDirector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">buildSUV</span><span class="params">(CarBuilder &amp;builder)</span> </span>&#123;</span><br><span class="line">        builder.setSeats(<span class="number">4</span>);</span><br><span class="line">        NormalEngine normalEngine;</span><br><span class="line">        builder.setEngine(normalEngine);</span><br><span class="line">        NormalGPS normalGps;</span><br><span class="line">        builder.setGPS(normalGps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car* <span class="title">buildSportsCar</span><span class="params">(CarBuilder &amp;builder)</span> </span>&#123;</span><br><span class="line">        builder.setSeats(<span class="number">2</span>);</span><br><span class="line">        SportEngine sportEngine;</span><br><span class="line">        builder.setEngine(sportEngine);</span><br><span class="line">        SportCarGPS sportCarGps;</span><br><span class="line">        builder.setGPS(sportCarGps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在CarCarBuilderDirector这个生成器主管类可以创建SUV类型的车辆对象，也可以创建SportsCar类型的对象。但在上例中我们没有定义基于CarBuilder接口的SUVCarBuilder类和SportsCarBuilder类。不是说不可以，而是说要结合具体的实际情况判断是否需要再定义SUVCarBuilder和SportsCarBuilder类，如果创建SUV和创建SportsCar的实现方式有差别的话，那么就可以再去定义SUVCarBuilder类和SportsCarBuilder类。</p>
<p>另外，我们在生成器接口中并没有提供获取构造结果对象的方法，因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</p>
<p>总之还是那句话，<font color="red">不基于实际应用场景的设计模式都是耍流氓</font>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。</p>
<p>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/28/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工厂模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-28 09:08:46" itemprop="dateCreated datePublished" datetime="2020-12-28T09:08:46+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:02:05" itemprop="dateModified" datetime="2021-03-03T17:02:05+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式保护简单工厂模式、工厂方法模式、抽象工厂模式</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="简单工厂模式简介"><a href="#简单工厂模式简介" class="headerlink" title="简单工厂模式简介"></a>简单工厂模式简介</h2><ul>
<li><font color="red">一个</font>抽象产品类，根据这个抽象产品类可派生出多个具体产品类</li>
<li><font color="red">一个</font>具体工厂类，具体工厂类用于生产多个具体产品类</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIDrawable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span> <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw button code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBox</span>:</span> <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw check box code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GUIType</span> &#123;</span></span><br><span class="line">    GUITypeButton,</span><br><span class="line">    GUITypeCheckBox,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">GUIDrawable* <span class="title">create</span><span class="params">(GUIType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> GUITypeButton:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Button();</span><br><span class="line">            <span class="keyword">case</span> GUITypeCheckBox:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CheckBox();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="工厂方法模式简介"><a href="#工厂方法模式简介" class="headerlink" title="工厂方法模式简介"></a>工厂方法模式简介</h2><ul>
<li><font color="red">一个</font>抽象产品类，根据这个抽象产品类可派生出多个具体产品类</li>
<li><font color="red">一个</font>抽象工厂类，可以派生出多个具体工厂类</li>
<li><font color="red">每个</font>具体工厂只能创建<font color="red">一个</font>具体产品</li>
</ul>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIDrawable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span> <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw button code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBox</span>:</span> <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw check box code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIDrawableFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GUIDrawable* <span class="title">create</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GUIDrawable* <span class="title">create</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Button();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBoxFactory</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GUIDrawable* <span class="title">create</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CheckBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="抽象工厂模式简介"><a href="#抽象工厂模式简介" class="headerlink" title="抽象工厂模式简介"></a>抽象工厂模式简介</h2><ul>
<li><font color="red">多个</font>抽象产品类，每个抽象产品类可以派生出多个具体产品类</li>
<li><font color="red">一个</font>抽象工厂类，可以派生出多个具体工厂类</li>
<li><font color="red">每个</font>具体工厂可以创建<font color="red">多个</font>具体产品</li>
</ul>
<h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIDrawable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span> <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clicked</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBox</span>:</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">checked</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinButton</span>:</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw win button code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clicked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinCheckBox</span>:</span> CheckBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw win label code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">checked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacButton</span>:</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw mac button code here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clicked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacCheckBox</span>:</span> CheckBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw mac label code here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">checked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CheckBox* <span class="title">createCheckBox</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinGUIFactory</span> :</span> <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WinButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CheckBox* <span class="title">createCheckBox</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WinCheckBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacGUIFactory</span>:</span> <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MacButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CheckBox* <span class="title">createLabel</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MacCheckBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在许多设计工作的初期都会使用简单工厂模式，随后演化为使用工厂方法模式， 随后演化为使用抽象工厂模式，甚至继续演化为使用原型模式或生成器模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/27/design_patterns/design-pattern-first-of-all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/design_patterns/design-pattern-first-of-all/" class="post-title-link" itemprop="url">design_pattern_first_of_all</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-27 21:32:23" itemprop="dateCreated datePublished" datetime="2020-12-27T21:32:23+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:01:21" itemprop="dateModified" datetime="2021-03-03T17:01:21+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font color="red">设计模式应该作为代码编写的一种指导，而不是一种准则，任何不结合实际应用场景的设计模式都是耍流氓。</font>

<p>设计模式中主要涉及到三种类型的设计模式：创建型模式（construct design pattern）、结构型模式（structure design pattern）、行为模式（behavior design pattern）。</p>
<ul>
<li>创建型模式主要关注如何合理地构造对象</li>
<li>结构型模式主要关注如何组织一个系统内部的各个类</li>
<li>行为模式主要定义类与类之间交互的方式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/19/Linux/Linux%E5%91%BD%E4%BB%A4%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/Linux/Linux%E5%91%BD%E4%BB%A4%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">Linux命令初步</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-19 22:35:25" itemprop="dateCreated datePublished" datetime="2020-12-19T22:35:25+08:00">2020-12-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/01/av_processing/%E8%A7%86%E9%A2%91/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/av_processing/%E8%A7%86%E9%A2%91/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">图像基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-01 09:08:46" itemprop="dateCreated datePublished" datetime="2020-12-01T09:08:46+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-28 20:15:19" itemprop="dateModified" datetime="2020-12-28T20:15:19+08:00">2020-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/video-processing/" itemprop="url" rel="index">
                    <span itemprop="name">video processing</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是颜色"><a href="#什么是颜色" class="headerlink" title="什么是颜色"></a>什么是颜色</h1><p>颜色是有不同波长的光发出的能量对人眼产生刺激后，人产生的一种感觉。</p>
<ul>
<li>不同波长的电磁波对应不同的颜色</li>
<li>人眼对在380nm(紫光)到760nm(红光)波长的光很敏感</li>
</ul>
<h1 id="光的光谱分布"><a href="#光的光谱分布" class="headerlink" title="光的光谱分布"></a>光的光谱分布</h1><p>光是一种多种波长，每种波长的强度不同的电磁波的混合。对于白光，就意味光中包含的所有波长的电磁波具有一样的强度。</p>
<p>光谱分布就是一个光的强度和波长的函数。</p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200709161946882.png" alt="image-20200709161946882" style="zoom:33%;"></p>
<p>由于颜色就是光对人眼产生的刺激，因此颜色也就可以用光谱分布表示。但是使用光谱分布来表示颜色太复杂，并且现实中也存在异谱同色的现象。</p>
<h1 id="颜色表示方法"><a href="#颜色表示方法" class="headerlink" title="颜色表示方法"></a>颜色表示方法</h1><h2 id="RGB颜色空间"><a href="#RGB颜色空间" class="headerlink" title="RGB颜色空间"></a>RGB颜色空间</h2><p>RGB是被用得最广泛的颜色空间，颜色用三个通道(r, g, b)表示，r表示red，g表示green，b表示blue。通常每个通道中值都是0～1的浮点数，或者用8比特表示的0～255之间的数。</p>
<p>人类的视觉系统也是基于RBG三原色的。</p>
<p><strong>但是有些颜色并不能由RBG三原色的组合表示，因为有些颜色的R通道是负的。</strong></p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200709200933168.png" alt="image-20200709200933168" style="zoom:33%;"></p>
<h2 id="CMY颜色空间"><a href="#CMY颜色空间" class="headerlink" title="CMY颜色空间"></a>CMY颜色空间</h2><p>颜色用三个通道(c, m, y)表示，c表示cyan(青)，m表示magenta(品红)，y表示yellow，它和RBG颜色空间的对应方式为：</p>
<script type="math/tex; mode=display">
(c, m, y) = (1, 1, 1) - (r, g, b)</script><p>CMY颜色空间也被叫做减色系统，因为RBG颜色空间随着每个通道值的增加颜色逐渐从黑变为白，而CMY颜色空间的颜色随着每个通道值的增加颜色逐渐从白色变为黑色。</p>
<h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>HSV颜色空间用色调(Hue)，饱和度(Saturation)，明度(Value of Brightness)来分别颜色。</p>
<ul>
<li>色调意味着基础颜色，它是表明不同颜色的主要因素，用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°，蓝色为240°。它们的补色是：黄色为60°，青色为180°，紫色为300°。</li>
<li>饱和度表示颜色的纯度，取值为0～1的浮点数，饱和度越低，颜色越接近白色。</li>
<li>明度表示颜色的明亮程度，亮度越低，颜色越接近黑色。</li>
</ul>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200709202938841.png" alt="image-20200709202938841" style="zoom:33%;"></p>
<p><strong>RGB和CMY颜色模型都是面向硬件的，而HSV颜色模型是面向用户的。</strong></p>
<h2 id="YUV，YCbCr颜色空间"><a href="#YUV，YCbCr颜色空间" class="headerlink" title="YUV，YCbCr颜色空间"></a>YUV，YCbCr颜色空间</h2><p>Y分量表示明亮度(Lumiance或着Luma)，U(Cr)和V(Br)表示色度，人眼一般对亮度信息比较敏感，对颜色信息比较不敏感。</p>
<p>YUV 用在 模拟 PAL or 模拟 NTSC视频格式，不用在数字视频格式</p>
<p>YCbCr 是用于数字视频表示的则是色度(Chrominance或Chroma).</p>
<p>YUV(YCbCr)的颜色空间存储有几种方式：plane、bi-plane、packed，</p>
<p>plane的存储方式为先存储所有的像素中的Y通道的值，然后存储所有像素中的U通道的值，然后是U通道的值(不一定所有像素都有U和V值，这和采样有关，后续再说明)。bi-plane存储方式为先存储所有像素中的Y通道值作为一个plane，然后交替存储像素中的U和V的值作为第二个plane。packed存储方式为交替存储每个像素中的YUV值。</p>
<p>采样率(数字信号才谈采样)，YCbCr颜色空间一般有4:4:4，4:2:2和4:2:0这几种采样方式。4:4:4——每采样一个Y通道，同时采样一个Cb、Cr通道。4:2:2——每采样两个Y，采样一个Cb和Cr，要显示4：2：2的YCbCr数据，首先将其转换为4：4：4的YCbCr数据，使用内插生成缺少的Cb和Cr样本。4:2:0并不意味着只有Cb分量，没有Cr分量。它指的是对于每行扫描线来说，4:2:0——只有一种色度分量以2:1的抽样率存储。相邻的扫描线存储不同的色度分量，也就是说一行是4:2:0的话，下一行就是4:0:2，下一行又是4:2:0，以此类推。要显示4：2：0的YCbCr数据，首先将其转换为4：4：4的YCbCr数据，使用内插生成新的Cb和Cr样本。</p>
<h2 id="CIE-XYZ颜色空间"><a href="#CIE-XYZ颜色空间" class="headerlink" title="CIE XYZ颜色空间"></a>CIE XYZ颜色空间</h2><p>由CIE(International Commission on Illumination)提出，它可以用来表示所有的可见光</p>
<h1 id="图像和像素"><a href="#图像和像素" class="headerlink" title="图像和像素"></a>图像和像素</h1><p>//TODO：虽然知道相关概念，但还是写一下吧。</p>
<h1 id="网格绘制"><a href="#网格绘制" class="headerlink" title="网格绘制"></a>网格绘制</h1><p>在计算机图形中，表示一个3D图形一般使用三角网格或者参数曲线(曲面)。一个三角网格数据结构一般包括一个三角形数组，</p>
<h1 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h1><p>当光照射到物体表面时,物体对光会发生反射、透射、吸收、衍射、折射、和干涉,其中被物体吸收的部分转化为热，反射、透射的光进入人的视觉系统,使我们能看见物体。为模拟这一现象,我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。</p>
<h1 id="局部光照"><a href="#局部光照" class="headerlink" title="局部光照"></a>局部光照</h1><p>在真实感图形学中,仅处理光源直接照射物体表面的光照明模型被称为局部光照明模型。</p>
<h1 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h1><p>全局光照模型是基于光学物理原理的，光照强度的计算依赖于光能在现实世界中的传播情况，考虑光线与整个场景中各物体表面及物体表面间的相互影响，包括多次反射 、透射 、散射等。因此，与局部光照模型相比，全局光照模型需要相当大的计算量 ，但同时也能取得非常逼真的真实效果 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">类与对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-20 17:33:45 / Modified: 17:41:56" itemprop="dateCreated datePublished" datetime="2020-11-20T17:33:45+08:00">2020-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-primer-plus/" itemprop="url" rel="index">
                    <span itemprop="name">c++ primer plus</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的声明只是说明了如何创建一个对象，并没有实际分配内存，只有当有对象被创建的时候才会分配内存。</p>
<h1 id="类内定义的成员函数"><a href="#类内定义的成员函数" class="headerlink" title="类内定义的成员函数"></a>类内定义的成员函数</h1><p>在类的定义声明并实现的成员函数默认为inline函数，不论前面是否加了inline关键字</p>
<h1 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h1><ul>
<li>构造函数和析构函数都没有返回值</li>
</ul>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p><code>当程序创建未被显示初始化的类对象时，总是调用默认构造函数</code></p>
<p>如果没有提供任何构造函数，则编译器将自动提供默认构造函数，这个构造函数不会做任何事。它是默认构造函数的隐式版本。<br><code>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数</code></p>
<p>显示定义默认构造函数的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1:给构造函数所有参数提供默认值</span></span><br><span class="line">MyClass(<span class="keyword">const</span> <span class="built_in">string</span> &amp;co = <span class="string">&quot;&quot;</span>, <span class="keyword">int</span> n = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2:提供一个没有参数的构造函数</span></span><br><span class="line">MyClass();</span><br></pre></td></tr></table></figure><br><code>不要同时采用这两种方法，否则会产生二义性，编译器在需要用到默认构造函数的时候不知道使用哪一个</code></p>
<p><code>隐式地调用默认构造函数的时候，不要使用圆括号</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class;<span class="comment">//隐式调用默认构造函数</span></span><br><span class="line">MyClass my_class = MyClass();<span class="comment">//显示调用默认构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">my_class</span><span class="params">()</span></span>;<span class="comment">//这个变成了一个函数声明</span></span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数的小tips"><a href="#构造函数的小tips" class="headerlink" title="构造函数的小tips"></a>构造函数的小tips</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = MyClass();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，编译器有两种实现方式。第一种：不会创建临时对象，直接将对象赋给my_class；第二种：调用构造函数来创建一个临时对象，然后将该临时对象拷贝到my_class中，并丢弃该临时对象，则这样会为临时对象调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = MyClass();</span><br><span class="line">my_class = MyClass();</span><br></pre></td></tr></table></figure>
<p>对于上述代码的第二个赋值语句，在这样的赋值语句中使用构造函数<code>总会</code>导致在赋值前创建一个临时对象。</p>
<p><code>如果既可以通过初始化，也可以通过赋值来设置对象的值，应采用初始化方式，通常这种方式的效率更高，即可以避免创建临时对象。</code></p>
<p><code>每个类都只能有一个析构函数</code></p>
<h1 id="带const的类成员函数"><a href="#带const的类成员函数" class="headerlink" title="带const的类成员函数"></a>带const的类成员函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass my_class;</span><br><span class="line">my_class.func();<span class="comment">//编译器可能会拒绝执行该方法，因为func方法可能无法保证调用对象不被修改</span></span><br></pre></td></tr></table></figure>
<p>但是如果func()的类方法声明为const类方法就可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//承诺不修改调用对象</span></span><br></pre></td></tr></table></figure><br><code>只要类方法不修改调用对象，就应将其声明为const</code></p>
<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_classes[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>上述声明要求，这个类要么显式的定义了默认构造函数，要么没有定义任何构造函数(即编译器提供了默认构造函数)</p>
<p>可以使用构造函数来初始化数组元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_classes[<span class="number">4</span>] = &#123;</span><br><span class="line">    MyClass();</span><br><span class="line">    MyClass(<span class="string">&quot;&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述代码初始化了对象数组的部分元素，剩余的2个将会使用默认构造函数进行初始化。</p>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。<code>因此，要创建对象数组并有部分数组元素未使用显示构造函数创建时，则这个类必须要有默认构造函数</code></p>
<h1 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">egg</span> &#123;</span>Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">t_shirt</span> &#123;</span>Small, Mediun, Large, Xlarge&#125;;</span><br></pre></td></tr></table></figure>
<p><code>上述代码在两个枚举中定义了同一个枚举变量，会发生冲突，编译器会报错。</code><br>为了避免这种冲突，C++11提供了一种新枚举，其枚举变量的作用域为类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">egg</span> &#123;</span>Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">t_shirt</span> &#123;</span>Small, Mediun, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure><br>可以使用关键字struc代替关键字class，<code>创建作用域内枚举时都需要使用枚举名来限定枚举量</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egg choice = egg::Large;</span><br><span class="line">t_shirt Floyd = t_shirt::Large;</span><br></pre></td></tr></table></figure><br><code>常规的枚举变量可以自动转换为整型，但是作用域内枚举不能隐式地转换为整型。但是必要时可以进行显式类型转换</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = egg::Small;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">int</span>(egg::Small);<span class="comment">//b = 0</span></span><br></pre></td></tr></table></figure><br>作用域内枚举变量可以设置底层数据类型，但是<code>必须为整型数据</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> :</span> <span class="keyword">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;<span class="comment">//指定底层类型为短整型</span></span><br></pre></td></tr></table></figure></p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>要重载运算符，需使用被称为运算符函数的特殊形式。运算符函数的格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>-type <span class="keyword">operator</span> op(argument-<span class="built_in">list</span>);</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">MyClass <span class="keyword">operator</span> +(<span class="keyword">const</span> Myclass &amp;my_class);</span><br></pre></td></tr></table></figure><br>当编译器发现如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = my_class_1 + my_class_2;</span><br></pre></td></tr></table></figure><br>编译器会使相印的运算符函数替换上述运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = my_class_1.<span class="keyword">operator</span>+(my_class_2);</span><br></pre></td></tr></table></figure></p>
<h4 id="运算符重载限制："><a href="#运算符重载限制：" class="headerlink" title="运算符重载限制："></a>运算符重载限制：</h4><p>1、重载后的运算符必须至少有一个操作数是用户定义的类型，这将<code>防止用户为标准类型重载运算符</code><br>2、使用运算符时不能违反运算符原来的句法规则</p>
<p><code>运算符的重载可以通过成员函数或非成员函数进行重载</code>，但下面的运算符只能通过成员函数进行重载：</p>
<ul>
<li>“=” : 赋值运算符</li>
<li>“()”: 函数调用运算符</li>
<li>“[]”: 下标运算符</li>
<li>“-&gt;”: 通过指针访问类成员的运算符</li>
</ul>
<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>友元有三种：</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ul>
<p><code>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限</code></p>
<h3 id="为什么要使用友元？"><a href="#为什么要使用友元？" class="headerlink" title="为什么要使用友元？"></a>为什么要使用友元？</h3><p>对于如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设类A实现了A operator +(int value);</span></span><br><span class="line">A b = a + <span class="number">3</span>;<span class="comment">//转换成a.operator+(3);</span></span><br><span class="line">A b = <span class="number">3</span> + a;<span class="comment">//因为3不是A类对象，编译器无法使用成员函数来替换该表达式</span></span><br></pre></td></tr></table></figure><br>使用友元函数可以解决这个问题</p>
<h3 id="创建友元函数"><a href="#创建友元函数" class="headerlink" title="创建友元函数"></a>创建友元函数</h3><p>创建友元函数的第一步是将其<code>原型放在类声明中</code>，并在原型声明前加上关键字friend</p>
<p>第二步编写函数定义，因为友元函数不是成员函数，所以<code>不要使用&quot;::&quot;限定符，且在定义中不要使用关键字friend</code></p>
<p>所以对于上面的这个问题，只需要实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">int</span> value, <span class="keyword">const</span> A &amp;a)</span><br></pre></td></tr></table></figure><br><code>注意：只有类声明可以决定哪一个函数是友元</code></p>
<h3 id="重载”-lt-lt-”运算符"><a href="#重载”-lt-lt-”运算符" class="headerlink" title="重载”&lt;&lt;”运算符"></a>重载”&lt;&lt;”运算符</h3><p>直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种重载方式</span></span><br><span class="line"><span class="keyword">void</span> opeartor&lt;&lt;(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种重载方式</span></span><br><span class="line"><span class="keyword">void</span> opeartor&lt;&lt;(ostream &amp;os) &#123;</span><br><span class="line">    os &lt;&lt; <span class="keyword">this</span>-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种重载方式</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">    os &lt;&lt; a.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这是定义同时也是实现，单独实现的时候不加friend</span></span><br></pre></td></tr></table></figure><br>对于上述代码1，你觉得可以这样使用吗？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;</span><br></pre></td></tr></table></figure><br>答案是不可以</p>
<p>对于上述代码2，调用的格式因该是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a &lt;&lt; <span class="built_in">cout</span>;</span><br></pre></td></tr></table></figure><br>很别扭是吧</p>
<p>第三种方式可以实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; a.data</span><br></pre></td></tr></table></figure><br>但是第三种方式有种缺憾，就是不可以这样调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a.data is&quot;</span> &lt;&lt; a.data &lt;&lt; <span class="string">&quot;and b.data is&quot;</span> &lt;&lt; b.data;</span><br></pre></td></tr></table></figure><br>解决方法——让第三种方式返回ostream对象的引用即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(osteam &amp;os, <span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">    os &lt;&lt; a.data;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="重载单操作数运算符"><a href="#重载单操作数运算符" class="headerlink" title="重载单操作数运算符"></a>重载单操作数运算符</h3><p>对于某些运算符既可以作单数运算符，又可以作为双操作数运算符。例如“-”既可以作为自反运算符，又可以作为减号操作符。<br>那么重载这种运算符的时候，作为单操作数运算符是不同于双操作运算符的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为成员函数的情况</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>-();<span class="comment">//用作单操作运算符</span></span><br><span class="line">return_type <span class="keyword">operator</span>-(parameter);<span class="comment">//用作双操作运算符</span></span><br></pre></td></tr></table></figure><br>有了上述成员函数的情况，作为非成员函数的情况就可以类推出来了</p>
<h4 id="重载-和—运算符"><a href="#重载-和—运算符" class="headerlink" title="重载++和—运算符"></a>重载++和—运算符</h4><p>++运算符和—运算符既可以做前缀可以做后缀，重载前缀++(—)和后缀++(—)的情况是不同的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>++();<span class="comment">//前缀++</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后缀++</span></span><br></pre></td></tr></table></figure><br><code>C++规定后缀形式有一个int类型的参数，但是这个参数永远不会用到，所以不必写参数名，也不要写这个参数名。</code></p>
<h3 id="运算符重载：作为成员函数还是非成员函数？"><a href="#运算符重载：作为成员函数还是非成员函数？" class="headerlink" title="运算符重载：作为成员函数还是非成员函数？"></a>运算符重载：作为成员函数还是非成员函数？</h3><p>前面说过运算符的重载可以通过成员函数或非成员函数进行重载，但是不能同时声明这两种格式，否则将造成二义性错误，导致编译错误。</p>
<p>对于某些运算符来说，成员函数是唯一合法的选择，例如前面说的”=”(赋值运算符)。有时，根据类设计，使用非成员函数版本可能更好（尤其是为类定义类型转换时）。其他情况下，这两种格式没有太大区别。</p>
<h3 id="可以对运算符重载再进行重载"><a href="#可以对运算符重载再进行重载" class="headerlink" title="可以对运算符重载再进行重载"></a>可以对运算符重载再进行重载</h3><p>例如对于”-“运算符，它既可以表示减法，也可以表示自反，那么就可以实现两种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以向量为例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    Vector(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector &amp;v) &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(x - v.x, y - v.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vecotor <span class="keyword">operator</span>-()&#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h1><p>在c++中，如果一个类有接受一个参数的构造函数，则c++支持将与该参数相同类型的值转换为类。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    A(<span class="keyword">int</span> data) : data(data) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>程序将使用构造函数A(10)来创建一个临时对象，并将19.6作为初始化值，然后将该临时对象复制到a中。这一过程称为隐式转换。</p>
<p>c++中新增了关键字explicit用于关闭这种自动特性<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> data)</span> : <span class="title">data</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="number">10</span>;<span class="comment">//报错，不能再隐式转换</span></span><br><span class="line">A a = (A) <span class="number">10</span>;<span class="comment">//仍然可以使用显示转换</span></span><br></pre></td></tr></table></figure><br><code>explicit关键字只有用来修饰单参数的构造函数才有意义</code></p>
<p><code>建议不要使用隐式转换，最好将单参数的构造函数都加上explicit关键字，使用强制类型转换</code></p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>上面的例子是将整型转换成A类型，同时转换函数可以让A类型转换成整型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> data)</span> : <span class="title">data</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">//b = 10</span></span><br></pre></td></tr></table></figure><br><code>声明转换函数注意以下几点</code>：</p>
<ul>
<li>转换函数必须是类方法</li>
<li>转换函数不能指定返回类型</li>
<li>转换函数不能有参数</li>
</ul>
<p>同时c++11及之后可以将explicit关键字用于转换函数，这样就只能进行强制类型转换而不能进行隐式类型转换</p>
<p><code>使用转换函数的原则</code>：<br>谨慎使用转换函数，最好使用功能相同的非转换函数，例如上例中完全可以实现一个int to_int();的成员方法来实现相同的功能。</p>
<h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><h4 id="static成员变量的声明及初始化"><a href="#static成员变量的声明及初始化" class="headerlink" title="static成员变量的声明及初始化"></a>static成员变量的声明及初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static成员变量初始化</span></span><br><span class="line"><span class="keyword">double</span> MyClass::d = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<p>一般不能在类声明中初始化静态成员变量，这是因为类声明只描述了如何分配内存，但不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句指出了类型，并使用了作用域运算符，<code>但没有使用关键字static</code>。</p>
<p><code>但是如果静态成员是const整型或const枚举型，则可以在类声明中初始化。</code></p>
<h4 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h4><ul>
<li>不能通过对象调用static成员函数，对于声明在共有部分的static成员函数，可以使用类名和作用域解析运算符来调用它。</li>
<li><code>static成员函数中不能使用this指针</code></li>
<li>static成员函数只能访问static成员变量</li>
</ul>
<h4 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h4><p>c++自动提供了下面这些成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数</li>
<li>默认析构函数，如果没有定义</li>
<li>复制(拷贝)构造函数，如果没有定义</li>
<li>赋值运算符(“=”)，如果没有定义</li>
<li>地址运算符(“&amp;”)，如果没有定义</li>
</ul>
<h5 id="复制-拷贝-构造函数"><a href="#复制-拷贝-构造函数" class="headerlink" title="复制(拷贝)构造函数"></a>复制(拷贝)构造函数</h5><p>复制构造函数用于将一个对象复制到新创建的对象中，也就是说，它用于初始化过程中。复制构造函数的原型通常如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;);</span><br></pre></td></tr></table></figure><br><code>调用复制构造函数的时机：</code></p>
<ul>
<li><code>新建一个对象并</code>将其初始化为同类对象时，复制(拷贝)构造函数都将被调用。</li>
<li>当函数按值传递对象或函数返回对象时(<code>返回引用则不会调用</code>)，都将使用复制(拷贝)构造函数</li>
</ul>
<p>默认的复制(拷贝)构造函数逐个复制非静态成员的值（即<code>浅拷贝</code>）</p>
<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>将已有对象赋值给另一个对象时，将使用重载的赋值运算符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class_1;</span><br><span class="line">MyClass my_class_2 = my_class_1;<span class="comment">//使用复制(拷贝)构造函数，可能使用赋值运算符——可能先使用复制(拷贝)构造函数创建一个临时对象，然后使用赋值构造函数将这个临时对象赋值给my_class_2</span></span><br><span class="line">MyClass my_class_3;</span><br><span class="line">my_class_3 = my_class_1;<span class="comment">//使用赋值运算符</span></span><br></pre></td></tr></table></figure><br>同默认的复制(拷贝)构造函数一样，<code>默认的赋值运算函数也对成员进行逐个复制（浅拷贝）</code></p>
<p><code>编写赋值运算符函数的规范：</code></p>
<ul>
<li>由于目标对象可能引用了以前分配的数据，所以函数应使用delete或delete[]来释放这些数据</li>
<li>函数应当避免将对象赋给自身，首先这样做没有太大意义，并且，给对象重新赋值前，释放内存操作可能删除对象的内容(详见示例代码)</li>
<li>函数最后返回一个指向调用对象的引用，这是为了能够连续赋值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyClass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass &amp; my_class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;my_class) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放动态内存，如果有的话</span></span><br><span class="line">    <span class="comment">//如果没有上面的判断且this == &amp;my_class的话，那么 delete p也会将my_class中的p delete掉，那么下面的内存拷贝就会出错</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    data = my_class.data;</span><br><span class="line">    p = <span class="keyword">new</span> ...;<span class="comment">//重新分配动态内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用拷贝构造函数还是赋值运算符函数？"><a href="#调用拷贝构造函数还是赋值运算符函数？" class="headerlink" title="调用拷贝构造函数还是赋值运算符函数？"></a>调用拷贝构造函数还是赋值运算符函数？</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">my1</span><span class="params">(my2)</span></span>;<span class="comment">//只调用拷贝构造函数</span></span><br><span class="line">MyClass my1 = my2;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">MyClass my1;</span><br><span class="line">my1 = my2;<span class="comment">//调用赋值运算符函数</span></span><br></pre></td></tr></table></figure>
一般有新对象被创建时就会调用一个构造函数，可能就是拷贝构造函数</li>
</ul>
<h3 id="重载-运算符的一个技巧"><a href="#重载-运算符的一个技巧" class="headerlink" title="重载[]运算符的一个技巧"></a>重载[]运算符的一个技巧</h3><p>重载运算符最好能够返回引用，因为这样不仅能够使用”[index]”获取值，而且可以方便的为”[index]”处对应的值进行赋值。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i) <span class="keyword">const</span>;<span class="comment">//const成员函数返回一定是const char &amp;</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">char</span> c = str[<span class="number">1</span>];</span><br><span class="line">str[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//如果返回不是引用那么修改的就只是一个临时对象而已</span></span><br></pre></td></tr></table></figure><br>使用const版本的operator[]实现非const版本的operator[]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> MyClass&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第一次cast将<em>this转换成const MyClass&amp;类型，即为</em>this添加const，第二次则从const operator[]的返回值中移除const。<br><code>只能用const版本来实现非const版本，注意不要用非const版本来实现const版本。</code>是否需要const版本来实现非const版本取决于你自己。</p>
<h3 id="包含类成员的类的逐成员复制"><a href="#包含类成员的类的逐成员复制" class="headerlink" title="包含类成员的类的逐成员复制"></a>包含类成员的类的逐成员复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBigClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MySmallClass1 my_small_class1;</span><br><span class="line">MySmallClass2 my_small_class2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于MyBigClass而言，<code>默认的逐成员复制和赋值行为有一定的智能，逐成员复制或赋值将使用成员类型定义的复制(拷贝)构造函数和赋值运算符</code>。然而，如果MyBigClass有需要定义复制(拷贝)构造函数和赋值运算符函数，则最好重新为MyBigClass编写复制(拷贝)构造函数和赋值运算符函数。</p>
<h3 id="需要重新编写复制-拷贝-构造函数和赋值运算符函数的一种情况"><a href="#需要重新编写复制-拷贝-构造函数和赋值运算符函数的一种情况" class="headerlink" title="需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况"></a>需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况</h3><p>如果一个类的成员是需要动态内存分配的，那么这个类一般是在构造函数中动态申请内存，而在析构函数中一般会释放该动态内存。</p>
<p>因为默认复制(拷贝)构造函数和赋值运算符函数是浅拷贝，所以浅拷贝复制的只是指向动态内存的指针的值，当其中一个对象被释放掉了，其析构函数释放掉动态内存，那个另外一个对象也将不再拥有该动态分配的内存。</p>
<p>这时就应该为该类重新编写复制(拷贝)构造函数和赋值运算符函数，让其进行深拷贝，即重新申请内存，而不是简单的指针赋值。</p>
<h3 id="对于使用定位new运算符分配的动态对象"><a href="#对于使用定位new运算符分配的动态对象" class="headerlink" title="对于使用定位new运算符分配的动态对象"></a>对于使用定位new运算符分配的动态对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">MyClass *p1 = <span class="keyword">new</span> (buffer) MyClass;</span><br></pre></td></tr></table></figure>
<p>由于对于定位new运算符不能使用delete，所以，<code>对使用定义new运算符创建的对象，要显式的调用函数的析构函数</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1-&gt;~MyClass();</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure></p>
<h1 id="嵌套结构和类"><a href="#嵌套结构和类" class="headerlink" title="嵌套结构和类"></a>嵌套结构和类</h1><p>在类声明的结构、类或枚举被称为是嵌套在类中的，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是类的私有部分进行的，则只能在这个类使用被声明的类型，如果声明是在共有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类。</p>
<h1 id="成员初始化列表的语法"><a href="#成员初始化列表的语法" class="headerlink" title="成员初始化列表的语法"></a>成员初始化列表的语法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b) : mem1(a), mem2(b), mem3(a * b + <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员初始化列表格式只能用于构造函数</li>
<li><code>必须使用这个格式来初始化非静态const数据成员，即单const修饰的成员</code></li>
<li><code>必须用这种格式来初始化引用数据成员</code>（一般很少有引用数据成员，因为这种设计很不好）</li>
<li><code>当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序</code>。如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要了。</li>
</ul>
<p>成员初始化列表会覆盖类内初始化的成员的初始值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//类内初始化</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass() : a(<span class="number">10</span>)<span class="comment">//将会覆盖掉a，a=10</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="子类的初始化"><a href="#子类的初始化" class="headerlink" title="子类的初始化"></a>子类的初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BaseClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b) : a(a), b(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SubClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> c): BaseClass(a, b), c(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类的构造函数必须使用<code>相邻基类</code>的构造函数，<code>且只能使用成员初始化列表的方式</code>，创建派生类对象时，程序首先创建基类对象。如果不显示的调用基类的构造函数，程序将使用默认的基类构造函数(如果有的话，否则将会报错)</p>
<p>派生类对象过期时，程序将先调用派生类的析构函数，然后再调用基类析构函数</p>
<h3 id="在派生类成员函数中调用父类的方法"><a href="#在派生类成员函数中调用父类的方法" class="headerlink" title="在派生类成员函数中调用父类的方法"></a>在派生类成员函数中调用父类的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BaseClass::func();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在派生类成员函数中调用父类定义的方法是使用作用域解析运算符来调用的。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h3><p>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的条件下引用派生类对象，也可以将派生对象赋给基类对象（向上强制转换）。但是不可以将基类对象赋给派生类对象和派生类引用，不可以把基类对象地址赋给派生类对象指针（向下强制转换）</p>
<h3 id="虚函数-virtual-function-与多态实现"><a href="#虚函数-virtual-function-与多态实现" class="headerlink" title="虚函数(virtual function)与多态实现"></a>虚函数(virtual function)与多态实现</h3><p>如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用virtual，程序将根据引用或指针指向的具体对象的类型来选择方法<br>不使用virtual：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseClass base;</span><br><span class="line">SubClass sub;</span><br><span class="line">BaseClass *b1 = &amp;base;</span><br><span class="line">BaseClass *b2 = &amp;sub;</span><br><span class="line">b1-&gt;func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b2-&gt;func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">BaseClass &amp;b3 = base;</span><br><span class="line">BaseClass &amp;b4 = sub;</span><br><span class="line">b3.func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b4.func(); <span class="comment">// 使用 BaseClass::func()</span></span><br></pre></td></tr></table></figure><br>使用virtual关键字：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;<span class="comment">//只能对virtual方法标记override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseClass base;</span><br><span class="line">SubClass sub;</span><br><span class="line">BaseClass *b1 = &amp;base;</span><br><span class="line">BaseClass *b2 = &amp;sub;</span><br><span class="line">b1-&gt;func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b2-&gt;func(); <span class="comment">// 使用 SubClass::func()</span></span><br><span class="line">BaseClass &amp;b3 = base;</span><br><span class="line">BaseClass &amp;b4 = sub;</span><br><span class="line">b3.func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b4.func(); <span class="comment">// 使用 SubClass::func()</span></span><br></pre></td></tr></table></figure><br>经常在基类中将派生类会重新定义的方法声明为虚方法，方法在基类中被声明为虚方法后，它在<code>所有派生类中</code>将<code>自动成为</code>虚方法。但是最好在派生类声明中使用virtual来指出哪些函数是虚函数，这可以增加程序的可读性</p>
<p><code>virtual关键字只用于类声明的方法原型中，而不用于方法实现中</code></p>
<h4 id="总结实现多态的方法"><a href="#总结实现多态的方法" class="headerlink" title="总结实现多态的方法"></a>总结实现多态的方法</h4><ul>
<li><code>公有继承</code>，因为只有公有继承是才允许将基类指针或基类引用指向派生类</li>
<li>成员函数要用virtual修饰</li>
<li>使用对象的引用或指针</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~BaseClass() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~SubClass() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseClass *p1 = <span class="keyword">new</span> BaseClass();</span><br><span class="line">BaseClass *p2 = <span class="keyword">new</span> SubClass();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，如果析构函数不是虚函数，当delete p2时，将只会调用基类的虚构函数。如果是虚析构函数，则当delete p2时，将会调用SubClass的析构函数。</p>
<p><code>所以，一般将类的析构函数定义为虚函数</code></p>
<h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。在程序运行时选择正确的函数代码块，被称为动态联编（dynamic binding），又称为晚期联编（late dinding）</p>
<p>为什么有两种类型的联编？：<br>由于动态联编需要采用一些方法来追踪基类指针或引用指向的对象类型，这增加了额外的开销，所以静态联编的效率比动态联编的效率高，因此<code>静态联编也被设置为c++的默认选择</code>。</p>
<h4 id="虚成员函数与动态联编"><a href="#虚成员函数与动态联编" class="headerlink" title="虚成员函数与动态联编"></a>虚成员函数与动态联编</h4><p>编译器会对非虚方法使用静态联编，对虚方法使用动态联编。但是由于动态联编需要额外开销，所以<code>对不需要重新定义的成员函数，不要将这些函数设置为虚函数</code>，这样有两种好处：首先效率更高；<code>其次，指出不要重新定义该函数</code>。仅将那些需要被重新定义的方法声明为虚的</p>
<h3 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a><code>虚函数的工作原理</code></h3><p>编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这个指针一般会成为对象的第一个数据成员。这个数组被称为<code>虚函数表</code>。虚函数表中存储了为类对象进行声明的虚函数的地址。无论类中包含的虚函数还是1个还是10个，都只需要在对象中添加一个地址成员，只是表的大小不同而已。<code>使用虚函数表也就是为了不增大类所占的内存，并加快函数查找速度</code><br><img src="/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/虚函数机制.jpg" alt="虚函数机制" style="zoom:25%;"></p>
<p>对于上图，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个<code>指向独立地址</code>的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，虚函数表将<code>保存函数原始版本的地址</code>。如果派生类定义了新的虚函数，则该函数的地址也将被添加到虚函数表中。</p>
<p>如果使用类声明中定义的第一个虚函数，则程序将使用数组 中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</p>
<h3 id="虚表指针初始化的时机"><a href="#虚表指针初始化的时机" class="headerlink" title="虚表指针初始化的时机"></a><code>虚表指针初始化的时机</code></h3><p>序表指针的初始化在进入类构造函数之前，<br>一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SubClass&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass s;</span><br></pre></td></tr></table></figure><br>最后打印的结构为“Base”，因为在进入s的构造函数之前，会先进行Base的构造，而在进入Base的构造函数之前，虚表指针被初始化为指向Base的虚函数表，所以这是执行虚函数调用的是父类的虚函数。当父类被构造完，进入自己的构造函数之前，虚表指针再被初始化为指向自己的虚函数表</p>
<h3 id="关于虚函数的注意事项"><a href="#关于虚函数的注意事项" class="headerlink" title="关于虚函数的注意事项"></a>关于虚函数的注意事项</h3><ul>
<li><code>构造函数不能是虚函数</code>，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。</li>
<li><code>析构函数最好设计成虚函数</code>，除非类不用做基类。也就是说即使基类不需要显示析构函数提供服务，也不应该依赖于默认析构函数，而应该提供析构函数，</li>
<li><code>友元不能是虚函数</code>，因为友元不是类成员，<code>而只有成员才能是虚函数。</code></li>
</ul>
<h1 id="在派生类中重新定义方法将隐藏方法"><a href="#在派生类中重新定义方法将隐藏方法" class="headerlink" title="在派生类中重新定义方法将隐藏方法"></a>在派生类中重新定义方法将隐藏方法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span> :</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不在继承类中重新定义showperks方法，则继承类中可以使用基类所有的showperks方法。但是重新定义将showperks()定义为一个不接受任何参数的函数。<code>重新定义不会生成函数的两个重载版本</code>，而是隐藏了接收一个int参数的基类版本。总之，<code>重新定义继承的方法并不是重载</code>。</p>
<p><code>这引出了两条经验准则</code>：<br>第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类应用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Dwelling &amp; <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span>:</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Hovel &amp; <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>注意这种例外只适用于返回值，而不适用于参数</code></p>
<p>第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本，或者使用<code>继承方法函数</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法1：重新定义所有的基类版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span>:</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法2：使用继承方法函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span>:</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Dwelling::showperks;<span class="comment">//can use all showperks now</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;<span class="comment">//还可以定义自己的showperks(double x)，而不使用基类的showperks(double x)。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span> <span class="keyword">const</span></span>;<span class="comment">//还可以定义其他的showperks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>如果派生类中只定义一个版本，则另外两个版本将被隐藏，派生对象将无法使用它们。如果不需要需要修改，则新定义可只调用基类版本</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hovel::showperks</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Dwelling::showperks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="当typedef出现在类定义的私有部分"><a href="#当typedef出现在类定义的私有部分" class="headerlink" title="当typedef出现在类定义的私有部分"></a>当typedef出现在类定义的私有部分</h1><p>则只有在类中使用，在类外和子类中不能使用</p>
<h1 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h1><p>使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，基类的私有成员子类无法访问。使用私有继承时，只能在派生类中访问基类的非私有成员及成员函数。</p>
<p><code>使用私有继承，不支持隐式向上转换(隐式向上转换：无需进行显示类型转换，就可以将基类指针或引用指向派生类对象)</code></p>
<h1 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h1><p>基类的公有成员和保护成员都将成为派生类的保护成员</p>
<h1 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h1><p>使用保护继承或私有继承时， 基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，方法之一是定义一个使用基类方法的派生类方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pri_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> protect BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pri_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一种方法是使用一个using声明，来指出派生类可以使用特定的基类成员，即使采用的是私有派生<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> <span class="keyword">private</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> BaseClass::pri_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>注意using声明只使用成员名——没有圆括号、函数特征标和返回类型。且using声明只适用于继承，而不适用于包含</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/19/others/pytest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/others/pytest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">pytest学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-19 14:55:29" itemprop="dateCreated datePublished" datetime="2020-11-19T14:55:29+08:00">2020-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-26 15:07:30" itemprop="dateModified" datetime="2021-01-26T15:07:30+08:00">2021-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pytest/" itemprop="url" rel="index">
                    <span itemprop="name">pytest</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装pytest时，直接使用pip安装就可以了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure>
<h1 id="pytest辨认测试文件和测试函数"><a href="#pytest辨认测试文件和测试函数" class="headerlink" title="pytest辨认测试文件和测试函数"></a>pytest辨认测试文件和测试函数</h1><p>如果运行pytest没有指定文件的话，pytest会将所有形式为”test_*.py”或者”*_test.py”的文件运行。</p>
<p>另外，pytest要求测试函数必须以”test”开头，并且不能通过其他方式在代码中显示指定哪些函数是需要被pytest测试的测试函数。</p>
<h1 id="第一个测试程序"><a href="#第一个测试程序" class="headerlink" title="第一个测试程序"></a>第一个测试程序</h1><p>在项目目录下新建一个叫做”test_first.py”的文件，文件的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sqrt</span>():</span></span><br><span class="line">    num = <span class="number">25</span></span><br><span class="line">    <span class="keyword">assert</span> math.sqrt(num) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testsqure</span>():</span></span><br><span class="line">    num = <span class="number">7</span></span><br><span class="line">    <span class="keyword">assert</span> num * num == <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tesequlity</span>():</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">10</span> == <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>之后，<strong>在命令行中</strong>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>
<p>之后pytest就会开始运行单元测试，并产生测试报告。注意到，第三个函数不是以test开头的函数，所以pytest将不会对第三个函数进行测试。</p>
<p>使用”-v”（verbose）参数可以打印更多的信息。</p>
<h1 id="pytest选择执行文件"><a href="#pytest选择执行文件" class="headerlink" title="pytest选择执行文件"></a>pytest选择执行文件</h1><p>在上例的基础上，再创建一个名叫”test_second.py”的文件，文件的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_greater</span>():</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   <span class="keyword">assert</span> num &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_greater_equal</span>():</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   <span class="keyword">assert</span> num &gt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_less</span>():</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   <span class="keyword">assert</span> num &lt; <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>此时，如果执行执行”pytest”命令，pytest将对test_first.py和test_second.py中的函数都进行测试。</p>
<p>如果只想对”test_scond.py”文件进行测试，可以执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_second.py</span><br></pre></td></tr></table></figure>
<h1 id="指定测试函数搜索名称"><a href="#指定测试函数搜索名称" class="headerlink" title="指定测试函数搜索名称"></a>指定测试函数搜索名称</h1><p>在pytest命令中，可以使用”-k”参数指定关键字过滤，pytest只会测试那些含有关键字的函数。<font color="red">注意，即使指定了关键字，仍然要求函数以test开头</font>，否则即使有关键字也不会对该函数进行测试。例如在文件中有函数的名称为”keyword”，即使使用命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -k keyword</span><br></pre></td></tr></table></figure>
<p>pytest也不会对”keyword”这个函数进行测试。</p>
<h1 id="将测试函数分组"><a href="#将测试函数分组" class="headerlink" title="将测试函数分组"></a>将测试函数分组</h1><p>pytest运行用户对测试函数使用”marker”，”marker”可以给测试函数添加多种特性，mark本质上是一个函数装饰器。pytest自身提供了一些内建的”marker”，另外用户也可以自定义”marker”。marker在代码中的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.mark.&lt;markname&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_xxxx</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在测试时，可以对pytest命令添加”-m”参数来指定marker，pytest将只会运行有相同marker标记的测试函数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -m &lt;markname&gt;</span><br></pre></td></tr></table></figure>
<font color="red">注意函数名仍然需要以test起始。</font>



<h1 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h1><p>Fixture是一个自定义的函数，这个函数在每个测试函数被执行前，都会执行一遍这个fixture函数。fixture函数通常可以用来给测试函数提供数据源，例如从数据库获取数据等。</p>
<p>声明一个Fixture函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_value</span>():</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>使用Fixture函数：在测试函数中使用fixture函数，需要将fixture函数的函数名作为输入参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_input</span>(<span class="params">input_value</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> input_value % <span class="number">3</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="conftest-py"><a href="#conftest-py" class="headerlink" title="conftest.py"></a>conftest.py</h1><p>conftest.py在使用了pytest的项目中是一个特殊的文件，我们可以在这个文件中定义fixture函数，而在其他所有测试函数中使用定义的fixture函数，并且不必在代码中显示地import这个文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#in conftest.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_value</span>():</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#in other test file</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_input</span>(<span class="params">input_value</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> input_value % <span class="number">3</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="Parameterizing-Tests"><a href="#Parameterizing-Tests" class="headerlink" title="Parameterizing Tests"></a>Parameterizing Tests</h1><p>Parameterizing Tests可以给测试函数指定多个输入参数的值，直接看例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;num&quot;</span>, <span class="string">&quot;output&quot;</span>, [(<span class="params"><span class="number">1</span>, <span class="number">11</span></span>), (<span class="params"><span class="number">2</span>, <span class="number">22</span></span>), (<span class="params"><span class="number">3</span>,<span class="number">35</span></span>), (<span class="params"><span class="number">4</span>, <span class="number">44</span></span>)]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_multiplication_11</span>(<span class="params">num, output</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> num * <span class="number">11</span> == output</span><br></pre></td></tr></table></figure>
<h1 id="Xfail-Skip-Tests"><a href="#Xfail-Skip-Tests" class="headerlink" title="Xfail/Skip Tests"></a>Xfail/Skip Tests</h1><p>使用xfail “marker”标记的测试函数，会被pytest执行，但是不会进入pytest的统计，即使测试函数失败了也不会被打印出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.mark.xfail</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_something</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>使用skip “marker”标记的测试函数，不会被pytest执行。</p>
<h1 id="指定N个测试失败后结束测试"><a href="#指定N个测试失败后结束测试" class="headerlink" title="指定N个测试失败后结束测试"></a>指定N个测试失败后结束测试</h1><p>可以在pytest命令中使用”—maxfail”参数来指定测试多少个函数失败后就停止测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --maxfail=3</span><br></pre></td></tr></table></figure>
<p>一般在测试用例较多，测试时间较长时使用。</p>
<h1 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h1><p>默认情况下，pytest是串行运行测试函数的，当测试函数数量较多时，可能需要并行运行测试函数。要并行运行测试函数，需要下载pytest-xdist插件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-xdist</span><br></pre></td></tr></table></figure>
<p>现在可以使用 pytest -n \<num\>来指定并行度</num\></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -n 3</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/11/hight_performance_linux_coding/IO%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/hight_performance_linux_coding/IO%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">IO复用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-11 10:07:54" itemprop="dateCreated datePublished" datetime="2020-11-11T10:07:54+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 12:58:58" itemprop="dateModified" datetime="2021-02-09T12:58:58+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Select系统调用"><a href="#Select系统调用" class="headerlink" title="Select系统调用"></a>Select系统调用</h1><p>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p>
<p>select系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>nfds参数指定被监听的文件描述符的总数。<font color="red">它通常被设置为select监听的所有文件描述符中的最大值加1</font>因为文件描述符是从0开始计数的。</li>
<li>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。应用程序调用select函数时，通过这三个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。fd_set结构体仅包含一个整型数组，该数组的<font color="red">每个</font>元素的<font color="red">每一位bit</font>标记一个文件描述符。</li>
<li>timeout参数用来设置select函数的超时时间。它是一个timeval结构类型的指针，<font color="red">采用指针参数是因为内核将修改它以告诉应用程序select等待了多久</font>。不过我们不能完全信任select调用返回后的timeout值，比如调用失败时timeout值是不确定的。<font color="red">如果给timeout参数传递NULL，则select将一直阻塞，直到某个文件描述符就绪</font>。</li>
</ul>
<p>select成功时返回就绪(可读、可写和异常)文件描述符的总数。如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno为EINTR。</p>
<p>如果觉得自己手动使用位操作去处理fd_set，可以使用下面的一系列宏和函数来访问fd_set结构体中的位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line">FD_ZERO(fd_set *fdset);	<span class="comment">/*清零fdset的所有位*/</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *fdset);	<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *fdset);	<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure>
<h2 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h2><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。在网络编程中，下列情况可认为socket可读：</p>
<ul>
<li>socket内核接受缓冲区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</li>
<li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li>
<li>监听scoket上有新的连接请求。</li>
<li>socket上有未处理的错误，此时我们可以使用getsockopt来读取和清除错误。</li>
</ul>
<p>下列情况下socket可写：</p>
<ul>
<li>socket内核发送缓存区中的可用字节数小于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</li>
<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li>
<li>socket上有未处理的错误。此时我们可以使用getsocketopt来读取和清除该错误。</li>
</ul>
<p>网络程序中，select能处理的异常情况只有一种：socket上接受到带外数据。</p>
<p>下面是使用select函数处理socket带外数据的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in sockAddress&#123;&#125;;</span><br><span class="line">    sockAddress.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;sockAddress.sin_addr);</span><br><span class="line">    sockAddress.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockFD = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;create socket fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sockFD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockFD, (sockaddr *)&amp;sockAddress, <span class="keyword">sizeof</span>(sockAddress));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket bind fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = listen(sockFD, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket listen fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sockaddr_in clientSock&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientSockLen;</span><br><span class="line">    <span class="keyword">int</span> clientSockFD = accept(sockFD, (sockaddr *)&amp;clientSock, &amp;clientSockLen);</span><br><span class="line">    <span class="keyword">if</span> (clientSockFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket accept fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> clientSockFD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    fd_set  read_fds;</span><br><span class="line">    fd_set exception_fds;</span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">/*每次调用select 前都要重新在read_fds和exception_fds中设置文件描述符clientSockFD，因为事件发生之后，文件描述符集合将被内核修改*/</span></span><br><span class="line">        FD_SET(clientSockFD, &amp;read_fds);</span><br><span class="line">        FD_SET(clientSockFD, &amp;exception_fds);</span><br><span class="line">        ret = select(clientSockFD + <span class="number">1</span>, &amp;read_fds, <span class="literal">nullptr</span>, &amp;exception_fds, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;select fail &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*对于可读事件，采用普通的recv函数读取数据*/</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(clientSockFD, &amp;read_fds)) &#123;</span><br><span class="line">            ret = recv(clientSockFD, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot; bytes of normal data: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(clientSockFD, &amp;exception_fds)) &#123;</span><br><span class="line">            <span class="comment">/*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/</span></span><br><span class="line">            ret = recv(clientSockFD, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot; bytes of oob data: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(clientSockFD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="poll-系统调用"><a href="#poll-系统调用" class="headerlink" title="poll 系统调用"></a>poll 系统调用</h1><p>poll系统调用和select类似，也是在指定时间内轮训一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。</li>
<li>nfds指定被监听事件的fds的数量。它本质是一个整数。</li>
<li>timeout参数指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</li>
</ul>
<p>poll调用的返回值的含义与select相同。</p>
<p>poll函数的第一个参数使用的pollfd结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;					<span class="comment">/*文件描述符*/</span></span><br><span class="line">  <span class="keyword">short</span> events;		<span class="comment">/*注册的事件*/</span></span><br><span class="line">  <span class="keyword">short</span> revents;	<span class="comment">/*实际发生的事件，由内核补充*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fd指定文件描述符</li>
<li>events告诉poll监听fd上的那些事件，他是一系列事件的<font color="red">按位或</font></li>
<li>revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件</li>
</ul>
<p>poll 支持的事件类型如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">是否可作为输入</th>
<th style="text-align:center">是否可作为输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POLLIN</td>
<td style="text-align:center">数据可读（包括普通数据和优先数据）</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLRDNORM</td>
<td style="text-align:center">普通数据可读</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLRDBAND</td>
<td style="text-align:center">优先级带数据可读（Linux不支持）</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLPRI</td>
<td style="text-align:center">高优先级数据可读，比如TCP带外数据</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLOUT</td>
<td style="text-align:center">数据（包括普通数据和优先数据）可写</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLWRNORM</td>
<td style="text-align:center">普通数据可写</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLWRBAND</td>
<td style="text-align:center">优先级带数据可写</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLRDHUP</td>
<td style="text-align:center">TCP连接被对方关闭，或者对方关闭了写操作，它由GNU引入</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLERR</td>
<td style="text-align:center">错误</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLHUP</td>
<td style="text-align:center">挂起。比如管道的写端被关闭后，读端描述符上将收到POLLHUP事件</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLNVAL</td>
<td style="text-align:center">文件描述符没有打开</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
</div>
<h1 id="epoll系统调用"><a href="#epoll系统调用" class="headerlink" title="epoll系统调用"></a>epoll系统调用</h1><h2 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h2><font color="red">epoll是Linux特有的I/O复用函数。</font>它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中。从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。<font color="red">但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用epoll_create函数来创建：</font>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>size<font color="red">参数现在并不起作用</font>，只是给内核一个提示。告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指要访问的内核事件表。</li>
</ul>
<p>下面的函数可以用来操作epoll的内核事件表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>epfd为epoll_create返回的事件表文件描述符</li>
<li>fd为要操作的文件描述符</li>
<li>op指定操作类型，操作类型有如下3种<ul>
<li>EPOLL_CTL_ADD 往事件表中注册fd上的事件</li>
<li>EPOLL_CTL_MOD 修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL 删除fd上对的注册事件</li>
</ul>
</li>
<li>event 参数指定事件，它是epoll_event结构体指针类型。</li>
</ul>
<p>epoll_event结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;	<span class="comment">/* epoll事件 */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;	<span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>event 成员描述事件类型。epoll支持的事件类型和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上”E”。但epoll有<font color="red">两个额外的</font>事件类型——EPOLLET和EPOLLONESHOT，它们对于epoll的高效运作非常关键，这两个事件将在后面讨论。</p>
</li>
<li><p>data成员用于存储用户数据，其类型epoll_data_t的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>epoll_data_t是一个union，其四个成员中使用最多的是fd，它指定事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数据。<font color="orange">但由于epoll_data_t是一个union，我们不能同时使用ptr和fd成员</font>，因此如果要将文件描述符和用户数据关联起来，只能使用其他手段，<font color="orange">比如放弃使用epoll_data_t的fd成员，而在ptr指向的用户数据中包含fd。</font></p>
</li>
</ul>
<p>epoll_ctl成功时返回0，失败时返回-1并设置errno。</p>
<h2 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h2><p>epoll的一系列系统调用的主要接口时epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>timeout参数指定超时时间，单位为毫秒</li>
<li>maxevents参数指定最多监听多少个事件，它必须大于0</li>
<li>events参数，如果epoll_wait函数检测到事件，就将所有就绪的事件从内核事件表中复制到它events指向的数组中。这个数组<font color="red">只用于输出</font>epoll_wait检测到的就绪事件，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检查到的就绪事件。</li>
<li>epfd参数指定内核事件表的文件描述符</li>
</ul>
<h2 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h2><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。<font color="red">LT模式是默认的工作模式，</font>这种模式下epoll相对于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。<font color="red">ET模式时epoll的高效工作模式。</font></p>
<p>对于采用<code>LT</code>工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理事件。<font color="orange">这样当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</font></p>
<p>而对于采用<code>ET</code>工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<font color="orange">应用程序必须立即处理该事件，因为后续epoll_wait调用将不再向应用程序通知这一事件。</font>可见，ET模式在很大程度上降低了epoll事件被重复触发的次数，因此<font color="red">效率要比LT模式高。</font></p>
<h3 id="LT和ET模式下对事件的不同处理方式"><a href="#LT和ET模式下对事件的不同处理方式" class="headerlink" title="LT和ET模式下对事件的不同处理方式"></a>LT和ET模式下对事件的不同处理方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Bytedance-Wall Flower on 2021/1/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUM 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorEventForFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setNonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt_mode</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> listen_fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sock_fd == listen_fd) &#123;</span><br><span class="line">            sockaddr_in client_socket_addr&#123;&#125;;</span><br><span class="line">            <span class="keyword">socklen_t</span> sock_len;</span><br><span class="line">            <span class="keyword">int</span> conn_fd = accept(listen_fd, (sockaddr *)&amp;client_socket_addr, &amp;sock_len);</span><br><span class="line">            monitorEventForFd(epoll_fd, conn_fd, <span class="literal">false</span>); <span class="comment">//使用ET模式监听客户端socket fd</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<span class="comment">//客户端socket fd有数据可读</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client socket fd %d is readable\n&quot;</span>, sock_fd);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">int</span> ret = recv(sock_fd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                close(sock_fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sock fd %d get %d bytes of content: %s\n&quot;</span>, sock_fd, ret, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other event happen in le mode\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et_mode</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> listen_fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sock_fd == listen_fd) &#123;</span><br><span class="line">            sockaddr_in client_socket_addr&#123;&#125;;</span><br><span class="line">            <span class="keyword">socklen_t</span> sock_len;</span><br><span class="line">            <span class="keyword">int</span> conn_fd = accept(listen_fd, (sockaddr *)&amp;client_socket_addr, &amp;sock_len);</span><br><span class="line">            monitorEventForFd(epoll_fd, conn_fd, <span class="literal">true</span>); <span class="comment">//使用ET模式监听客户端socket fd</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client socket fd %d is readable\n&quot;</span>, sock_fd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环读，直到无数据可读</span></span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="keyword">int</span> ret = recv(sock_fd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                        <span class="comment">//对于非阻塞io，下面的条件成立表示数据已经全部读取完毕，</span></span><br><span class="line">                        <span class="comment">//此后epoll 就能再次触发该sock fd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    close(sock_fd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sock_fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sock fd %d get %d bytes of content: %s\n&quot;</span>, sock_fd, ret, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other event happen in et mode\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    server_sock_addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(server_fd, (sockaddr *)&amp;server_sock_addr, <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    epoll_event events[MAX_EVENT_NUM];</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    monitorEventForFd(epoll_fd, server_fd, <span class="literal">true</span>);<span class="comment">//monitor server socket fd use et mode</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUM, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll wait fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lt_mode(events, ret, epoll_fd, server_fd); <span class="comment">//LT mode to process client connection</span></span><br><span class="line"><span class="comment">//        et_mode(events, ret, epoll_fd, server_fd);//ET mode to process client connection</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="orange">注意在ET模式下，当客户端socket有数据可读的时候，需要使用循环一次性把所有数据读完。</font>



<h2 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h2><p>即使使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有数据可读(EPOLLIN再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。这当然不是我们期望的。<font color="orange">我们期望的时一个socket连接在任一时刻都只被一个线程处理。</font>这一点可以使用epoll的EPOLLONESHOT事件实现。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，<font color="orange">除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件</font>。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。<font color="red">但是，反过来，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件</font>，以确保这个socket下一次可读时，其他EPOLLIN事件能被触发。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUM 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FDPair</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd;</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line">&#125; FDPair;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNonBlocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorEventForFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> target_fd, <span class="keyword">bool</span> enable_one_shot)</span> </span>&#123;</span><br><span class="line">    epoll_event event&#123;&#125;;</span><br><span class="line">    event.data.fd = target_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="keyword">if</span> (enable_one_shot) &#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, target_fd, &amp;event);</span><br><span class="line">    setNonBlocking(target_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetOneShot</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> target_fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重置target fd上的事件，这样操作之后，</span></span><br><span class="line">    <span class="comment">//尽管target fd上的EPOLLONESHOT事件被注册，但是操作系统仍然会触发target fd上的EPOLLIN事件，且只触发一次</span></span><br><span class="line">    epoll_event event&#123;&#125;;</span><br><span class="line">    event.data.fd = target_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_MOD, target_fd, &amp;event);<span class="comment">//注意这里的操作是modify</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端socket的工作线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *<span class="built_in">pair</span> = (FDPair *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, <span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = recv(<span class="built_in">pair</span>-&gt;sock_fd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            close(<span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foreigner closed the connection\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//errno是线程安全的，不用担心</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                resetOneShot(<span class="built_in">pair</span>-&gt;epoll_fd, <span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get content: %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="comment">//休眠3s，模拟数据处理过程</span></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on socket fd: %d\n&quot;</span>, <span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    server_sock_addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(server_fd, (sockaddr *)&amp;server_sock_addr, <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    epoll_event events[MAX_EVENT_NUM];</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//注意，监听server fd是不能注册EPOLLONESHOT事件的，</span></span><br><span class="line">    <span class="comment">//否则应用程序只能处理一个客户连接，因为后续的客户连接请求将不再触发server_fd上的EPOLLIN事件</span></span><br><span class="line">    monitorEventForFd(epoll_fd, server_fd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> event_count = epoll_wait(epoll_fd, events, MAX_EVENT_NUM, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll wait fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; event_count; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sock_fd == server_fd) &#123;</span><br><span class="line">                sockaddr_in client_sock_addr&#123;&#125;;</span><br><span class="line">                <span class="keyword">socklen_t</span> sock_len;</span><br><span class="line">                <span class="keyword">int</span> client_sock_fd = accept(server_fd, (sockaddr *)&amp;client_sock_addr, &amp;sock_len);</span><br><span class="line">                monitorEventForFd(epoll_fd, client_sock_fd, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">                <span class="keyword">pthread_t</span> thread_handler;</span><br><span class="line">                FDPair <span class="built_in">pair</span>&#123;&#125;;</span><br><span class="line">                <span class="built_in">pair</span>.epoll_fd = epoll_fd;</span><br><span class="line">                <span class="built_in">pair</span>.sock_fd = sock_fd;</span><br><span class="line">                pthread_create(&amp;thread_handler, <span class="literal">nullptr</span>, worker, &amp;<span class="built_in">pair</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;other event happen\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="orange">注意在工作线程中，处理完一次client socket fd上的数据后，需要重置该client socket fd</font>



<h1 id="三个I-O复用函数的比较"><a href="#三个I-O复用函数的比较" class="headerlink" title="三个I/O复用函数的比较"></a>三个I/O复用函数的比较</h1><ul>
<li>每次select和poll调用都返回整个用户注册的事件集合（所有注册的fd，不论是就绪的还是未就绪的），所以应用程序检索就绪文件描述符的时间复杂度为O(n)。而epoll_wait返回的events参数仅用来返回就绪事件，这使得应用程序索引就绪文件描述符的事件复杂度减少到O(1)。</li>
<li>poll和epoll_wait分别使用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能到达系统允许打开的最大文件描述符数目。而select允许监听的最大文件描述符数量通常有限制。虽然用户可以修改这个限制，但这可能导致不可预期的后果。</li>
<li>从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法时间复杂度为O(n)。而epoll_wait采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将就绪事件队列中的内容拷贝到用户空间。因此epoll_wati的算法时间复杂度为O(1)。<font color="red">但是，当活动连接比较多的时候，epoll_wati的效率未必比select和poll高</font>，因为此时回调函数被触发得过于频繁。<font color="red">所以epoll_wait适用于连接数量多，但是活动连接较少的情况</font></li>
</ul>
<h1 id="I-O复用的高级应用一：非阻塞connect"><a href="#I-O复用的高级应用一：非阻塞connect" class="headerlink" title="I/O复用的高级应用一：非阻塞connect"></a>I/O复用的高级应用一：非阻塞connect</h1><p>对于非阻塞的socket调用connect，而连接又没有立即建立时，这个时候，connect会设置errno值为EINPROGRESS。这个时候对于非阻塞的socket，我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码为0，表示连接成功建立，否则连接失败。<font color="red">非阻塞connect的应用：可以同时发起多个连接并一起等待。</font></p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Bytedance-Wall Flower on 2021/1/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNonBlocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nonblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    sockaddr_in server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    server_sock_addr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> old_option =  setNonBlocking(sock_fd);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(sock_fd, (sockaddr *)&amp;server_sock_addr, <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果连接成功，则恢复sock fd的属性</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">        fcntl(sock_fd, F_SETFL, old_option);</span><br><span class="line">        <span class="keyword">return</span> sock_fd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">        <span class="comment">//只有当errno是EINPROGRESS时才表示连接还在进行，</span></span><br><span class="line">        fd_set write_fds;</span><br><span class="line">        timeval select_timeout&#123;&#125;;</span><br><span class="line">        FD_ZERO(&amp;write_fds);</span><br><span class="line">        FD_SET(sock_fd, &amp;write_fds);</span><br><span class="line">        select_timeout.tv_sec = timeout;</span><br><span class="line">        ret = select(sock_fd + <span class="number">1</span>, <span class="literal">nullptr</span>, &amp;write_fds, <span class="literal">nullptr</span>, &amp;select_timeout);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;select timeout\n&quot;</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!FD_ISSET(sock_fd, &amp;write_fds)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no write events on sock fd: %d\n&quot;</span>, sock_fd);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> error_in_sock_fd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">socklen_t</span> error_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">if</span> (getsockopt(sock_fd, SOL_SOCKET, SO_ERROR, &amp;error_in_sock_fd, &amp;error_len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (error_in_sock_fd != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//错误不为0，表示连接出错</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error: %d\n&quot;</span>, error_in_sock_fd);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//连接成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket: %d\n&quot;</span>, sock_fd);</span><br><span class="line">            fcntl(sock_fd, F_SETFL, old_option);<span class="comment">//重置为原来的属性</span></span><br><span class="line">            <span class="keyword">return</span> sock_fd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果连接没有立即建立，连接又不还在进行，出错返回</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;non-block connect unsupported\n&quot;</span>);</span><br><span class="line">        close(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = nonblock_connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *data = <span class="string">&quot;data from client !!!&quot;</span>;</span><br><span class="line">    send(sock_fd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">注意，上面的代码有平台移植的问题：</font>

<ul>
<li>首先，非阻塞的socket可能导致connect始终失败。</li>
<li>其次，select对处于EINPROGRESS状态下的socket可能不起作用</li>
<li>对于出错的socket，getsockopt在有些系统（比如Linux）上返回-1，而在有些系统（比如BSD）上则返回0。</li>
</ul>
<p>这些问题没有一个统一的解决方法，可能需要针对不同的平台使用宏来分别判断。</p>
<h1 id="I-O复用高级应用二：简单聊天室程序"><a href="#I-O复用高级应用二：简单聊天室程序" class="headerlink" title="I/O复用高级应用二：简单聊天室程序"></a>I/O复用高级应用二：简单聊天室程序</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/08/kafka_preliminary/kafka%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/kafka_preliminary/kafka%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">kafka基本操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-08 14:27:32 / Modified: 16:31:48" itemprop="dateCreated datePublished" datetime="2020-11-08T14:27:32+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h1><p>kafka的运行需要java环境和zookeeper，所以需要先下载好jdk和zookeeper，然后启动zookeeper server。详细操作可以参考<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/apache_kafka/apache_kafka_installation_steps.html">这里</a></p>
<p>启动一个kafka server(broker)的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<p>该命令需要传递一个kafka server配置文件的路径，使用默认的配置即可。</p>
<h1 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h1><p>kafka提供了一个名为”kafka-topics.sh”的脚本，用于在kafka server上创建topic，在命令行输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 </span><br><span class="line">--partitions 1 --topic hello-kafka</span><br></pre></td></tr></table></figure>
<p>该命令创建了一个叫做hello-kafka的topic。</p>
<p>创建topic后，也可以使用这个脚本获取服务器中的主题列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>
<h1 id="启动生产者以发送消息"><a href="#启动生产者以发送消息" class="headerlink" title="启动生产者以发送消息"></a>启动生产者以发送消息</h1><p>kafka提供一个kafka-console-producer.sh的脚步用于启动一个producer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name</span><br></pre></td></tr></table></figure>
<p>这个脚步需要两个参数，一个是kafka server(broker)的ip和端口，另外一个参数就是主题的名称。</p>
<p>启动producer后，脚本会从stdin获取输入，然后发送到kafka集群中。默认情况下，每个新行都作为新消息发布，可以在config/producer.properties文件中配置producer的一些属性。</p>
<h1 id="启动消费者以接收消息"><a href="#启动消费者以接收消息" class="headerlink" title="启动消费者以接收消息"></a>启动消费者以接收消息</h1><p>kafka也提供了一个Kafka-console-consumer.sh脚本来启动一个消费者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic-name</span><br></pre></td></tr></table></figure>
<h1 id="单节点多代理配置"><a href="#单节点多代理配置" class="headerlink" title="单节点多代理配置"></a>单节点多代理配置</h1><p>之前的基本操作的说明都是在单节点(一台物理机器)-单代理(一个kafka broker)下的场景下的，现在说明如何在一台物理机上启动多个Kafka server(broker)。</p>
<p>首先需要启动zookeeper服务器，然后由于需要启动多个kafka broker，需要为每个broker创建一个配置文件，可以将config/server.properties文件复制多份，并重新命令为config/server-one.properties，config/server-two.properties，注意需要修改配置文件中的port字段，让broker监听不同的端口。broker默认监听的端口是9092。</p>
<p>在多代理下可以对一个partition创建副本，可以使用Kafka-topics.sh脚本的”—describe”参数来检查哪个broker是partition的leader：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic topic-name</span><br></pre></td></tr></table></figure>
<p><code>在单节点多代理下创建生产者和消费者的方式和在单节点单代理的场景下相同</code>。</p>
<h1 id="修改已有主题的配置"><a href="#修改已有主题的配置" class="headerlink" title="修改已有主题的配置"></a>修改已有主题的配置</h1><p>修改主题使用Kafka-topics.sh脚本来完成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh —zookeeper localhost:2181 --alter --topic topic-name </span><br><span class="line">--partitions count</span><br></pre></td></tr></table></figure>
<p>这个命令可以修改topic-name的分区数量和备份数量。</p>
<h1 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic topic-name</span><br></pre></td></tr></table></figure>
<p>注意，如果配置delete.topic.enable为false，则delete操作不会生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
