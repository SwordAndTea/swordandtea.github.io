<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="xiangwei&#39;s blog">
<meta property="og:url" content="http://swordandtea.github.io/page/2/index.html">
<meta property="og:site_name" content="xiangwei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SwordAndTea">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>xiangwei's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiangwei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/05/05/devops/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/devops/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">k8s常用命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-05 13:13:19 / Modified: 13:15:58" itemprop="dateCreated datePublished" datetime="2022-05-05T13:13:19+08:00">2022-05-05</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>37</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h1><ul>
<li><p><code>kubectl config get-contexts</code></p>
<ul>
<li>查看当前有哪些集群context可以使用</li>
</ul>
</li>
<li><p><code>kubectl config use-context &lt;context name&gt;</code></p>
<ul>
<li>切换kubectl当前的集群context</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/05/02/Linux/linux%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/02/Linux/linux%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">linux网络</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-02 19:12:34" itemprop="dateCreated datePublished" datetime="2022-05-02T19:12:34+08:00">2022-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-05 15:01:07" itemprop="dateModified" datetime="2022-05-05T15:01:07+08:00">2022-05-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>301</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由可以分为以下三种：</p>
<ul>
<li><p>主机路由：表示到某台具体主机的路由（目前来说很少使用了）</p>
</li>
<li><p>网络路由：表达到某个网段的路由</p>
</li>
<li><p>默认路由：即<code>0.0.0.0/0</code>对应的路由项，它用于在路由表中查不到匹配项时进行的默认路由</p>
</li>
</ul>
<font color="orange">路由表的匹配采用最长匹配的原则</font>

<p>路由表不用记录同一网段中的其他主机的ip，同一网络中的主机通信直接通过数据链路层的ARP协议查询到IP地址对应的MAC地址后进行通信即可。</p>
<h2 id="linux路由表组成部分"><a href="#linux路由表组成部分" class="headerlink" title="linux路由表组成部分"></a>linux路由表组成部分</h2><p>在linux中可以使用<code>ip route</code>命令来查看路由表。路由表项由以下几个部分组成：</p>
<ul>
<li><p>destination：路由目标路径</p>
</li>
<li><p>interface：路由器的出口</p>
</li>
<li><p>gateway</p>
<ul>
<li><p>直连情况（即两个ip之间没有通过路由器相连）：不需要配置gateway，或者值为0.0.0.0</p>
</li>
<li><p>非直连情况：需要配置gateway，其值为下一个路由器在本网络中（当路由器对接多个网络时，会有多个网络地址）的ip地址</p>
</li>
</ul>
</li>
</ul>
<h2 id="路由表配置"><a href="#路由表配置" class="headerlink" title="路由表配置"></a>路由表配置</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/04/03/devops/k8s/pod%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/devops/k8s/pod%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">pod详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 21:57:13" itemprop="dateCreated datePublished" datetime="2022-04-03T21:57:13+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-17 18:59:47" itemprop="dateModified" datetime="2022-05-17T18:59:47+08:00">2022-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index">
                    <span itemprop="name">k8s</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id><a href="#" class="headerlink" title=" "></a> </h1><p>pod是k8s集群中的最小调度单元，一个pod中可以有多个容器。k8s引入pod，而不直接对容器进行调度的原因有如下两个：</p>
<ul>
<li><p>一个是为了将容器的实现和k8s平台自身引擎的实现进行解耦，从而做到可以支持多种类型的容器（docker、rkt）</p>
</li>
<li><p>另外一个是可以让多个容器共享网络、存储、进程空间，减少资源消耗</p>
</li>
</ul>
<h1 id="使用yaml定义一个pod"><a href="#使用yaml定义一个pod" class="headerlink" title="使用yaml定义一个pod"></a>使用yaml定义一个pod</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment">#pod name</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment">#命名空间，如果无该字段，则使用默认命名空间</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#pod标签，可选</span></span><br><span class="line">   <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line">   <span class="attr">key2:</span> <span class="string">value2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 挂载目录，有多种挂载方式 </span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment">#容器的名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="comment">#容器使用的镜像</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 容器访问</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> </span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 容器环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="attr">value:</span></span><br></pre></td></tr></table></figure>
<p>定义好一个pod描述之后，就可以使用<code>kubectl create -f xxx.yaml</code>来创建一个pod</p>
<h1 id="pod的常用操作"><a href="#pod的常用操作" class="headerlink" title="pod的常用操作"></a>pod的常用操作</h1><ul>
<li><p>查看pod被调度的节点已经pod ip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; get pod -o wide</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看pod的配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; get pod &lt;pod name&gt; -o &lt;yaml|json&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看pod的信息及事件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; describe pod &lt;pod name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入pod内的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; exec &lt;pod name&gt; -c &lt;container name&gt; -it /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看pod内容器日志，显示标准或者错误输出日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; logs -f &lt;pod name&gt; -c &lt;container name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;pod yaml file&gt; # 更新pod是使用更新yaml文件的形式</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f &lt;pod yaml file&gt; # 根据配置文件删除</span><br><span class="line">kubectl -n &lt;namespace&gt; delete pod &lt;pod name&gt; # 根据pod name删除</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Pod健康检查"><a href="#Pod健康检查" class="headerlink" title="Pod健康检查"></a>Pod健康检查</h1><p>pod的健康检查由kubelet来进行，pod健康检查有两种机制：</p>
<ul>
<li><p>LivenessProbe：存活性探测，用于判断容器是否存活，即pod是否为running状态。如果LivenessProbe探针探测到容器不健康，则kubelet将kill掉容器，并根据容器的重启策略是否重启（如果不配置，默认会进行重启），如果一个容器不包含LivenessProbe探针，则kubelet认为容器的LivenessProbe探针的返回值永远成功，即任务容器是健康的。 </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span> <span class="comment">#有三种类型：exec(执行脚本，脚本返回0表示健康)、</span></span><br><span class="line">               <span class="comment">#httpGet(返回200-399状态码表示健康)、</span></span><br><span class="line">               <span class="comment">#tcpSocket(如果能够建立TCP连接，则表示健康)</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">        <span class="attr">scheme:</span> </span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="comment"># 容器启动后多少秒后第一次执行探测</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="comment"># 多少秒执行一次探，默认10s，最小1s，</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="comment"># 探测超时时间默认1s，最小1</span></span><br><span class="line">      <span class="attr">successThreshold:</span> <span class="comment"># 连续探测成功多少次才被认为是成功，默认为为1</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="comment"># 连续探测失败多少次才被任务是失败，默认为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ReadinessProbe：可用性探测，用于判断容器是否正常提供服务，即容器的Ready是否为True，是否可以接收请求。如果ReadinessProbe探测失败，则容器的ready将为False，Endpoint Controller控制器会将此Pod的Endpoint从对应的service的Endpoint列表中移除，不再将任何请求调度到此Pod上，直到下次探测成功。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">        <span class="attr">scheme:</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="comment"># 容器启动后多少秒后第一次执行探测</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="comment"># 多少秒执行一次探测</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="comment"># 探测超时时间</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<font color="orange">对于同一个容器，两种健康检查可以同时设置。</font>

<h1 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h1><font color="orange">Pod的重启策略应用于Pod内的所有容器，并且仅在Pod所处的Node上由Kubelet进行判断和重启操作。</font>当某个容器异常退出或者健康检查失败时，kubelet将根据RestartPolicy的设置来进行相应的操作。Pod的重启策略包括Always、OnFailure和Never，默认值为Always。

* Always：当容器进程退出后，由kubelet自动重启该容器

* OnFailure：当容器进程终止运行且退出码不为0时，由kubelet自动重启该容器

* Never：不论容器运行状态如何，kubelet都不会重启该容器

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">containers:</span></span><br></pre></td></tr></table></figure>

# 镜像拉取策略

有如下几种镜像拉取策略：

* Always：总是拉取镜像，即使本地有镜像也从镜像仓库拉取

* IfNotPresent：本地有则使用本地镜像，本地没有则去仓库拉取，默认的镜像拉取策略

* Never：只使用本地镜像，本地没有则报错

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure>

# Pod资源限制

为了保证充分利用集群资源，且确保重要容器在运行周期内能够分配到足够的资源稳定运行，因此平台需要具备Pod的资源限制的能力。对于一个Pod来说，资源最基础的2个指标就是CPU和内存。资源限制有两种类型：

* requests：容器使用的最小资源要求，作用于schedule阶段，作为容器调度时分配的判断依赖，只有当节点上可分配的资源量>=request时，才允许将容器调度到该节点。requests参数不限制容器的最大可用资源。requests.cpu被转成docker的--cpu-shares参数，与cgroup.cpu.shared功能相同。requests.memory没有对应的docker参数，仅作为k8s调度的依据

* limits：容器使用的最大资源限制，不设置或者设置为0表示对使用的资源不做限制。当pod内存超过limit时，会被oom，当cpu超过limit时，不会被kill，但会被限制不超过limit值（因为cpu的时间片是动态调度）。limits.cpu会被转换成docker的-cpu-quota参数，与cgroup.cpu.cfs\_quota_us功能相同。limits.memory会被转换成docker的-memory参数，用来限制容器使用的最大内存。

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">    <span class="attr">image:</span> </span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">500m</span> <span class="comment"># 等同于0.5</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">500Mi</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

# configMap和secret

configMap和Secret是k8s提供的两种资源类型，它们可以用来实现业务配置的统一管理。一般来说会使用configMap存储一些不包含敏感信息的基本配置，secret用于管理敏感信息配置，例如密码、密钥等。

使用yaml定义一个configMap资源：

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure>

secret有三种类型：

* Service Accout：用来访问k8s API，由k8s 自动创建，并且会自动挂载到pod的/run/secrets/kubernetes.io/serveraccount目录中；

* Opaque：base64编码的Secret，用来存储密码，密钥等

* kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key1:</span> <span class="string">base64_encoded_value1</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="string">base64_encoded_value2</span></span><br></pre></td></tr></table></figure>

configMap和secret的使用：

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">env_name_1</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&lt;secret</span> <span class="string">resouce</span> <span class="string">name&gt;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">&lt;secret</span> <span class="string">resouce</span> <span class="string">key&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">env_name_2</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&lt;config</span> <span class="string">map</span> <span class="string">resource</span> <span class="string">name&gt;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">&lt;config</span> <span class="string">map</span> <span class="string">resource</span> <span class="string">key&gt;</span></span><br></pre></td></tr></table></figure>

# pod生命周期

一个pod可能处于如下的几种状态

| 状态值                    | 描述                                       |
| ---------------------- | ---------------------------------------- |
| Pending                | API Server已经创建该Pod，等待调度器调度               |
| ContainerCreating      | 拉取镜像启动容器中                                |
| Runing                 | Pod内容器均已创建，且至少有一个容器处于运行状态、正在启动状态或者正在重启状态 |
| Succeeded \| Completed | 容器内所有容器均已成功执行退出，且不再重启                    |
| Failed \| Error        | Pod内所有容器均已退出，但至少有一个容器退出为失败状态             |
| CrashLoopBackOff       | Pod内容器启动失败，比如配置文件丢失导致进程启动失败              |
| Unknown                | 由于某种原因无法获取该Pod的状态，可能由于网络通信不畅导致           |

pod支持两种hook，post-start hook 和pre-stop hook

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">      <span class="attr">image:</span></span><br><span class="line">      <span class="attr">lifecycle:</span></span><br><span class="line">        <span class="attr">postStart:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> </span><br><span class="line">        <span class="attr">preStop:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br></pre></td></tr></table></figure>

pre-stop hook只有在手动kill掉pod才会触发，如果是Pod自己down掉，则不会触发pre-stop hook

# Pod控制器（workload工作负载）

workload是用于实现管理pod的中间层，确保pod资源符合预期的状态，pod的资源出现故障时，会尝试进行重启，当根据重启策略无效时，则会重新新建pod资源。workload有以下几种类型：

* ReplicaSet：pod副本数量，确保pod副本数量符合预期状态，并且支持滚动式自动阔缩容

* Deployment：工作在ReplicaSet之上，用于管理无状态应用，目前来说最好的控制器，支持滚动更新和回滚功能

* DaemonSet：用于确保集群中的每一个节点只运行特定的pod服务，通常用于实现系统级后台服务

* Job：只要完成就立即退出，不需要重启或重建

* Cronjob：周期性任务控制，不需要持续后台运行

* StatefulSet：管理有状态应用

## Deployment

使用yaml定义一个deployment

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 指定pod副本数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># pod选择器，有对应label的pod都会归于这个deployment管理，不是pod的node selector</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># pod 模版，同定义pod的yaml文件</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span> <span class="comment">#这里定义的lable的key/value要和上面的select字段定义的相对应</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">nodeLabelKey:</span> <span class="string">nodeLabelValue</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">        <span class="attr">image:</span></span><br><span class="line">        <span class="attr">env:</span></span><br></pre></td></tr></table></figure>

deployment阔缩容命令：

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; scale deployment &lt;deployment name&gt; --replicas=&lt;n&gt;</span><br></pre></td></tr></table></figure>

deployment服务更新（镜像更新）

* 通过yaml配置文件的方式（建议）

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; apply -f &lt;xxx.yaml&gt;</span><br></pre></td></tr></table></figure>

* 通过命令行直接更新

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; set image deployment &lt;deployment name&gt; &lt;container name&gt;=&lt;image&gt;</span><br></pre></td></tr></table></figure>

deploy服务回滚

回滚只能通过命令行进行回滚，不能通过配置文件进行回滚

* 查看可回滚的历史记录

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment &lt;deployment name&gt;</span><br></pre></td></tr></table></figure>

* 回滚

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment &lt;deployment name&gt; --to-revision=&lt;revsion number&gt;</span><br></pre></td></tr></table></figure>

### deployment更新（回滚）策略配置

deployment的更新（回滚）是滚动更新（回滚）的，即一次只进行一部分pod更新（回滚），直到所有的pod都完成更新（回滚），deployment的更新（回滚）策略有以下几种可配置项：

* maxSurge：最大激增数，指更新过程中，最多可以比replicas预先设定值多出的pod数量，可以为固定值或百分比，默认为25%，计算时向上取整

* maxUnavailable：指更新过程中，最多有几个pod处于无法服务状态，可以为固定值或百分比，默认为25%，计算时向下取整

<font color="orange">deployment更新的底层实现其实是新建了一个ReplicaSet，这个ReplicaSet使用的最新版本的镜像，然后通过调整新ReplicaSet和老ReplicaSet的副本数来实现滚动升级。同时老的ReplicaSet不会立即删除，目的是为了方便回滚。</font>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">rollingUpdate:</span></span><br><span class="line">        <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">        <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">template:</span> </span><br><span class="line">      <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">podLabelKey1:</span> <span class="string">podLabelValue</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">nodeSelector:</span></span><br><span class="line">          <span class="attr">nodeLabelKey:</span> <span class="string">nodeLabelValue</span></span><br><span class="line">        <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">          <span class="attr">image:</span></span><br><span class="line">          <span class="attr">env:</span></span><br></pre></td></tr></table></figure>
<h1 id="Service负载均衡之Cluster-IP"><a href="#Service负载均衡之Cluster-IP" class="headerlink" title="Service负载均衡之Cluster IP"></a>Service负载均衡之Cluster IP</h1><p>通过deployment，我们已经可以创建一组Pod来提供具有高可用性的服务，虽然每个Pod都会分配一个单独的Pod IP， 然而却存在如下两个问题：</p>
<ul>
<li><p>Pod IP仅仅是集群内部的虚拟IP，在集群内部可以访问，外部却无法访问</p>
</li>
<li><p>Pod IP会随着Pod的销毁而消失，当ReplicaSet对Pod进行动态伸缩容时，Pod IP可能随时会发生变化，这样对于我们访问这个服务带来了难度</p>
</li>
</ul>
<p>Services是一组pod服务的抽象，相当于一组pod的load balancer，负责将请求分发到对应的pod。service会有一个IP，一般称为cluster ip，service对象通过selector进行标签选择，找到到对应的pod</p>
<p>使用yaml定义一个service</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 端口</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8002</span> <span class="comment"># pod 端口</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">podLabelName:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>
<p>创建好service后，在集群内部就可以直接使用service name + pod对服务进行访问，因为集群内部的dns会记录相关解析规则</p>
<h1 id="Service负载均衡之NodePort"><a href="#Service负载均衡之NodePort" class="headerlink" title="Service负载均衡之NodePort"></a>Service负载均衡之NodePort</h1><p>Cluster IP也是一个虚拟地址，其目的是为了方便集群内部服务直接的通信，只能在k8s集群内部进行访问，如果需要集群外部访问集群内部服务，实现方式之一为使用NodePort方式。NodePort会默认在30000—32767之间，不指定会随机使用其中的一个。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8002</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">podLabelName:</span> <span class="string">podLabelValue</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
<h1 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h1><p>kube-proxy运行在每个节点上，监听API Server中服务对象的变化，再通过创建流量路由规则来实现网络的转发。kube-proxy支持三种模式：</p>
<ul>
<li><p>User space：让kube-proxy 在用户空间监听一个端口，所有的service都转发到这个端口，然后kube-proxy在内部应用层对其进行转发，所有报文都走一遍用户态，性能不高，在k8s v1.2版本后废弃</p>
</li>
<li><p>Iptables：当前默认模式，完全由iptables来实现，通过各个节点上的iptable规则来实现service的负载均衡，但是随着service数量增大，iptables模式由于线性查找匹配、全量更新等特点，其性能会显著下降</p>
</li>
<li><p>IPVS：与iptables同样基于Netfilter，但是采用的hash表，因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能。k8s 1.8版本开始引入，1.11版本开始稳定，需要开启宿主机的ipvs模块</p>
</li>
</ul>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>对于k8s的service，无论是Cluster-IP还是NodePort的形式，都是四层的负载，集群内的服务如果实现7层的负载均衡，这就需要借助与Ingress。Ingress控制器的实现方式有很多，例如nginx、contour、haproxy，trafik，istio。</p>
<p>ingress-nginx是7层的负载均衡器，根据用户编写的ingress规则（创建的ingress的yaml文件），动态的去更改nginx服务的配置文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="comment"># 域名host</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">paths:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">serviceName:</span> <span class="string">&lt;service</span> <span class="string">name&gt;</span></span><br><span class="line">        <span class="attr">servicePort:</span> <span class="string">&lt;service</span> <span class="string">port&gt;</span></span><br></pre></td></tr></table></figure>
<p>ingress实现逻辑</p>
<ul>
<li><p>ingress controller通过api server，监听集群中ingress规则变化</p>
</li>
<li><p>然后读取ingress规则（规则就是写明了哪个域名对应哪个service），按照自定义的规则，生成一段nginx配置</p>
</li>
<li><p>再写到nginx-ingress-contoller的pod里，nginx-ingress-controller的pod里运行着Nginx服务</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/04/03/devops/docker/docker%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/devops/docker/docker%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">docker网络</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-03 15:24:42 / Modified: 18:48:13" itemprop="dateCreated datePublished" datetime="2022-04-03T15:24:42+08:00">2022-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>545</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>我们在使用<code>docker run</code>创建Docker容器时，可以用<code>--net</code>选项指定容器的网络模式，docker有以下4中网络模式：</p>
<ul>
<li><p>bridage模式：docker容器默认的网络模式。它的原理类似交换机设备，而在linux中，能够起虚拟交互作用的，就是网桥（bridge）。它是一个工作在数据链路层的软件，主要功能是根据MAC地址将数据包转发到网桥的不同端口上。</p>
<p>有了网桥之后，容器在启动时，会执行如下操作：</p>
<ol>
<li><p>创建一对虚拟接口/网卡，也就是veth pair</p>
</li>
<li><p>veth pair一端桥接到默认的名称为<code>docker0</code>的网桥或者其他指定网桥上，并具有一个唯一的名字，如veth9953b75</p>
</li>
<li><p>veth pair一端放到新启动的容器内部，并修改名字作为eth0</p>
</li>
<li><p>从虚拟网桥可用地址段中（也就是bridge对应的network）获取一个空闲地址分配给容器内的eth0</p>
</li>
<li><p>容器内部配置默认路由到网桥</p>
</li>
</ol>
<p>如果容器内部需要访问外部网络，需要经过容器内部的eth0网卡、虚拟网桥、宿主机网卡最终访问到外网。如果容器内部需要访问其他容器网络，需要经过容器内部eth0网卡、虚拟网桥、其他容器内部etho0最终访问到其他容器。</p>
</li>
<li><p>host模式：容器内部不会创建网络命名空间（Network Namespace），容器共享宿主机的网络空间。</p>
</li>
<li><p>container模式：这个模式指定新创建的容器和已经存在的一个容器共享一个网络命名空间（Network Namespace）、网卡、ip。<font color="orange">这种模式在一些特殊的场景中非常有用，例如k8s的pod，k8s为pod创建一个基础设施容器，该pod下的其他容器都以container模式共享这个技术设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</font></p>
</li>
<li><p>none模式：只会在容器内创建网络命名空间（Network Namespace），不会创建虚拟网卡</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/04/03/devops/docker/docker%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/devops/docker/docker%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">docker 实现原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-03 12:02:13 / Modified: 15:24:24" itemprop="dateCreated datePublished" datetime="2022-04-03T12:02:13+08:00">2022-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>727</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Namespace资源隔离"><a href="#Linux-Namespace资源隔离" class="headerlink" title="Linux Namespace资源隔离"></a>Linux Namespace资源隔离</h1><p>Linux命名空间是全局资源的一种抽象，将资源发到不同的命名空间中，各个命名空间中的资源时相互隔离的。命名空间有以下几种类别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>系统调用参数</th>
<th>相关内核版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>Linux 2.4.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>Linux 2.6.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>Linux 2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>Linux 2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>始于Linux 2.6.24 完成于2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>CLONE_NEWUSER</td>
<td>始于Linux2.6.23 完成于3.8</td>
</tr>
</tbody>
</table>
</div>
<p>查看进程的namespace</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/&lt;pid&gt;/ns</span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 net -&gt; net:[4026532057]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 pid_for_children -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 xiangwei.flower xiangwei.flower 0 Apr  3 12:27 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>
<h1 id="CGroup资源限制"><a href="#CGroup资源限制" class="headerlink" title="CGroup资源限制"></a>CGroup资源限制</h1><p>通过Namespace可以保证容器之间的隔离，但是无法控制容器可以占用多少资源，如果其中的某一个容器正在执行CPU计算密集型任务，那么就会影响其他容器任务的性能与执行效率，导致多个容器相互影响并且抢占资源。</p>
<p>CGroup（Control Group）就是能够隔离宿主机上的物理资源，例如CPU、内存、磁盘I/O和网络带宽。而我们需要做的就是把容器进程加入到指定的CGroup中。</p>
<h1 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS 联合文件系统"></a>UnionFS 联合文件系统</h1><p>Linux Namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器，这些容器可能会公用一个image。所以容器在启动的时候，不可能各自将这个image复制一份。Docker在内部使用镜像分层存储以及UnionFS来实现多个容器共用一个镜像。</p>
<ul>
<li><p>镜像分层存储：docker镜像是由一系列的层组成的，每层代表Dockerfile中的一条指令，比如下面的Dockerfile文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">15.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure>
<p>这个dockerfile文件最终生成镜像的时候会生成四层，这四层是不可写的，而通过镜像实例化容器的过程，其实就是在就是在这四层之上添加了一个可写层，也就是我们通常说的容器层。而对容器层的操作，主要是利用了写时复制（CoW，copy on write）的技术。例如，如果当前操作会改变下面四层的某一层，docker会先将该层拷贝到容器层，然后再在容器层中进行操作。</p>
</li>
<li><p>UnionFS 其实是一种为Linux操作系统设计的，用于把多个文件系统联合到同一个挂载点的文件系统服务。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/03/27/math/discrete_mathematics/dft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/27/math/discrete_mathematics/dft/" class="post-title-link" itemprop="url">dft</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-27 10:23:10" itemprop="dateCreated datePublished" datetime="2022-03-27T10:23:10+08:00">2022-03-27</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/03/26/program_language/python/effective_python/%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/program_language/python/effective_python/%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">类与接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-26 21:33:56 / Modified: 23:44:01" itemprop="dateCreated datePublished" datetime="2022-03-26T21:33:56+08:00">2022-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-python/" itemprop="url" rel="index">
                    <span itemprop="name">effective python</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>346</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型"><a href="#第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型" class="headerlink" title="第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型"></a>第37条：用组合起来的类来实现多层结构，不要用嵌套的内置类型</h1><p>一般我们在编写项目代码时，由于初始的需求简单，需要用到的数据结构也简单，所以我们会经常使用python提供的容器来用做类的内部状态记录。但是随着需求的迭代，我们可能会使用到数据结构可能会更变得复杂，这时，我们不能简单的对用于记录内部状态的容器进行嵌套，而是应该考虑将内部的某些状态封装成一个类，并在外部的接口类中对这些数据类进行组合。</p>
<h1 id="第38条：让简单的接口接受函数，而不是类的实例"><a href="#第38条：让简单的接口接受函数，而不是类的实例" class="headerlink" title="第38条：让简单的接口接受函数，而不是类的实例"></a>第38条：让简单的接口接受函数，而不是类的实例</h1><p>Python有很多内置的API，都允许我们传入某个函数来定制它的行为，这种函数被成为hook函数，API在执行的时候，会调用这些hook函数。例如，list类的sort方法的key参数。<font color="orange">在其他编程语音中，hook函数可能是通过抽象类或者接口来定义的（例如Java），但在python中一般是直接使用无状态的函数（即不会对内部状态进行修改）</font></p>
<h1 id="第39条：通过-classmethod多态来构造同一体系中的各类对象"><a href="#第39条：通过-classmethod多态来构造同一体系中的各类对象" class="headerlink" title="第39条：通过@classmethod多态来构造同一体系中的各类对象"></a>第39条：通过@classmethod多态来构造同一体系中的各类对象</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/03/06/program_language/python/effective_python/%E6%8E%A8%E5%AF%BC%E4%B8%8E%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/program_language/python/effective_python/%E6%8E%A8%E5%AF%BC%E4%B8%8E%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">推导与生成</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-06 12:07:53" itemprop="dateCreated datePublished" datetime="2022-03-06T12:07:53+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-17 20:53:16" itemprop="dateModified" datetime="2022-03-17T20:53:16+08:00">2022-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-python/" itemprop="url" rel="index">
                    <span itemprop="name">effective python</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第27条：用列表推导取代map与filter"><a href="#第27条：用列表推导取代map与filter" class="headerlink" title="第27条：用列表推导取代map与filter"></a>第27条：用列表推导取代map与filter</h1><p>Python里面有一种很精简的写法，可以根据某个序列或可迭代对象派生出一份新的列表。用这种写法写成的表达式，叫作列表推导。假设我们要用列表中每个元素的平方值构建一份新的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure>
<p>这种功能也可以使用内置函数map实现，它能够从多个列表中分别取出当前位置上的元素，并把它们当作参数传给映射函数，以求出新列表在这个位置上的元素值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a)</span><br></pre></td></tr></table></figure>
<font color="orange">如果映射关系比较简单，那么用列表推导来写还是要比用map简单一些，因为用map的时候，必须先把映射逻辑定义为lambda函数，这看上去稍微有点繁琐。</font>

<p>列表推导还有一个地方比map好，就是它能够方便地过滤原列表，把某些输入值对应的计算结果从输出结果中排除。例如，假设新列表只需要纳入原列中那些偶数的平方值，那么我们可以在推导的时候再添加一个条件表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这种功能也可以通过内置的filter与map函数来实现，但是这两个函数相结合的写法要比列表推导难懂一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt = <span class="built_in">map</span>(<span class="keyword">lambda</span> x : x**<span class="number">2</span>, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br></pre></td></tr></table></figure>
<p>上面这个写法是先用filter对a中的元素进行过滤形成新的列表，然后在对这个新的列表用map函数生成最终结果。</p>
<font color="orange">字典与集合也有相应的推导机制，分别叫做字典推导与集合推导，可以根据原字典与原集合创建新字典与新集合。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_squares_dict = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">threes_cubed_set = &#123;x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果改用map与filter实现，那么还必须调用相应的构造器（constructor），这会让代码变得很长，需要分成多行才能写得下。这样看起来比较乱，不如使用推导机制的代码清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alt_dict = <span class="built_in">dict</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x, x**<span class="number">2</span>), <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a)))</span><br><span class="line">alt_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x, x**<span class="number">3</span>), <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, a)))</span><br></pre></td></tr></table></figure>
<h1 id="第28条：控制推导逻辑的子表达式不要超过两个"><a href="#第28条：控制推导逻辑的子表达式不要超过两个" class="headerlink" title="第28条：控制推导逻辑的子表达式不要超过两个"></a>第28条：控制推导逻辑的子表达式不要超过两个</h1><p>列表推导除了最基本的用法外，列表推导还支持多层循环。例如，要把二维列表转化为普通的一维列表，那么可以在推导时，使用两条for子表达式。这些子表达式会按照从左到右的顺序解读。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br></pre></td></tr></table></figure>
<p>这样写简单易懂，也是多层循环在列表推导中的合理用法。多层循环还可以用来重制那种两层深的结构。例如，要根据二维矩阵里每个元素的平方值来构建一个新的二维矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br></pre></td></tr></table></figure>
<p>如果推导过程中还要再加一层循环，那么语句就会变得很长，必须把它分成多行来写，例如下面是把一个三维矩阵转化成普通一维列表的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_lists = [</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]],</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">flat = [x <span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists </span><br><span class="line">        <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</span><br></pre></td></tr></table></figure>
<font color="orange">在这种情况下，采用列表推导来实现，其实并不会比传统的for循环节省多少代码。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flat = []</span><br><span class="line"><span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists:</span><br><span class="line">    <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1:</span><br><span class="line">        flat.extend(sublist2)</span><br></pre></td></tr></table></figure>
<p>推导的时候，可以使用多个if条件，如果这些if条件出现在同一层循环内，那么它们之间默认是and关系，也就是必须同时成立。例如，如果要用原列表中大于4且是偶数的值来构建新列表，那么既可以连用两个if，也可以只用一个if，下面两种写法效果相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>在推导时，每一层的for子表达式都可以带有if条件。假如要根据原矩阵构建新的矩阵，把其中各元素之和大于等于10的那些行选出来，而且只保留其中能够被3整除的那些元素。这个逻辑用列表推导来写，并不需要太多的代码，但是这些代码理解起来会很困难：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">filterd = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> <span class="built_in">sum</span>(row) &gt;= <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<font color="orange">总之，在表示推导逻辑时，最多只应该写两个子表达式（例如两个if条件、两个for循环，或者一个if条件与一个for循环）。</font> 只要实现的逻辑比这还复杂，那就应该采用普通的if和for语句来实现。

# 第29条：用赋值表达式消除推导中的重复代码

推导list、dict与set等结构时，经常要在多个地方用到同一个计算结果。例如，我们要给制作紧固件的公司编写程序以管理订单。顾客下单后，我们要判断当前库存能否满足这份订单，也就是说，要和产每种产品的数量有没有达到可以发货的最低限制（8个为一批，至少要一批，才能发货）。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stock = &#123;</span><br><span class="line">    <span class="string">&#x27;nails&#x27;</span>: <span class="number">125</span>,</span><br><span class="line">    <span class="string">&#x27;screws&#x27;</span>: <span class="number">35</span>,</span><br><span class="line">    <span class="string">&#x27;wingnuts&#x27;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&#x27;washers&#x27;</span>: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order = [<span class="string">&#x27;screws&#x27;</span>, <span class="string">&#x27;wingnuts&#x27;</span>, <span class="string">&#x27;clips&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_batches</span>(<span class="params">count, size</span>):</span><br><span class="line">    <span class="keyword">return</span> count // size</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> order:</span><br><span class="line">    count = stock.get(name, <span class="number">0</span>)</span><br><span class="line">    batches = get_batches(count, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> batches:</span><br><span class="line">        result[name] = batches</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="string">&#x27;screws&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;wingnuts&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

这段循环逻辑，如果改用字典推导来写，会简单一些：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>) </span><br><span class="line">         <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">         <span class="keyword">if</span> get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>)&#125;</span><br></pre></td></tr></table></figure>

这样写虽然比刚才简短，但问题是，它把`get_batches(stock.get(name, 0), 8)`写了两遍。有个简单的办法可以解决这个问题，那就是在推导的过程中使用Python3.8新引入的 `:=`操作符进行赋值表达

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: batches <span class="keyword">for</span> name <span class="keyword">in</span> order </span><br><span class="line">         <span class="keyword">if</span> (batches := get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>))&#125;</span><br></pre></td></tr></table></figure>

在推导过程中，<font color="orange">描述新值的那一部分也可以出现赋值表达式，但如果在其他部分引用了定义在那一部分的变量，那么程序可能就会在运行时出错：</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: (tenth := count // <span class="number">10</span>)</span><br><span class="line">          <span class="keyword">for</span> name, count <span class="keyword">in</span> stock.items() <span class="keyword">if</span> tenth &gt; <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Traceback ...</span><br><span class="line">NameError: name <span class="string">&#x27;tenth&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>但是，如果把赋值表达式移动到<code>if</code>条件里面，就可以解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: tenth <span class="keyword">for</span> name, count <span class="keyword">in</span> stock.items() </span><br><span class="line">          <span class="keyword">if</span> (tenth := count // <span class="number">10</span>) &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值"><a href="#第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值" class="headerlink" title="第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值"></a>第30条：不要让函数直接返回列表，应该让它逐个生成列表里面的值</h1><p>如果函数要返回的是个包含许多结果的序列，那么最简单的办法就是把这些结果放到列表中。例如，我们要返回字符串里每个单词的首字母在字符串中所对应的下标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_words</span>(<span class="params">text</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, latter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> latter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            result.apppend(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">the_text = <span class="string">&#x27;Four score and seven years ago...&#x27;</span></span><br><span class="line">result = index_words(the_text)</span><br><span class="line"><span class="built_in">print</span>(result[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>
<p>上面的<code>index_words</code>函数也可以改用生成器来实现。<font color="orange">生成器由包含yield表达式的函数创建。</font>下面就定义一个生成器函数，实现与刚才那个函数相同的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_words_iter</span>(<span class="params">the_text</span>):</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> index + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<font color="orange">调用生成器函数并不会让其中的代码立刻得到执行，它会返回一个迭代器（iterator）。把迭代器传给Python内置的next函数，就可以将生成器函数推进到它的下一条yield表达式。生成器会把yield表达式的值通过迭代器返回给调用者。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = index_words_iter(the_text)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>如果确实要制作一份列表，那可以把生成器函数返回的迭代器传给内置的list函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">list</span>(index_words_iter(the_text))</span><br></pre></td></tr></table></figure>
<p><code>index_words_iter</code>相对于<code>index_words</code>来说，不必一次性把所有结果都保存到列表中，在数据的数据较多的情况下，<code>index_words</code>有可能因为耗尽内存而导致程序崩溃。</p>
<p>使用这些生成器函数时，只有一个地方需要注意，就是调用者无法重复使用函数所返回的迭代器，因为迭代器是有状态的（参见第31条）。</p>
<h1 id="第31条：谨慎地迭代函数所接受的可迭代参数"><a href="#第31条：谨慎地迭代函数所接受的可迭代参数" class="headerlink" title="第31条：谨慎地迭代函数所接受的可迭代参数"></a>第31条：谨慎地迭代函数所接受的可迭代参数</h1><p>如果函数接受的参数是个可迭代对象，那么我们可能会在函数中对其迭代多次。例如，我们要分析美国德克萨斯州的游客数量。原始数据保存在一份列表中，其中的每个元素表示每年有多少游客（单位是百万）。我们要统计每个城市的游客数占游客总数的百分比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">numbers</span>):</span><br><span class="line">    total = <span class="built_in">sum</span>(numbers)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> numbers:</span><br><span class="line">        percent = <span class="number">100</span> * value / total</span><br><span class="line">        result.append(percent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>在<code>normalize</code>函数中会对<code>numbers</code>参数进行两次迭代，一次是在<code>sum</code>函数的调用中，一次是在<code>for</code>循环中。</p>
<p>如果我们给<code>nomalize</code>函数传入参数的是一个列表，我们可以的得到正确的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visits = [<span class="number">15</span>, <span class="number">35</span>, <span class="number">80</span>]</span><br><span class="line">percentages = normalize(visits)</span><br><span class="line"><span class="built_in">print</span>(percentages)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">11.538</span>, <span class="number">26.924</span>, <span class="number">61.538</span>]</span><br></pre></td></tr></table></figure>
<p>但是如果我们传给<code>nomalize</code>函数的是个迭代器，例如在数据规模较大，需要从文件中读取数据时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_visits</span>(<span class="params">data_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_path) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">int</span>(line)</span><br></pre></td></tr></table></figure>
<p>奇怪的是，对<code>read_visits</code>所返回的迭代器调用<code>normalize</code>函数之后，并没有得到结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = read_visits(<span class="string">&#x27;my_numbers.txt&#x27;</span>)</span><br><span class="line">percentages = normalize(it)</span><br><span class="line"><span class="built_in">print</span>(percentages)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>出现这种状况的原因在于，迭代器只能进行一次迭代，并且迭代后不可重置。在<code>sum</code>函数中，已经对迭代器进行过一次迭代了，所以在<code>for</code>循环中由于没有数据可迭代，所以也就不会进行循环内部。</p>
<p>一种解决办法是让<code>normalize</code>函数接受另外一个函数，使它每次要使用迭代器时，都要向那个函数去索要：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normalize_func</span>(<span class="params">get_iter</span>):</span><br><span class="line">    total = <span class="built_in">sum</span>(get_iter())</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> get_iter()</span><br><span class="line">        percent = <span class="number">100</span> * value / total</span><br><span class="line">        result.append(percent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">percentages = normalize_func(<span class="keyword">lambda</span>: read_visits(<span class="string">&#x27;my_numbers.txt&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这么做虽然可行，但是每次调用<code>normalize_func</code>都需要传入一个函数，<font color="orange">更好的方法是自定义一种容器类，并让其实现迭代器协议（iterator protocol）。</font></p>
<font color="orange">Python的for循环及相关的表达式，正是按照迭代器协议来遍历容器内容的。</font>Python执行`for x in foo`这样的语句时，实际上会调用`iter(foo)`，也就是把foo传给内置的iter函数。这个函数会触发`foo.__iter__`的特殊方法，该方法必须返回一个迭代器对象（即要实现`__next__`特殊方法）。最后，Python会用迭代器对象反复调用内置的`next`函数，知道迭代完成。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadVisits</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_path</span>):</span><br><span class="line">        self.data_path = data_path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.data_data_path) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">int</span>(line)</span><br></pre></td></tr></table></figure>

我们只需要把新的容器传给最早的那个normalize函数即可，函数的代码无需修改：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visits = ReadVisits(p[<span class="number">11.538</span>, <span class="number">26.924</span>, <span class="number">61.538</span>]ath)</span><br><span class="line">percentage = normalize(visits)</span><br><span class="line"><span class="built_in">print</span>(percentages)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">11.538</span>, <span class="number">26.924</span>, <span class="number">61.538</span>]</span><br></pre></td></tr></table></figure>

# 第32条：考虑用生成器表达式改写数据量较大的列表推导

列表推导可以根据输入序列中的每个元素创建一个包含派生元素的新列表。如果输入的数据量比较小，那么这么做没有问题，但如果数据量很大，那么程序就有可能因为内存耗尽而崩溃。例如，我们要读取一份文件并返回每行的字符数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = [<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>)]</span><br></pre></td></tr></table></figure>

上面的代码有可能因为文件行数太多而导致list过长。<font color="orange">要想处理大规模的数据，可以使用生成器表达式来做，它扩展了列表推导和生成器机制。程序在对生成器表达式求值时，并不会让它把包含输出结果的那个序列立即构建出来，而是会把它当成一个迭代器，该迭代器每次可以根据表达式中的逻辑给出一个结果。</font>

<font color="orange">生成器表达式的写法与列表推导类似，只不过它是写在一对圆括号里，而不是方括号里：</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>
<p>生成器表达式还有个强大的特性，就是可以组合起来，例如，可以用刚才那条生成器表达式所形成的it迭代器作为输入，编写一条新的生成器表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roots = (x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure>
<h1 id="第33条：通过yield-from把多个生成器连起来用"><a href="#第33条：通过yield-from把多个生成器连起来用" class="headerlink" title="第33条：通过yield from把多个生成器连起来用"></a>第33条：通过yield from把多个生成器连起来用</h1><p>生成器（yield）有很多好处，能够解决很多常见的问题。生成器的用途很广，所以许多程序都会频繁使用它们，而且是一个连一个地用。</p>
<p>例如，我们要编写一个图形程序，让它在屏幕上面移动图像，从而形成动画效果。假设要实现这样一段动画：图片先快速移动一段时间，然后暂停，接下来慢速移动一段时间。我们用生成器来表示图片在当前时间段内应该保持的速度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">period, speed</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(period):</span><br><span class="line">        <span class="keyword">yield</span> speed</span><br></pre></td></tr></table></figure>
<p>为了把完整的动画制作出来，我们需要调用三次move：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">animate</span>():</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">4</span>, <span class="number">5.0</span>)</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">3</span>, <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">2</span>, <span class="number">3.0</span>)</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br></pre></td></tr></table></figure>
<p>上面这种写法的问题在于，animate函数里有很多重复的地方。比如它反复使用for结构来操作生成器，而且每个for结构都使用相同的yield表达式。为了解决这个问题，我们可以改用<code>yield from</code>形式的表达式来实现。这种形式，会先从嵌套进去的小生成器里面取值，如果该生成器已经用完，那么程序的控制流程就会回到<code>yield from</code>所在的这个函数之中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">animate</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">4</span>, <span class="number">5.0</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">3</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">2</span>, <span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<p>上面使用<code>yield from</code>的代码看上去更清晰、更直观，<font color="orange">并且这种实现方式的运行效率要更快。</font></p>
<h1 id="第34条：不要用send给生成器注入数据"><a href="#第34条：不要用send给生成器注入数据" class="headerlink" title="第34条：不要用send给生成器注入数据"></a>第34条：不要用send给生成器注入数据</h1><h1 id="第35条：不要通过throw变换生成器的状态"><a href="#第35条：不要通过throw变换生成器的状态" class="headerlink" title="第35条：不要通过throw变换生成器的状态"></a>第35条：不要通过throw变换生成器的状态</h1><font color="orange">说实话，第34条和第35条没怎么看懂，第一主要是生成器的这两个高级特性使用的场景也并不多，第二是感觉作者的代码示例也不太贴合实际场景中会写的代码。</font>

<h1 id="第36条：考虑用itertools处理迭代器与生成器"><a href="#第36条：考虑用itertools处理迭代器与生成器" class="headerlink" title="第36条：考虑用itertools处理迭代器与生成器"></a>第36条：考虑用itertools处理迭代器与生成器</h1><p>Python内置的itertools模块中有很多函数，可以用来对迭代器进行一些高级处理。下面分三大类，列出其中最重要的函数。</p>
<ul>
<li><p><strong>连接多个迭代器</strong></p>
<ul>
<li><p><code>chain</code> : 可以把多个迭代器从头连接到尾形成一个新的迭代器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it1 = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">it2 = <span class="built_in">iter</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">it3 = itertools.chain(it1, it2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>repeat</code> : 可以制作这样的一个迭代器，它会不停得输出某个值，或者通过第二个参数来控制最多能输出几次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.repeat(<span class="string">&#x27;hello&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cycle</code> : 可以制作这样的一个迭代器，它会循环地输出某段内容之中的各个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.cycle([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">result = [<span class="built_in">next</span>(it) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tee</code> : 可以让一个迭代器分裂成多个平行迭代器，具体个数由第二个参数指定。如果这些迭代器推进的速度不一样，那么程序可能要用大量内存做缓存，以存放进度落后的迭代器会用到的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it1, it2, it3 = itertools.tee([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>zip_longest</code> : 它与内置的zip函数类似（参见第8条），但区别是，如果源迭代器的长度不同，那么它会用<code>fillvalue</code>参数的值来填补提前耗尽的那些迭代器所留下的空缺。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">normal = <span class="built_in">zip</span>(keys, values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zip:&#x27;</span>, <span class="built_in">list</span>(normal))</span><br><span class="line"></span><br><span class="line">it = itertools.zip_longest(key, values, fillvalue=<span class="string">&#x27;nope&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zip_longest:&#x27;</span>, <span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">zip</span>: [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line">zip_longest: [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;nope&#x27;</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>过滤迭代器中的元素</strong></p>
<ul>
<li><p><code>islice</code> : 可以在<font color="orange">不拷贝数据</font>的前提下，按照下标切割源迭代器，这种切割方式与标准的序列切片以及步进机制类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">first_five = itertools.islice(it, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First Five:&#x27;</span>, <span class="built_in">list</span>(first_five))</span><br><span class="line"></span><br><span class="line">middle_odds = itertools.islice(it, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Middle odds:&#x27;</span>, <span class="built_in">list</span>(middle_odds))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">First five: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">Middle odds: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>takewhile</code> : 会一值从源迭代器里获取元素，直到某元素让测试函数返回False为止：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it1 = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">it2 = itertools.takewhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">7</span>, it1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dropwhile</code> : 与takewhile相反，dropwhile会一直跳过源序列里的元素，直到某元素让测试函数返回True为止，然后它会从这个地方开始逐个取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it1 = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">it2 = itertools.dropwhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">7</span>, it1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filterfalse</code> : 和内置的filter函数相反，它会逐个输出源迭代器里使得测试函数返回False的那些元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">evens = <span class="keyword">lambda</span> x : x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">filter_result = <span class="built_in">filter</span>(evens, it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Filter:&#x27;</span>, <span class="built_in">list</span>(filter_result))</span><br><span class="line"></span><br><span class="line">filter_false_result = itertools.filterfalse(evens, it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Filter false:&#x27;</span>, <span class="built_in">list</span>(filter_false_result))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Filter: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">Filter false: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>用源迭代器中的元素合成新元素</strong></p>
<ul>
<li><p><code>accumulate</code> : accumulate 会从源代码迭代器取出一个元素，并把已经累计的结果与这个元素一起传给表示累加逻辑的函数，然后输出那个函数的计算结果，并把结果当成新的累计值。<font color="orange">这与内置的functools模块中的reduce函数，实际上是一样的，只不过这个函数每次只给出一项累加值。如果调用者没有指定表示累加逻辑的函数，那么默认的逻辑就是两值相加。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">sum_reduce = itertools.accumulate(it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sum:&#x27;</span>, <span class="built_in">list</span>(sum_reduct))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_modulo_20</span>(<span class="params">first, second</span>):</span><br><span class="line">    output = first + second</span><br><span class="line">    <span class="keyword">return</span> output % <span class="number">20</span></span><br><span class="line">modulo_reduce = itertools.accumulate(it, sum_modulo_20)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Modulo:&#x27;</span> <span class="built_in">list</span>(module_reduce))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Sum: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, ]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>product</code> : 会从一个或多个源迭代器里获取元素，并计算笛卡尔积，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">single = itertools.product([<span class="number">1</span>, <span class="number">2</span>], repeat=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Single:&#x27;</span>, <span class="built_in">list</span>(single))</span><br><span class="line"></span><br><span class="line">multiple = itertools.product([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Multiple:&#x27;</span>, <span class="built_in">list</span>(multiple))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Single: [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line">Multiple: [(<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>product</code> : 会从源迭代器中能给出的全部元素，并逐个输出由其中N个元素组成的有序排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>combinations</code> : 会从源迭代器中能给出的全部元素，并逐个输出由其中N个元素组成的无序组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>combinations_with_replacement</code> : 和combination类似，但是它允许同一个元素在组合里多次出现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/02/20/program_language/python/effective_python/%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/program_language/python/effective_python/%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-20 15:14:27" itemprop="dateCreated datePublished" datetime="2022-02-20T15:14:27+08:00">2022-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-06 12:07:21" itemprop="dateModified" datetime="2022-03-06T12:07:21+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/effective-python/" itemprop="url" rel="index">
                    <span itemprop="name">effective python</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>22 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第19条：不要把函数返回的多个值拆分到三个以上的变量中"><a href="#第19条：不要把函数返回的多个值拆分到三个以上的变量中" class="headerlink" title="第19条：不要把函数返回的多个值拆分到三个以上的变量中"></a>第19条：不要把函数返回的多个值拆分到三个以上的变量中</h1><p>python的unpacking机制允许python函数返回一个以上的值，函数返回一个以上的值的时候，实际上返回的是一个元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_min_max</span>(<span class="params">numbers</span>):</span><br><span class="line">    minimum = <span class="built_in">min</span>(numbers)</span><br><span class="line">    maximum = <span class="built_in">max</span>(numbers)</span><br><span class="line">    <span class="keyword">return</span> minimum, maximum</span><br></pre></td></tr></table></figure>
<p>在返回多个值的时候，可以用带星号的表达式接收那些没有被普通变量捕获到的值（参考第13条）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_avg_ratio</span>(<span class="params">numbers</span>):</span><br><span class="line">    average = <span class="built_in">sum</span>(numbers) / <span class="built_in">len</span>(numbers)</span><br><span class="line">    scaled = [x / average <span class="keyword">for</span> x <span class="keyword">in</span> numbers]</span><br><span class="line">    scaled.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> scaled</span><br><span class="line"></span><br><span class="line">longest, *middle, shortest = get_avg_ratio(numbers)</span><br></pre></td></tr></table></figure>
<p>当我们用超过三个变量去接收函数的返回值时，会很容易出现将顺序弄错的情况。所以一般来时，一个元组最多只拆分到三个普通变量或者拆分到两个普通变量与一个万能变量（带星号的变量）。假如要拆分的值确实很多，那最好还是定义一个轻便的类或namedtuple（参见第37条），并让函数返回这样的实例。</p>
<h1 id="第20条：遇到意外状况时应该抛出异常，不要返回None"><a href="#第20条：遇到意外状况时应该抛出异常，不要返回None" class="headerlink" title="第20条：遇到意外状况时应该抛出异常，不要返回None"></a>第20条：遇到意外状况时应该抛出异常，不要返回None</h1><p>编写工具函数（utility function）时，许多python程序员都爱用None这个返回值来表示特殊情况。对于某些函数来说，这或许有几分道理。例如，我们要编写一个辅助函数计算两数相除的结果，在除数是0的情况下，返回None似乎合理，因为这种除法的结果是没有意义的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">careful_devide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">result = careful_divide(x, y)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;invalid inputs&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但是，如果传给careful_divide函数的被除数为0时，会怎么样呢？在这种情况下，只要除数不为0，函数返回的结果就应该是0。但是问题时，别人在使用这个工具函数时，在if表达式中不会明确判断返回值是否是None，而是去判断返回值是否相当于False：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="number">0</span>, <span class="number">5</span></span><br><span class="line">result = careful_divide(x, y)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;invalid inputs&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面这种if语句，会把函数返回0的情况和返回None的情况一样处理。由于这种写法经常出现在python代码里，因此，像careful_divide这样，用None来表示特殊情况的函数是很容易出错的。有两种办法可以减少这样的错误。</p>
<p>第一种，利用二元组把计算结果分成两部分返回，元组的首个元素表示操作是否成功，第二个元素表示计算的实际值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">careful_divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">success, result = careful_divide(x, y)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;invalid inputs&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但是，有些调用方总喜欢忽略元组的第一个部分。第二种方法比刚才那种更好，就是不采用None表示特例，而是向调用方抛出异常，让他们自己去处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">careful_divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid inputs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">5</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = careful_divide(x, y)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;invalid inputs&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们还可以利用类型注解指明函数返回float类型，这样就对外说明不会返回None了，但是，我们无法在函数的接口上说明函数可能抛出哪些异常，所以，我们只好把有可能抛出的异常写在文档里面，并希望调用方能够根据这份文档适当得捕获相关的异常（参见第84条）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">careful_divide</span>(<span class="params">a: <span class="built_in">float</span>, b:<span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Divides a by b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        ValueError: When the inputs cannot by divided</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid inputs&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>总结：用返回值None表示特殊情况是很容易出错的，因为这样的值在条件表达式里面没法与0、空字符串、空数组之类的值进行区分，这些值都相当于False。</p>
<p>个人觉得作者在此处使用的代码示例不是很好，这个抛出异常版本的careful_divide函数根据没啥实际用处，使用者还不如直接去捕获ZeroDivisionError，作者的目的可能只是为了简明得解释这条建议。</p>
<h1 id="第21条：了解如何在闭包里面使用外围作用域中的变量"><a href="#第21条：了解如何在闭包里面使用外围作用域中的变量" class="headerlink" title="第21条：了解如何在闭包里面使用外围作用域中的变量"></a>第21条：了解如何在闭包里面使用外围作用域中的变量</h1><p>假设，现在有一个需求，我们要给列表中的元素排序，而且要优先把在另外一个群组的元素放在其他元素的前面。实现这种做法的一种常见方案，是把辅助函数通过key参数传给列表的sort方法，让这个方法根据辅助函数返回的值来决定元素在列表中的先后顺序，辅助函数先判断当前元素是否处在重要群组里，如果在，就把返回值的第一项写成0，让它能够排在不属于这个组的那些元素之前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_priority</span>(<span class="params">values, group</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, x</span><br><span class="line"></span><br><span class="line">    values.sort(key=helper)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">priority_group = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">sort_priority(numbers, priority_group)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>在sort_priority函数中，引用了外部函数的group参数，<font color="orange">在一个内部函数中，对外部作用域的变量进行引用，那么内部函数就被认为是闭包。</font></p>
<p>假设现在需求新增，sort_priority函数还需要告诉我们，列表里面是否有位于重要群组之中，那么第一个想法就是添加一个标志位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_priority</span>(<span class="params">values, group</span>):</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, x</span><br><span class="line"></span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">priority_group = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">found = sort_priority(numbers, priority_group)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;found: &#x27;</span>, found)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">found:  <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>虽然排序结果没有问题，但是却发现标志本应该为True，但是返回的确是False。</p>
<p>在表达式中引用某个变量时，Python解释器会按照下面的顺序，在各个作用域（scope）里面查找这个变量，以解析这次引用（变量出现在<code>=</code>右边时）。</p>
<ol>
<li><p>当前函数作用域</p>
</li>
<li><p>外围作用域（例如包含当前函数的其他函数所对应的作用域）</p>
</li>
<li><p>包含当前代码的那个模块所对应的作用域（也叫全局作用域，global scope）</p>
</li>
<li><p>内置作用域（built-in scope，也就是包含len与str等函数的那个作用域）</p>
</li>
</ol>
<p>如果这些作用域中都没有定义名称相符的变量，那么程序就抛出NameError异常。</p>
<p>当对变量进行赋值时（变量出现在<code>=</code>左边），需要分两种情况处理：如果变量已经定义在当前作用域中，那么直接把新值赋给它就行了。<font color="orange">如果当前作用域中不存在这个变量，那么即使外围作用域里有同名的变量，Python也还是会把这次赋值操作当成变量的定义来处理。</font>这会产生一个重要的效果，也就是说，Python会把包含赋值操作的这个函数当作新定义的这个变量的作用域。这也就解释了为什么found还是为False。</p>
<p>这种问题有时也称为作用域bug（scoping bug），Python新手可能认为这样的赋值规则很奇怪，<font color="orange">但实际上Python是故意这么设计的，因为这样可以防止函数的局部变量污染外围模块，假设不这么做，那么函数里的每条赋值语句都有可能影响全局作用域的变量，</font>这不仅混乱，而且会让全局变量之间彼此交互影响，从而导致更多难以探查的bug。</p>
<font color="orange">Python有一种特殊的写法，可以把闭包里面的数据赋给闭包外面的变量。</font>用`nonlocal`描述变量，就可以让系统在处理针对这个变量的赋值操作时，去外围作用域查找。<font color="orange">然而，nonlocal有个限制，就是不能侵入模块级别的作用域（以防污染全局作用域）。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_priority</span>(<span class="params">values, group</span>):</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">nonlocal</span> found</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, x</span><br><span class="line"></span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">priority_group = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">found = sort_priority(numbers, priority_group)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;found: &#x27;</span>, found)</span><br></pre></td></tr></table></figure>
<p>nonlocal语句清楚地说明，我们要把数据赋给闭包之外的变量。<font color="orange">有一种跟它互补的语句，叫做global，用这种语句描述某个变量后，在给这个变量赋值时，系统会直接把它放到模块作用域中。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_global</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">to_global()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<font color="orange">我们都知道全局变量不应该滥用，其实nonlocal也是这样，除比较简单的函数外，建议不要使用nonlocal语句。</font>因为它造成的副作用有时很难发现。尤其是在那些比较长的函数里，nonlocal语句与其关联变量的赋值操作之间可能隔很远。

# 第22条：用数量可变的位置参数给函数设计清晰的参数列表

让函数接收数量可变的位置参数，可以把函数设计得更清晰（这些位置参数通常称为varargs，或者称为star args，因为我们习惯用\*args指代）。例如假设我们要记录调试信息。如果采用参数数量固定的方案来设计，那么函数应该接受一个表示信息的message参数和value列表，这个列表用于存放需要用来debug的一些变量值。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">msg, values</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;message&#125;</span>: <span class="subst">&#123;values_str&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;the numbers are&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

在调用log函数时，每次都需要传入一个列表，更好的方式是给values参数加上前缀\*，让其变量为数量可变的参数。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">msg, *values</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;message&#125;</span>: <span class="subst">&#123;values_str&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;the numbers are&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

如果想把已有序列里面的元素当成参数传给像log这样的参数个数可变的函数，那么可以在传递序列时采用\*操作符，这样Python把序列中的元素都当成位置参数传给这个函数。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">log(<span class="string">&#x27;numbers are&#x27;</span>, *numbers)</span><br></pre></td></tr></table></figure>

<font color="orange">但是，令函数接受数量可变的位置参数，可能导致两个问题。</font>第一个问题是，程序总是必须把这些参数转化为一个元组，然后才能把他们当成可选的位置参数传给函数。这意味着，在调用函数时，把带\*的操作符的生成器传了过去，那么程序必须先把这个生成器的所有元素迭代完（以便形成元组），然后才能继续往下执行（参见第30条）。这个元组包含生成器所给出的每个值，这可能耗费大量的内存，甚至会让程序崩溃。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">it = my_generator()</span><br><span class="line">my_func(*it)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">9999</span>)</span><br></pre></td></tr></table></figure>

<font color="orange">接受\*args参数的函数，适合处理输入值不太多，而且数量可以提前预估的情况。在调用这种函数时，传给\*args这一部分的应该是许多个字面值或变量名。</font>Python的这种机制主要是为了让代码写起来更方便、读起来更清晰。

第二个问题是，如果采用了\*args之后，又要给函数添加新的位置参数，那么原来的调用操作就需要全部更新。例如给log函数的参数列表开头添加新的位置参数sequence，那么原来的调用就会表现有问题。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">sequence, msg, *values</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;sequence&#125;</span> - <span class="subst">&#123;message&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;sequence&#125;</span> - <span class="subst">&#123;message&#125;</span>: <span class="subst">&#123;values_str&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;the numbers are&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">the numbers are - <span class="number">1</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<font color="orange">关键的问题是，之前的函数调用是不会报语法错误，只是行为不正常甚至是导致运行时错误。</font>这样的bug有时很难去排查。为了避免这种漏洞，在给这种\*args函数添加参数时，应该使用只能通过关键字来指定的参数（keyword-only argument，参见25条）。要是想做得更稳妥一些，可以考虑添加类型注解（参见第90条）。

# 第23条：用关键字参数来表示可选的行为

与大多数其他编程语音一样，Python运行在调用函数时，按照位置传递参数，即按照参数列表所指定的顺序依次传递参数。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remainder</span>(<span class="params">number, divisor</span>):</span><br><span class="line">    <span class="keyword">return</span> number % divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> remainder(<span class="number">20</span>, <span class="number">7</span>) == <span class="number">6</span></span><br></pre></td></tr></table></figure>

Python函数里面的所有普通参数，除了按位置传递外，还可以按关键字传递：调用函数时，在调用括号内可以把关键字的名称放在`=`左边，把参数写在右边。这种写法不在乎参数的顺序，只要把指定的所有位置参数全部传过去即可。另外，关键字形式与位置形式也可以混用，下面这四种写法效果相同：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remiander(<span class="number">20</span>, <span class="number">7</span>)</span><br><span class="line">remainder(<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(number=<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(divisor=<span class="number">7</span>, number=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<font color="orange">如果混用，那么位置参数必须出现在关键字参数之前，否则就会报错。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remainder(number=<span class="number">20</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Traceback ...</span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>
<font color="orange">每个参数只能指定一次，不能既通过位置形式指定，又通过关键字形式指定。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remainder(<span class="number">20</span>, number=<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>如果有一份字典，而且字典里面的内容能够用来调用remainder这样的函数，那么可以吧**运算符加在字典前面，这会让Python把字典里面的键值以关键字参数的形式传给函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_kwargs = &#123;</span><br><span class="line">    <span class="string">&#x27;number&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;divisor&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> remainder(**my_kwargs) == <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>调用函数时，带**操作符的参数可以和位置参数或关键字参数混用，只要不重复指定就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_kwargs = &#123;</span><br><span class="line">    <span class="string">&#x27;divisor&#x27;</span>: <span class="number">7</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> remainder(number=<span class="number">20</span>, **my_kwargs) == <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>也可以对多个字典分别施加**操作，只要这些字典所提供的参数不重叠就好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_kwargs = &#123;</span><br><span class="line">    <span class="string">&#x27;number&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">other_kwargs = &#123;</span><br><span class="line">    <span class="string">&#x27;divisor&#x27;</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> remainder(**my_kwargs, **other_kwargs) == <span class="number">6</span></span><br></pre></td></tr></table></figure>
<font color="orange">定义函数时，如果想让这个函数接受任意数量的关键字参数，那么可以在参数列表里写上万能形参\*\*kwarg，</font>它会把调用者传进来的参数集合到一个字典里面。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_parameters</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_parameters(alpha=<span class="number">1.5</span>, beta=<span class="number">9</span>, gamma=<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">alpha = <span class="number">1.5</span></span><br><span class="line">beta = <span class="number">9</span></span><br><span class="line">gamma = <span class="number">4</span></span><br></pre></td></tr></table></figure>

使用关键字参数调用函数有三个好处：

1. 用关键字参数调用函数可以让初次阅读代码的人更容易看懂

2. 它可以带有默认值，该值在定义函数时指定

3. 我们可以很灵活地扩充函数的参数，而不担心会影响原来函调用的代码

<font color="orange">对于函数中定义的非万能关键字参数，python仍然可以按照位置来传递参数</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_flow_rate</span>(<span class="params">weight_diff, time_diff, period=<span class="number">3600</span>, units_per_kg=<span class="number">2.2</span></span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">calculate_flow_rate(<span class="number">100</span>, <span class="number">20</span>, <span class="number">3600</span>, <span class="number">2.5</span>)</span><br></pre></td></tr></table></figure>
<font color="orange">通过位置来指定可选参数，可能会让读代码的人有点糊涂，所有最好是能以关键字的形式给这些参数传值，而不要按位置去传。</font>从设计函数的角度来说，还可以考虑用更加明确的方案以降低出错概率（参见25条）。

# 第24条：用None和docstring来描述默认值会变的参数

有时，我们想把那种不能够提前固定的值，当作关键字参数的默认值。例如，记录日志消息时，默认的时间应该是触发事件的那一刻。所以，如果调用者没有明确指定时间，那么就默认把调用函数的那一刻当成这条日志的记录时间。如果我们写如下代码来实现：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">msg, when=datetime.now(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;when&#125;</span>: <span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

这样写是不行的，因为`datetime.now()`只会执行一次，所有每条日志的时间戳都会相同。<font color="orange">参数的默认值只会在系统加载这个模块的时候，计算一遍，而不会在每次执行时都重新计算，这通常意味着这些默认值在程序启动后，就已经定下来了。</font>

<p>要想在Python里实现这种效果，惯用的办法是把参数的默认值设为None，同时在docstring文档里面写清楚，这个参数为None时，函数会怎么运作（参见第84条）。给函数写实现代码时，在内部对参数进行判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">msg, when=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Log a message with a timestamp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        msg: message to print</span></span><br><span class="line"><span class="string">        when: datetime of when the message occured.</span></span><br><span class="line"><span class="string">            Defaults to the present time</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> when <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        when = datetime.now()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;when&#125;</span>: <span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>把参数的默认值写成None还有个重要的意义，就是用来表示那种以后可能由调用者修改内容的默认值（例如某个可变容器）。例如，我们要写一个函数对采用JSON格式编码的数据进行解码。如果无法解码，那么就返回调用时所指定的默认结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure>
<p>这样的写法与前面的datetime.now()的例子有同样的问题，系统只会计算一次default参数（在加载这个模块时），所有每次调用这个函数时，给调用者返回的都是一开始分配的那个字段，这就相当于凡是以默认值返回来调用这个函数的代码都共用的同一份字典。这会让程序出现奇怪的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line">foo[<span class="string">&#x27;stuff&#x27;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">bar = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line">bar[<span class="string">&#x27;meep&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Foo:&#x27;</span>, foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bar:&#x27;</span>, bar)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Foo: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">Bar: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们的本意是让这两次操作得到两个不同的空白字典，但是实际上foo和bar是同一个字典。要解决这个问题，可以把默认值设置为None，而且在docstring文档里面说明，函数在这个值为None时会怎么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">data, default=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load JSON data from a string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args: </span></span><br><span class="line"><span class="string">        data: JSON data to decode</span></span><br><span class="line"><span class="string">        default: Value to return if decoding fails.</span></span><br><span class="line"><span class="string">            Defaults to an empty dictionary.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">if</span> default <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            default = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure>
<h1 id="第25条：用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"><a href="#第25条：用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表" class="headerlink" title="第25条：用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"></a>第25条：用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h1><p>按关键字传递参数是Python函数的一项强大特性，这种关键字参数特别灵活，在很多情况下，都能让我们写出一看就冬的函数代码。</p>
<p>例如，计算两数相除的结果时，可能需要仔细考虑各种特殊情况。例如在除数为0的情况下，时抛出异常还是返回无穷；在结果益处的情况下，是抛出异常还是返回0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_division</span>(<span class="params">number, divisor, </span></span><br><span class="line"><span class="params">                  ignore_overflow=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                  ignore_zero_dvision=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="keyword">return</span> number / divisor</span><br><span class="line">    <span class="keyword">except</span> OverflowError:</span><br><span class="line">        <span class="keyword">if</span> ignore_overflow:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">if</span> ignore_zero_division:</span><br><span class="line">            <span class="keyword">return</span> number * <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">result = safe_division(<span class="number">1.0</span>, <span class="number">0</span>, ignore_overflow=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>调用者可以根据自己的需要对ignore_overflow和ignore_zero_division参数进行指定，而且调用者使用关键字形式进行传递会让代码显得更清晰。<font color="orange">但是，按照上面的函数定义形式，我们没有办法要求调用者必须按照关键字形式来指定这两个参数。他们还是可以用传统的写法，按位置给safe_divison函数传递参数。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_division(number, divisor, <span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>对于这种参数比较复杂的函数，我们可以声明只能通过关键字指定的参数（keyword-only argument），这样的话，写出来的代码就能清楚地反映调用者的想法了。这种参数只能用关键字来指定，不能按位置传递。具体操作方式是使用<code>*</code>符号把参数列表分成两组，左边是位置参数，右边是只能通过关键字指定的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_division</span>(<span class="params">number, divisor, *,</span></span><br><span class="line"><span class="params">                 ignore_overflow=<span class="literal">False</span>, </span></span><br><span class="line"><span class="params">                 ignore_zero_division=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这时，如果按位置给只能用关键字指定的参数传值，那么程序就会出错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save_division(<span class="number">1.0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Traceback ...</span><br><span class="line">TypeError: save_divisoin() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
<p>但是，这样改依然还是有问题，因为在这个函数中，调用者在提供number和divisor参数时，既可以按位置提供，也可以按关键字提供，还可以把这两种方式混起来用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_division(number=<span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在未来，也许因为扩展函数的需要，甚至是因为代码风格的变化，或许要修改这两个参数的名字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_division</span>(<span class="params">numerator, denominator, *,</span></span><br><span class="line"><span class="params">                  ignore_overflow=<span class="literal">False</span>, </span></span><br><span class="line"><span class="params">                  ignore_zero_division=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这看起来只是字面上的微调，但之前所有通过关键字形式来指定这两个参数的调用代码，都会出错。其实最重要的问题在于，我们根本没有打算把number和divisor这两个名称纳入函数的接口；我们只是在编写函数时，随意挑了两个比较顺口的名称而已。</p>
<font color="orange">Python3.8引入了一项新特性，可以解决这个问题，这就是只能按位置传递的参数（positional-only argument）。</font>这种参数与刚才的只能通过关键字指定的参数相反，它们必须按位置指定，绝不能通过关键字形式指定。具体操作方式是使用`/`符号表示左边的参数只能通过位置来指定：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_division</span>(<span class="params">numerator, denominator, /, *,</span></span><br><span class="line"><span class="params">                  ignore_overflow=<span class="literal">False</span>, </span></span><br><span class="line"><span class="params">                  ignore_zero_division=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

这时候，如果调用者使用关键字形式来指定numerator和denominator参数，程序就会在运行时抛出异常。

<font color="orange">在函数的参数列表中， `/` 符号左侧的参数是只能按位置指定的参数，`*`符号右侧的参数则是只能按照关键字形式指定的参数。</font>如果`*`出现在`/`的左边，则会出现语法错误；如果有参数出现在`/`和`*`的中间，那意味着，这两个符号之间的参数，既可以按照位置提供，又可以用关键字形式指定（其实，如果不特别说明，Python函数的参数全都属于这种参数）。

# 第26条：用functools.wraps定义函数修饰器

Python中有一种特殊的写法，可以用修饰器（decorator）来封装某个函数，从而让程序在执行这个函数之前与执行这个函数之后，分别运行某些代码。这意味着，调用者传给函数的参数值、函数返回给调用者的值，以及函数抛出的异常，都可以有修饰器访问并修改，这是个很有用的机制。

假如，我们要把函数执行时收到的参数与返回的值记录下来，这在调试递归函数时是很有用的，因为我们需要知道，这个函数执行没一层递归时，输入的是什么参数，返回的是什么参数。下面我们就定义一个修饰器，在实现这个修饰器时，用\*args与\*\*kwargs表示受修饰的原函数func所收到的参数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;args!r&#125;</span>, <span class="subst">&#123;kwargs!r&#125;</span>) -&gt; <span class="subst">&#123;result!r&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

写好之后，我们用`@`符号把修饰器运用在想要调试的函数上面。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the n-th Fibonacci number&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> (fibonacci(n-<span class="number">2</span>) + fibonacci(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<font color="orange">这样写，相当于先把受修饰的函数传给修饰器，然后将修饰器所返回的值赋给原来那个函数，这样的话，如果我们继续通过原来那个名字调用函数，那么执行的就是修饰器之后的函数。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">fibonacci((<span class="number">0</span>,), &#123;&#125;) -&gt; <span class="number">0</span></span><br><span class="line">fibonacci((<span class="number">1</span>,), &#123;&#125;) -&gt; <span class="number">1</span></span><br><span class="line">fibonacci((<span class="number">2</span>,), &#123;&#125;) -&gt; <span class="number">1</span></span><br><span class="line">fibonacci((<span class="number">1</span>,), &#123;&#125;) -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这样写确实能够满足要求，但是会带来一个我们不愿意看到的副作用。使用修饰器对fibonacci函数进行修饰后，fibonacci函数的名字本质上不再是fibonacci。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(fibonacci)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;funtion trace.&lt;<span class="built_in">locals</span>&gt;.wrapper at <span class="number">0x108955dc</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这种现象解释起来并不困难。trace函数返回的，是它里面定义的wrapper函数，所以，当我们把这个返回值赋给fibonacci之后，fibonacci这个名称所表示的自然就是wrapper了。问题在于，这个可能会干扰需要利用反射机制来运作的工具。</p>
<p>例如，如果用内置的help函数来查看修饰后的fibonacci，那么打印出来的并不是我们想看的帮助文档，它本来应该打印前面定义时的那行’Return the n-th Fibonacci number文本才对’。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(fibonacci)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Help on function wrapper <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">wrapper(*args, **kwargs) </span><br></pre></td></tr></table></figure>
<p>对象序列化器也无法正常运作，因为它不能确定受修饰的那个原始函数的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">pickle.dumps(fibonacci)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Traceback ...</span><br><span class="line">AttibuteError: Can<span class="string">&#x27;t pickle local object &#x27;</span>trace.&lt;<span class="built_in">locals</span>&gt;.wrappe<span class="string">r&#x27;</span></span><br></pre></td></tr></table></figure>
<p><font color="orange">想要解决这些问题，可以改用functool内置模块之中的wraps辅助函数来实现。wraps本身也是个修饰器，它可以帮助你编写自己的修饰器。</font>把它运用到wrapper函数上面，它就会将重要的元数据全部从内部函数复制到外部函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>现在我们就可以通过help函数看到正确的文档了，对象序列化器也可以正常使用，不会抛出异常了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/02/20/DDIA/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/DDIA/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">数据复制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-20 15:13:27" itemprop="dateCreated datePublished" datetime="2022-02-20T15:13:27+08:00">2022-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-03 10:17:16" itemprop="dateModified" datetime="2022-03-03T10:17:16+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DDIA/" itemprop="url" rel="index">
                    <span itemprop="name">DDIA</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>复制主要指通过互联网络在多台机器上保存相同数据的副本，通过数据复制方案，人们通常希望达到以下目的：</p>
<ul>
<li><p>使数据在地理位置上更接近用户，从而降低访问延迟</p>
</li>
<li><p>当部分组件出现故障，系统依然可以继续工作，从而提高可用性</p>
</li>
<li><p>扩展至多台机器以同时提供数据访问服务，从而提高吞吐量</p>
</li>
</ul>
<p>本章讨论的内容都是在假设数据规模比较小，集群的每一台机器都可以保存数据集的完整副本。在接下来的第6章中，我们讨论单台机器无法容纳整个数据集的情况（即必须分区）。在后面的章节中，我们还将讨论复制过程中可能出现的各种故障，以及该如何处理这些故障。</p>
<p>如果复制的数据一成不变，那么复制就非常容易：只需将数据复制到每个节点，一次即可搞定。然而所有的技术挑战都在于处理哪些持续更改的数据，而这正是本章讨论的核心。我们将讨论是那种流行的复制变化数据的方法：主从复制、多节点复制和无主节点复制。几乎所有的分布式数据库都使用上述方法中的某一种，而三种方法各有优缺点。</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>每个保存数据库完整数据集的节点称之为副本。当有了多个副本，不可避免地会引入一些问题：如何确保所有副本之间的数据是一致的？</p>
<p>对于每一笔数据写入，所有副本都需要随之更新，否则，某些副本将出现不一致。最常见的解决方案是基于主节点的复制，也即主从复制。主从复制的工作原理如下：</p>
<ol>
<li><p>指定某一个副本为主副本（或主节点）。当客户写数据库时，必须将写请求发送给主副本</p>
</li>
<li><p>其他副本则全称为从副本（或从节点）。主副本把数据写入本地存储后，将数据更改为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志后将其应用到本地，且严格保持与主副本相同的写入顺序。</p>
</li>
<li><p>客户端从数据库中读数据时，既可以在主副本也可以在从副本上执行查询。</p>
</li>
</ol>
<p>//TODO: 贴图</p>
<p>许多关系型数据库都内置支持主从复制，例如PostgresSQL、Mysql、SQL Server。一些非关系型数据库如MongoDB、RethinkDB和Espresso也支持主从复制。另外，主从复制技术也不仅限于数据库，还广泛应用于分布式消息队列如Kafka和RabbitMQ，以及一些网络文件系统和复制块设备（如DRBD）</p>
<h2 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h2><p>复制非常重要的一个设计选项是同步复制还是异步复制。对于关系数据库系统，同步或异步通常是一个可配置的选项；而其他系统则可能是硬性指定或者只能二选一。</p>
<p>结合一个例子，假设网站用户需要更新首页的头像图片。其基本流程是，客户将更新请求发送给主节点，主节点接收到请求，接下来将数据更新转发给从节点。最后，由主节点来通知客户端更新完成。</p>
<p>TODO：//贴图</p>
<p>在上图中，从节点1的复制是同步的，即主节点需等待直到从节点1确认完成了写入，然后才会向用户报告完成，并且将最新的写入对其他客户端可见。而从节点2的复制是异步的：主节点发送完消息之后立即返回，不用等待从节点2完成确认。</p>
<p>从节点2在接收到复制日志并完成数据同步有一段延迟，通常情况下，复制速度会非常快，例如多数数据库系统可以在一秒之内完成所有从节点的更新，但是，系统其实并没有保证一定会在多长时间内完成复制。有些情况下，从节点可能落后主节点几分钟甚至更长时间，例如，由于从节点刚从故障中恢复，或者系统已经接近最大设计上限，或者节点之间的网络出现问题。</p>
<p>同步复制的优点是，一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。缺点则是，如果同步的从节点无法完成确认（例如由于从节点发生崩溃，或者网络故障，或任何其他原因），写入就不能视为成功。节点会阻塞所有的写操作，直到同步副本确认完成。</p>
<p>因此，把所有的节点都配置为同步复制有些不切实际。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。实践中，如果数据库启用了同步复制，通常意味着其中某一个从节点是同步的，而其他节点则是异步模式。万一同步的从节点变得不可用或性能下降，则将另一个异步的从节点提升为同步模型。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。这种配置有时也称为半同步。</p>
<p>主从复制还经常会被配置为全异步模式。此时如果主节点发送失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。这意味着即使向客户端确认了写操作，却无法保证数据一定会持久化存储到。但全异步配置的优点则是，不管从节点上数据多么滞后，主节点总是可以继续响应写请求，系统的吞吐性能更好。</p>
<p>全异步模式这种弱化的持久性听起来是一个非常不靠谱的折中设计，但是异步复制还是被广泛使用，特别是那些从节点数量巨大或者分布于广域地理环境。</p>
<h2 id="配置新的从节点"><a href="#配置新的从节点" class="headerlink" title="配置新的从节点"></a>配置新的从节点</h2><p>如果出现一下情况时，如需要增加副本数以提高容错能力，或者替换失败的副本，就需要考虑增加新的从节点，但如何确保新的从节点和主节点保持数据一致呢？</p>
<p>简单地将数据文件从一个节点复制到另一个节点通常是不够的，主要是因为客户端仍在不断向数据库写入新数据，数据始终处于不断变化之中，因此常规的文件拷贝方式将会导致不同节点上呈现不同时间点的数据，这不是我们所期待的。</p>
<p>或许应该考虑锁定数据库（使其不可写）来使磁盘上的文件保持一致，但这会违反高可用的设计目标，好在我们可以做到不停机、数据服务不中断的前提下完成从节点的设置。逻辑上的主要操作步骤如下：</p>
<ol>
<li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。</li>
<li>将此快照拷贝到新的从节点</li>
<li>从节点连接到主节点请求快照点所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联。</li>
<li>获取日志之后，从节点来应用这些快照点之后所有数据变更，这个步骤称之为追赶。</li>
</ol>
<p>建立新的从副本具体操作步骤可能因数据库系统而异，某些系统中，这个过程是全自动化的，而在某些系统中由于所设计的步骤、流程可能会比较复杂，甚至需要管理员手动介入。</p>
<h2 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/02/12/devops/k8s/k8s%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/devops/k8s/k8s%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">k8s初学笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-12 10:44:22" itemprop="dateCreated datePublished" datetime="2022-02-12T10:44:22+08:00">2022-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-29 16:40:50" itemprop="dateModified" datetime="2022-04-29T16:40:50+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index">
                    <span itemprop="name">k8s</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="k8s-组件"><a href="#k8s-组件" class="headerlink" title="k8s 组件"></a>k8s 组件</h1><p>一个k8s集群（cluster）由一组被称为节点（node）的机器组成，这些节点上运行k8s所管理的容器化应用，<font color="orange">一个集群至少拥有一个节点</font></p>
<p><img title src="/2022/02/12/devops/k8s/k8s%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/components-of-kubernetes.svg" alt data-align="center" width="681"></p>
<h2 id="控制面板组件"><a href="#控制面板组件" class="headerlink" title="控制面板组件"></a>控制面板组件</h2><p>控制面板组件对集群做出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的replicas时，启动新的pod）。</p>
<p>控制面板组件可以在集群中的任何节点上运行，然后，为了简单起见，通常会在同一个计算机上启动所有控制面板组件，并且不会在此计算机上运行用户容器。</p>
<h2 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h2><p>api server组件实现了Kubernetes API供外部调用</p>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>etcd是兼具一致性和高可用性的键值数据库，可以作为保存kubernetes所有集群数据的后台数据库，这个数据库是给k8s自己使用的。</p>
<h2 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h2><p>该组件负责监控新创建的、并未pods分配运行的节点。</p>
<h2 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h2><p>对控制器进行管理的组件，kubernetes有如下控制器</p>
<ul>
<li><p>节点控制器（Node Controller）：负责节点出现故障时进行通知和响应</p>
</li>
<li><p>任务控制器（Job Controller）：检测代表一次性任务的job对象，然后创建pods来运行这些任务直至这些任务运行完成</p>
</li>
<li><p>端点控制器（Endpoints Controller）: 填充端点对象（即加入service和pod）</p>
</li>
<li><p>服务账号和令牌控制器（Service Account &amp; Token Controller）：为新的命名空间创建默认账户和API访问令牌</p>
</li>
</ul>
<h2 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h2><p>云控制管理器使得你可以将你的集群连接到云服务商提供的API之上，并将与该云平台交互的组件同与你的集群交互的组件分离开来。<font color="orange">cloud-controller-manager仅运行于云平台的控制回路。如果你在自己的环境中运行kubernetes，或者在本地计算机运行学习环境，所部署的环境中不需要云控制器管理器。</font>下面的控制器包含对云平台驱动的依赖：</p>
<ul>
<li><p>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</p>
</li>
<li><p>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</p>
</li>
<li><p>服务控制器（Server Controller）：用于创建、更新和删除云服务商提供负载均衡器</p>
</li>
</ul>
<h2 id="node组件"><a href="#node组件" class="headerlink" title="node组件"></a>node组件</h2><p>节点组件用于维护运行pod并提供kubernetes运行环境</p>
<h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>一个在集群中每个节点（node）上运行的代理，它的主要任务有如下几点：</p>
<ul>
<li><p>pod管理：kubelet定期从所监听的数据源获取节点上pod/container的期望状态（运行容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态。</p>
</li>
<li><p>容器健康检查：kubelet创建了容器之后还要检查容器是否正常运行，如果容器运行出错，就要根据pod设置的重启策略进行处理</p>
</li>
<li><p>容器监控：kubelet会监控所在节点的资源使用情况，并是定时向master报告</p>
</li>
</ul>
<h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>kube-proxy是集群中每个节点（node）上运行的网络代理，kube-proxy维护节点上的网络规则（例如iptable和ipvs规则），这些网络规则允许从集群内部或外部的网络会话与pod进行网络通信。</p>
<h2 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）</h2><p>容器运行环境时负责运行容器的软件，kubernetes支持多个容器允许环境：Docker、contrainerd、CRI-O以及任何实现Kubernetes CRI（容器运行环境接口）的容器。</p>
<h1 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h1><p>kubernetes通过将容器放入在节点（Node）上运行的Pod来执行你的工作负载。<font color="orange">节点可以是一个虚拟机或者物理机器</font>。通常一个集群会有会有若干个节点。节点上的组件包括：kubelet、容器运行时以及kube-proxy。</p>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><p>一个节点的状态包含一下信息</p>
<ul>
<li><p>地址</p>
<ul>
<li><p>HostName：由节点的内核设置，可以通过kubelet的<code>--hostname-override</code>参数进行覆盖</p>
</li>
<li><p>ExternalIP：通常是节点的可从集群外访问的IP地址</p>
</li>
<li><p>InternalIP：通常是节点的仅可在集群内部访问的IP地址</p>
</li>
</ul>
</li>
<li><p>状态</p>
<ul>
<li><p>Ready：如节点是健康的并已准备好接收Pod则为True；False表示节点不健康而且不能接收Pod；Unknown表示节点控制器在最近的<code>node-monitor-grace-period</code>期间（默认40秒）没有收到节点的消息</p>
</li>
<li><p>DiskPressure：Ture表示节点存在磁盘空间压力，否则为False</p>
</li>
<li><p>MemoryPressure：Ture表示节点存在内存压力，即节点内存可用量低，否则为False</p>
</li>
<li><p>PIDPressure：True表示接单存在进程压力，即节点上进程过多，否则为False</p>
</li>
<li><p>NetworkUnavailable：True表示节点网络配置不正确，否则为False</p>
</li>
</ul>
</li>
<li><p>容量与可分配：CPU、内存和可以调度到节点上的Pod的个数上限</p>
<ul>
<li><p>capacity：标示节点拥有的资源总量</p>
</li>
<li><p>allocatable：标示节点上可供普通Pod消耗的资源量</p>
</li>
</ul>
</li>
<li><p>信息：描述节点的一般信息，如内核版本、Kubernetes版本（kubelet和kube-proxy版本）、容器运行时详细信息，已经节点使用的操作系统。kubelet从节点收集这些信息并将其发送到Kubernetes API</p>
</li>
</ul>
<h1 id="k8s-Namespace"><a href="#k8s-Namespace" class="headerlink" title="k8s Namespace"></a>k8s Namespace</h1><p>集群内的虚拟概念，类似于资源池的概念，一个资源池里可以有各种资源类型，绝大多数的资源都必须属于某一个namespace。一个集群初始化安装好后，会默认有如下几个namespace</p>
<ul>
<li><p>default</p>
</li>
<li><p>kube-node-release</p>
</li>
<li><p>kube-public</p>
</li>
<li><p>kube-system</p>
</li>
<li><p>kubenetes-dashboard</p>
</li>
</ul>
<p>可以使用<code>kubectl get namespaces</code>来获取当前有哪些命名空间。在k8s中，不是所有的资源都必须归属于一个命名空间，可以使用<code>kubectl api-resources</code>命令来查看哪些资源需要归属到一个namespace下。另外可以使用<code>kubectl create namespace xxx</code>来创建namespace。</p>
<h1 id="k8s常见的工作流程（以创建新pod为例）"><a href="#k8s常见的工作流程（以创建新pod为例）" class="headerlink" title="k8s常见的工作流程（以创建新pod为例）"></a>k8s常见的工作流程（以创建新pod为例）</h1><ol>
<li><p>用户准备一个配置文件，通过调用API向api server发起请求创建调用</p>
</li>
<li><p>api server写etcd，并将api response返回给用户 </p>
</li>
<li><p>同时scheduler持续监听api server（轮训?），获取是否有需要进行pod调度，则通过调度算法，计算出最适合该pod运行的节点，同时调用api将信息更新到etcd中</p>
</li>
<li><p>kubelet同样持续监听api server，判断是否有新的pod需要创建到本节点，如果有新pod需要创建，创建pod，并调用api将相关信息写入etcd</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/" class="post-title-link" itemprop="url">数据编码与演化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-16 22:15:28" itemprop="dateCreated datePublished" datetime="2022-01-16T22:15:28+08:00">2022-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-03 10:17:16" itemprop="dateModified" datetime="2022-03-03T10:17:16+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DDIA/" itemprop="url" rel="index">
                    <span itemprop="name">DDIA</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据编码格式"><a href="#数据编码格式" class="headerlink" title="数据编码格式"></a>数据编码格式</h1><p>一个程序通常使用两种不同的数据表示形式：</p>
<ol>
<li><p>在内存中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）</p>
</li>
<li><p>将数据写入文件或者通过网络发送时，必须将其编码为某种自包含的的字节序列（例如json文档）。由于一个进程的指针对于其他进程来说是没有意义的，所以这个字节序列会与内存中使用的数据结构不大一样</p>
</li>
</ol>
<p>因此，在这两种表示之间需要进行类型的转化。<font color="orange">从内存中的表示到字节序列的表示称为编码（或序列化），相反的过程称为解码（或反序列化）</font></p>
<h1 id="语言特定的编解码格式"><a href="#语言特定的编解码格式" class="headerlink" title="语言特定的编解码格式"></a>语言特定的编解码格式</h1><p>许多语言都内置支持将内存中的对象序列化为字节序列的工具包，例如java有<code>java.io.Serializable</code>，ruby有<code>Marshal</code>，python有<code>pickle</code>等。这些序列化反序列化库使用其他很方便，它们只需要很少的代码就可保存和恢复内存中的对象。然后也有一些问题：</p>
<ul>
<li><p>它们通常和语言绑定在一起，而使用另外一种语言时访问数据就非常困难</p>
</li>
<li><p>效率，有些编程语言的序列化反序列化工具库性能非常差，例如java</p>
</li>
</ul>
<p>由于这些原因，使用语言内置的编码方案通常不是一个好主意</p>
<h1 id="JSON、XML"><a href="#JSON、XML" class="headerlink" title="JSON、XML"></a>JSON、XML</h1><p>JSON和XML是两种被广泛支持的，可有不同编程语言编写和读取的标准化编码，虽然XML经常被批评过于冗长与不必要的复杂。</p>
<p>JSON与XML都是文本格式，因此具有不错的可读性，但是它们也有一些小问题：</p>
<ul>
<li><p>对数字的编码有很多模糊之处。在XML中，无法区分数字和数字组成的字符串。JSON区分字符串和数字，但是不区分整数和浮点数，并且不指定精度。</p>
<p>这在处理大数字时是一个问题，大于$2^{53}$的整数在IEEE 754标准中的双精度浮点数不能精确显示，所以这些数据在使用浮点数的语言（如JavaScript）中进行分析时，会得到不准确的结果。</p>
</li>
<li><p>JSON和XML对二进制数据支持得不是很好，通常的处理是将二进制数据用base64编码为文本来解决这个限制，虽然可行，但是会使数据变得混乱，而且会使二进制数据大小相对于原来增加33%左右</p>
</li>
</ul>
<font color="orange">尽管存在一些缺陷，但JSON和XML已经可用于很多应用。特别是作为数据交换格式，在某些情况下，只要人们就格式本身达成一致，格式多么美观或者高效往往不太重要。</font>

<h1 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h1><p>虽然JSON不像XML那样冗长，但是与二进制格式相比，两者仍然占用大量空间，虽然有很多JSON和XML的二进制变体（例如BSON），这些格式在一些细分领域被采用，但是没有一个像JSON和XML那样被广泛采用。另外，由于JSON和XML没有规定格式，所以需要在编码数据时包含所有的对象字段名称。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Martin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;favoriteNumber&quot;</span><span class="punctuation">:</span> <span class="number">1337</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;interests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;daydreaming&quot;</span><span class="punctuation">,</span> <span class="string">&quot;hacking&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的JSON文档中，它们必须在包含字符串userName，favoriteNumber，interest。</p>
<h2 id="Thrift和Protocol-Buffers"><a href="#Thrift和Protocol-Buffers" class="headerlink" title="Thrift和Protocol Buffers"></a>Thrift和Protocol Buffers</h2><p>Apache Thrift和Protocol Buffers是目前使用得最广泛的两种二进制编码。Protocol Buffers最初是在Google开发的，Thrift最初是在Facebook开发的，并且都是在2007~2008年开源的。</p>
<font color="orange">Thrift和Protocol Buffers都需要模式来编码任意的数据，它们都使用接口描述语言来描述模式。</font>Thrift的IDL示例：

<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="type">string</span> userName,</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> <span class="type">i64</span> favoriteNumber,</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> <span class="type">list</span>&lt;<span class="type">string</span>&gt; interests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Protocol Buffers IDL示例：

<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> user_name = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int64</span> favorte_number = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> interests = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Thrift 和 Portocol Buffers各有对应的代码生成工具，采用和上面类似的模式定义，并生成支持多种编程语言的类，应用程序可以直接调用生成的代码来编码或解码该模式的数据。

### Thrift的编码模式

Thrift有三种二进制编码格式和两种基于JSON的编码格式，这里主要讨论两种二进制的编码格式——BinaryProtocol和CompactProtocol（这两种二进制编码是跨语音的，第三种DenseProtocol只支持c++实现）。

先看看使用BinaryProtocol编码上面同格式的json数据是怎么的：

<img title src="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-2.png" alt width="471" data-align="center">

每一个字段都使用一个字节进行类型标注（用于指定它是字符串、整数、列表等），并且在需要时指定数据长度（包括字符串的长度、列表中的项数），数据中的字符串被编码成UTF-8格式的编码。<font color="orange">与JSON相比，最大的区别是没有字段名，相反，编码数据包含数字类型的字段标签（1、2和3）。</font>这些是模式定义中出现的数字，字段标签就像字段的别名，用来指示当前的字段。

上面的JSON文本编码需要占用81字节（去掉空格），而BinaryProtocol编码只需要59字节。

Thrift CompactProtocol编码在语意上等同于BinaryProtocol，它编码出来同格式的数据如下：

<img title src="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-3.png" alt width="478" data-align="center">

CompactProtocol编码出来的数据只有34字节，它通过将字段类型和字段标签打包到单个字节中，并使用可变长度整数来对数字进行编码。对数字1337，不使用全部8字节，而是使用两个字节进行编码，每字节的最高位来指示是否还有更多的字节（但是这也意味着每个字节都会失去一位有效数字，在某些情况下使用字节数还会比BinaryProtocol用得多）。

### Protocol Buffers的编码模式

Protocol Buffers只有一种二进制编码格式，对上面的JSON数据进行编码，它的结果如下：

<img title src="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-4.png" alt width="486" data-align="center">

Protocol Buffers将字段类型和字段标签打包到单个字节中，并且数字类型只有变长编码的方式，并且对于list类型的编码是通过重复类型和字段tag来实现的，这一点和thirft也不同。

## 字段标签和字段增删

在Thrift和Protocol Buffers的编码中可以看到，字段标签对编码数据的含义至关重要，<font color="orange">我们可以轻松更改模式中字段的名称，但不能随便更改字段的标签，因为编码永远不直接引用字段名称。</font>

<p>可以添加新的字段到模式，只要给每个字段一个新的标记号码。如果旧的的代码试图解析新代码编码的数据，遇到它不能识别的字段标记号码时，则它可以简单忽略该字段。</p>
<p>新代码也可以加解析旧代码编码的数据，因为之前的标记号码仍有意义，<font color="orange">唯一的要求是，如果添加一个新的字段，不能使其成为必须的字段。</font>如果将添加的字段设置为required，当新代码读取旧代码写入的数据时，则会检测失败，因为旧代码不会写入添加的required字段。</p>
<p>删除字段和添加字段一样，只不过只能删除可选的字段，不能删除必须的字段，<font color="orange">而且删除之后的字段号码，后面添加字段时，不要使用已经删除的字段号码，因为很有可能仍然有代码还在写入已经删除的字段。</font></p>
<h2 id="字段类型变动"><a href="#字段类型变动" class="headerlink" title="字段类型变动"></a>字段类型变动</h2><p>另外一个问题，是否可以改变字段的数据类型呢？<font color="orange">这是有可能的，但是会存在数据精度丢失或者数据被截断的风险。</font></p>
<h1 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h1><p>avro 是另一种二进制编码格式，它与Protocol Buffers和Thrift有着一些有趣的差异。由于Thrift不适合Hadoop的用例，因此Avro在2009年作为Hadoop的子项目而启动。</p>
<p>Avro也使用模式来指定编码的数据结构，<font color="orange">它有两种模式语音，一种Avro IDL易于人工编辑，另一种（基于JSON）更易于机器读取。</font></p>
<p>用Avro IDL示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record Person &#123;</span><br><span class="line">    string userName;</span><br><span class="line">    union &#123; null, long &#125; favoriteNumber = null;</span><br><span class="line">    array&lt;string&gt; interests;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<font color="orange">模式中没有标签编号</font>，其对应等价的JSON表示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;record&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Person&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;userName&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;favoriteNumber&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;null&quot;</span><span class="punctuation">,</span> <span class="string">&quot;long&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;interests&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;array&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用avro对之前的json数据进行编码其结果如下</p>
<p><img title src="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-5.png" alt width="494" data-align="center"></p>
<p>从上图中的字节序列中可以看出，<font color="orange">其中没有标识字段或数据类型，</font>用于标记长度的字节中的最后一位用来标记数据是否为null，编码只是由连在一起的一些列值组成。一个字符串只是一个长度前缀，后紧跟UTF-8字节流。</p>
<p>为了解析二进制数据流，需要按照定义的模式顺序遍历这些字段，然后采用模式告诉的每个字段的类型，<font color="orange">这意味着avro的编解码和模式是强相关的</font>，那么Avro是如何支持模式的演化的呢？</p>
<h2 id="写模式和读模式"><a href="#写模式和读模式" class="headerlink" title="写模式和读模式"></a>写模式和读模式</h2><p>avro在对某些数据进行编码时，它使用的模式成为写模式，反之，当arvo解码某些数据时使用的模式成为读模式。</p>
<p>avro的关键思想是，写模式和读模式不必是完全一模一样的，它们只需要保持兼容。只需要给出对应的写模式和读模式给avro，相关avro库内部会解决这种差异。</p>
<p><img title src="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-6.png" alt data-align="center" width="530"></p>
<ul>
<li><p>如果字段顺序不同，解析模式匹配字段名称即可</p>
</li>
<li><p>如果字段在写模式中有，但是在读模式中无，则忽略该字段</p>
</li>
<li><p>如果字段在读模式中有，但是在写模式中没有，则使用读模式中声明的默认值填充</p>
</li>
</ul>
<h2 id="模式演化规则"><a href="#模式演化规则" class="headerlink" title="模式演化规则"></a>模式演化规则</h2><font color="orange">为了保持兼容性，只能添加或删除具有默认值的字段。</font>如果要添加一个没有默认值的字段，新的reader将无法获取旧的writer写的数据，因此将破坏向后兼容性。如果删除没有默认值的字段，旧reader将无法读取新writer写入的数据，因此将破坏向前兼容性。

在某些编程语言中，null是所有变量可以接受的默认值，但在avro中并非如此：如果要允许字段为null，则必须使用联合类型，例如`union{ null, long, string}`字段，表示该字段可以是数字、字符串或null，<font color="orange">只有当null是联合的分支之一时，才可以使用null作为默认值（确切地说，null必须是联合的第一个可能类型）。</font>这比默认情况下所有类型都可为空显得更加冗长一些，但是通过明确什么能为null和不能为null可以帮助防止一些错误。

<font color="orange">avro对于类型转换更方便，因为编码后并不会标记字段类型，但是对于字段名称的改变会比较难处理。</font>avro可以在模式中为字段定义别名，因此旧writer模式可以和新reader的字段别名进行匹配做到向后兼容，<font color="orange">但是不能做到向前兼容。</font>

<p>对于在union类型中添加新分支也是向后兼容的，但不能向前兼容。删除union类型的分支是向前兼容的，但不能向后兼容。</p>
<h2 id="avro使用的场景"><a href="#avro使用的场景" class="headerlink" title="avro使用的场景"></a>avro使用的场景</h2><p>由于avro的编辑码需要确切的知道使用的写模式和读模式是什么，如果在每个编码数据中都包含一份写模式用于reader去解码是不太现实的，因为模式有时甚至比编码数据还要大得多，这样使用avro二进制编码所节省的空间都变得没有意义。</p>
<p>但是在一些特点的使用场景下可以避免这个问题</p>
<ul>
<li><p>有很多记录的大文件</p>
<ul>
<li>avro的一个常见用于，尤其是在Hadoop的上下文中，是用于存储包含数百万条记录的大文件，所有记录都使用相同的模式进行编码，该文件的writer可以仅在文件的开头包含writer的模式信息</li>
</ul>
</li>
<li><p>在数据库中保存写模式</p>
<ul>
<li>将写模式的变更记录在数据库中，并使用版本号进行标记。在每个编码记录的开始只需要包含一个版本号，reader根据版本号去数据库中获取到对应的写模式</li>
</ul>
</li>
<li><p>网络长连接</p>
<ul>
<li>当两个进程通过网络连接进行通信时，可以在建立连接时协商使用的模式，然后在后续的生命周期中使用该模式。这也是Avro RPC协议的基本原理。</li>
</ul>
</li>
</ul>
<h2 id="动态生成的模式"><a href="#动态生成的模式" class="headerlink" title="动态生成的模式"></a>动态生成的模式</h2><p>与Protocol Buffers和Thrift相比，Avro的一个优点是不包含任何标签号，这样的关键之处在于avro对动态生成的模式更友好。例如，假如有一个关系数据库，想把它的内容转储到一个二进制文件中，如果使用avro，可以很容易根据数据库表的关系模式来动态生成一个avro模式（一个数据表对应一个avro record，每个列成为该record中的一个字段），并使用该模式对数据库中的数据进行编码。</p>
<p>现在，假如数据库中的数据表的关系模式发生了变化，则可以动态生成新的avro模式，并使用新的avro模式来导出数据。相比之下，如果使用Thrift和Protocol Buffers，则可能必须手动分配字段标签：每次数据库模式更改时，管理员都必须手动更新从数据库名到字段标签的映射（这个部署可以通过代码来完成自动化，但是编写代码时必须非常小心，不要分配到以前使用的字段标签，尤其是删除或者增加列的情况）。</p>
<h2 id="代码生成和动态类型语言"><a href="#代码生成和动态类型语言" class="headerlink" title="代码生成和动态类型语言"></a>代码生成和动态类型语言</h2><p>Thrift和Protocol Buffers依赖于代码生成：在定义了模式之后，可以使用选择的编程语言生成实现此模式的代码。这在Java、C++等静态类型语言中很有用，因为它允许使用高效的内存结构来解码数据。</p>
<p>在动态类型编程语言中，如JavaScript、Ruby或Python，因为没有编译时类型检查，生成代码没有太多意义。代码生成在这些语言中经常被忽视。</p>
<p>Avro为静态类型编程语言提供了可选的代码生成，但是它可可以在不生成代码的情况下直接使用，入股有一个avro文件（它嵌入了writer模式信息），可以简单地使用avro库打开它，并用和查看JSON文件一样的方式查看数据，该文件也是自描述的，它包含了所有必须的元信息。</p>
<h1 id="模式的优点"><a href="#模式的优点" class="headerlink" title="模式的优点"></a>模式的优点</h1><ul>
<li><p>它们在大多数情况下比各种“二进制JSON”变体更紧凑，可以节省编码数据中的字段名称</p>
</li>
<li><p>有较好的向前和向后兼容性支持</p>
</li>
<li><p>对于静态类型编程语言来说，从模式生成代码的能力是很有用的，它能编译时进行类型检查</p>
</li>
</ul>
<h1 id="数据流模式"><a href="#数据流模式" class="headerlink" title="数据流模式"></a>数据流模式</h1><p>二进制数据流从一个进程流向另外一个进程通常有以下几种方式：</p>
<ul>
<li><p>通过数据库</p>
</li>
<li><p>通过服务调用</p>
</li>
<li><p>通过异步消息传递</p>
</li>
</ul>
<h2 id="基于数据库的数据流"><a href="#基于数据库的数据流" class="headerlink" title="基于数据库的数据流"></a>基于数据库的数据流</h2><p>在数据库中，写入数据库的进程对数据进行编码，而读取数据库的进程对数据进行编码。可能只有一个进程会方法数据库，在这种情况下，reader只有一个进程，但是这个reader可能在不同时候用不同版本的模式对数据库进行读写，例如reader用模式写入后，就进行了服务更新，之后会使用新模式来读取数据库的内容。此时向后兼容性就很重要，否则未来的自己将无法解码以前自己写的内容。</p>
<p>但是，一般而言，几个不同的进程同时访问数据库是很常见的。这些进程可能是几个不同的服务，也可能是一个服务的几个实例。无论哪种情况，访问数据库的进程可能某些运行着较新的代码，而其他运行着较旧的代码。这意味着既有可能数据库中的值由较旧的代码写入，较新的代码进行读取，又有可能由较新的代码写入，较旧的代码读取，所以向前和向后的兼容性都很重要。</p>
<p>另外，还存在一个问题，假设在记录模式中添加了一个字段，并且较新的代码将该新字段的值写入数据库，随后，旧版本的代码（尚不知道该新字段）将其读取、更新记录并写回数据库，在这种情况下，理想的行为通常是旧代码保持新字段不变，即使它无法解释。<font color="orange">之前讨论的编码格式支持未知字段的保存，但是有时候还需要注意应用层面的影响，例如，如果将数据库中的值解码为应用程序中的对象，然后重新编码这些模型对象，则在转换过程中可能会丢失未知字段，在编写代码的时候要有这方面的意识</font></p>
<p><img title src="/2022/01/16/DDIA/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-7.png" alt width="543" data-align="center"></p>
<h3 id="不同时间写入不同的值"><a href="#不同时间写入不同的值" class="headerlink" title="不同时间写入不同的值"></a>不同时间写入不同的值</h3><p>数据库通常支持在任何时候写入，这意味着在单个数据库中，可能有一些值是在5ms前写入的，而有些值可能是在5年前写入的。</p>
<p>部署新版本的服务应用程序时，可以在几分钟内用新版本完全替换旧版本。但是数据库内容的情况并不是这样的：将旧数据重写（迁移）为新模式当然是可能的，但在大型数据集上执行此操作代价不菲，因此很多数据库都进可能避免此操作。大多数关系数据库允许进行简单的模式更改，例如添加具有默认值为空的新列，而不重写现有数据。读取旧行时，数据库会为磁盘上编码数据缺失的所有列填充为空值。因此，模式演化支持整个数据库看起来像是采用了单个模式编码，即使底层存储可能包含各个版本模式所编码的记录。</p>
<h3 id="归档存储"><a href="#归档存储" class="headerlink" title="归档存储"></a>归档存储</h3><p>有些时候我们会不时地为数据库创建快照，例如用于备份或加载到数据仓库，在这种情况下，数据转储通常使用最新的编码模式进行编码，即使源数据库中的数据包含了不同时代的各种模式版本。由于无论如何都要复制数据，所以此时最好对数据副本进行统一编码。</p>
<font color="orange">由于数据转储时一次写入的，而且以后可能不可改变，因此像arvo这样的编码格式非常适合。</font>

<h2 id="基于服务的数据流：REST和RPC"><a href="#基于服务的数据流：REST和RPC" class="headerlink" title="基于服务的数据流：REST和RPC"></a>基于服务的数据流：REST和RPC</h2><h2 id="网络http服务"><a href="#网络http服务" class="headerlink" title="网络http服务"></a>网络http服务</h2><p>http服务有两种流行的服务方法：REST和SOAP，它们在设计理念方面几乎式截然相反的。</p>
<p>REST不是一种协议，而是一个基于HTTP原则的设计理念，它强调简单的数据格式，使用URL来标识资源，并使用HTTP功能进行缓存控、身份验证和内容类型协商。与SOAP相比，REST已经越来越受欢迎，根据REST原则所设计的API称为RESTful。</p>
<p>相比之下，SOAP是一种基于XML的协议，用于发送网络API请求，虽然它最长用与HTTP，但其目的是独立于HTTP，并避免使用大多数HTTP功能，相反，它带有庞大而复杂的多种相关标准和新增的各种功能，SOAP Web服务的API使用被称为WSDL（Web Service Description Language，一种基于XML的语言）。WSDL支持代码生成，客户端可以使用本地类和方法调用（编码为XML消息并由框架进行解码）来访问远程服务。</p>
<p>由于WSDL的设计目标不是人类可读的，而且SOAP消息通常过于复杂，无法手动构建，SOAP用户严重依赖工具支持、代码生成和IDE。对于没有SOAP提供商支持的编程语言用户来说，试图集成SOAP服务非常困难。由于这些原因，尽管它在某些大型企业中仍有使用，但是已经不再收到大多数小公司的青睐。</p>
<h2 id="远程过程调用RPC"><a href="#远程过程调用RPC" class="headerlink" title="远程过程调用RPC"></a>远程过程调用RPC</h2><p>远程过程调用的思想从20世纪70年代以来就一直存在。RPC模式试图使向远程网络发送请求看起来与在同一进程调用编程语言中的函数或方法相同。<font color="orange">虽然RPC起初看起来很方便，但是这种方法在根本上是有缺陷的，网络请求与本地函数调用非常不同：</font></p>
<ul>
<li><p>本地函数调用是可预测的，并且成功或失败仅取决于参数的控制。网络请求是不可预测的：请求或响应可能有由于网络问题而丢失，或者远程计算机可能速度慢或不可用，这些问题完全不在控制范围之内，网络问题很常见，因此必须有所准备，例如重试失败的请求。</p>
</li>
<li><p>本地函数调用要门返回一个结果，要么抛出一个异常，或者永远不会返回（因为进入无限循环或者进程崩溃）。网络请求有另外一个可能的结果：由于超时，它返回时可能没有结果。在这种情况下，根本不知道发生了什么：如果没有接收到来自远程服务的响应，无法直到请求是否成功</p>
</li>
</ul>
<ul>
<li><p>当你重试失败的网络请求时，可能发生请求实际上通过，但是只有响应丢失的情况，在这种情况下，重试将导致该操作被执行多次，除非操作是幂等的。</p>
</li>
<li><p>每次调用本地功能时，通常需要大致相同的时间来执行，网络请求比函数调用要慢很多，而且其延迟会随着网络环境和机器负载而波动</p>
</li>
<li><p>调用本地函数时，可以高效地将引用（指针）传递给本地内存中的对象。当你发出一个网络请求时，所有这些参数都需要被编码成可以通过网络发送的一系列字节。</p>
</li>
<li><p>客户端和服务可以用不同的编程语音实现，所以RPC框架必须将数据从一种语音翻译成另外一种语音，这样可能会出问题，因为不是所有的语音都具有相同的数据类型（例如JavaScript数字大于$2^{53}$的问题）。</p>
</li>
<li><p><font color="orange">所有这些因素意味着尝试使远程服务看起来像编程语音中的本地函数调用一样是毫无意义的，因为这是两个根本不同的事情。</font>REST的部分吸引力在于，它并不试图隐藏它是一个网络协议的事实。</p>
</li>
</ul>
<h2 id="RPC的当前方向"><a href="#RPC的当前方向" class="headerlink" title="RPC的当前方向"></a>RPC的当前方向</h2><p>尽管有这样那样的问题，RPC不会消失：thrift和Avro带有RPC支持，gRPC是使用Protocol Buffers的RPC实现。</p>
<font color="orange">新一代的RPC框架更加明确的是，远程请求与本地函数调用不同。</font>例如，gPRC支持流，其中一个调用不仅包括一个请求和一个响应，还可以是随时间的一系列请求和响应。

由于REST具有方便实验和调试（只需使用web浏览器或者命令行工具curl，无需任何代码生成或软件安装即可发送请求），能被所有主流的编程语音和平台所支持，还有大量可用的工具的生态系统（服务器、缓存、负载均衡、代理、防火墙、监控、调试和测试工具），<font color="orange">REST已经成为公共API的主要风格，RPC的主要重点在于同一组织内部服务器之间的请求。</font>

<h2 id="RPC数据编码的演化"><a href="#RPC数据编码的演化" class="headerlink" title="RPC数据编码的演化"></a>RPC数据编码的演化</h2><p>对于RPC可演化性，关注的是可以独立更改和部署RPC客户端和服务器。与通过数据库流动的数据相比，一般来说都是所有的服务器先进行更新，其次再是客户端进行更新。所以RPC数据编码的演化需要考虑的是在请求上具有向后兼容性（服务器端对还未更新的客户端发来的请求可以识别并处理），并在响应上具有向前兼容（未更新的客户端对已经完成更新的服务端返回的响应也能够处理）。</p>
<h1 id="异步消息传递中的数据流"><a href="#异步消息传递中的数据流" class="headerlink" title="异步消息传递中的数据流"></a>异步消息传递中的数据流</h1><p>进程间异步消息的传递通常是通过消息代理（消息队列）实现的，与直接RPC相比，使用消息代理有几个优点：</p>
<ul>
<li><p>如果接受消息的进程不可用或过载，消息代理可以充当消息代理，从而提供系统的可靠性。</p>
</li>
<li><p>避免消息发送的进程需要知道接收进程的IP地址和端口号</p>
</li>
<li><p>它允许将一条消息广播给多个接收方</p>
</li>
<li><p>将消息发送方和接收方进行解耦</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwordAndTea"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SwordAndTea" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SwordAndTea" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">183k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">10:11</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
