<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="SwordAndTea&#39;s Blog">
<meta property="og:url" content="http://swordandtea.github.io/page/2/index.html">
<meta property="og:site_name" content="SwordAndTea&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SwordAndTea">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>SwordAndTea's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SwordAndTea's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/19/others/pytest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/others/pytest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">pytest学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-19 14:55:29" itemprop="dateCreated datePublished" datetime="2020-11-19T14:55:29+08:00">2020-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-26 15:07:30" itemprop="dateModified" datetime="2021-01-26T15:07:30+08:00">2021-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pytest/" itemprop="url" rel="index">
                    <span itemprop="name">pytest</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装pytest时，直接使用pip安装就可以了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure>
<h1 id="pytest辨认测试文件和测试函数"><a href="#pytest辨认测试文件和测试函数" class="headerlink" title="pytest辨认测试文件和测试函数"></a>pytest辨认测试文件和测试函数</h1><p>如果运行pytest没有指定文件的话，pytest会将所有形式为”test_*.py”或者”*_test.py”的文件运行。</p>
<p>另外，pytest要求测试函数必须以”test”开头，并且不能通过其他方式在代码中显示指定哪些函数是需要被pytest测试的测试函数。</p>
<h1 id="第一个测试程序"><a href="#第一个测试程序" class="headerlink" title="第一个测试程序"></a>第一个测试程序</h1><p>在项目目录下新建一个叫做”test_first.py”的文件，文件的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sqrt</span>():</span></span><br><span class="line">    num = <span class="number">25</span></span><br><span class="line">    <span class="keyword">assert</span> math.sqrt(num) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testsqure</span>():</span></span><br><span class="line">    num = <span class="number">7</span></span><br><span class="line">    <span class="keyword">assert</span> num * num == <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tesequlity</span>():</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">10</span> == <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>之后，<strong>在命令行中</strong>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>
<p>之后pytest就会开始运行单元测试，并产生测试报告。注意到，第三个函数不是以test开头的函数，所以pytest将不会对第三个函数进行测试。</p>
<p>使用”-v”（verbose）参数可以打印更多的信息。</p>
<h1 id="pytest选择执行文件"><a href="#pytest选择执行文件" class="headerlink" title="pytest选择执行文件"></a>pytest选择执行文件</h1><p>在上例的基础上，再创建一个名叫”test_second.py”的文件，文件的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_greater</span>():</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   <span class="keyword">assert</span> num &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_greater_equal</span>():</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   <span class="keyword">assert</span> num &gt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_less</span>():</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   <span class="keyword">assert</span> num &lt; <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>此时，如果执行执行”pytest”命令，pytest将对test_first.py和test_second.py中的函数都进行测试。</p>
<p>如果只想对”test_scond.py”文件进行测试，可以执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_second.py</span><br></pre></td></tr></table></figure>
<h1 id="指定测试函数搜索名称"><a href="#指定测试函数搜索名称" class="headerlink" title="指定测试函数搜索名称"></a>指定测试函数搜索名称</h1><p>在pytest命令中，可以使用”-k”参数指定关键字过滤，pytest只会测试那些含有关键字的函数。<font color="red">注意，即使指定了关键字，仍然要求函数以test开头</font>，否则即使有关键字也不会对该函数进行测试。例如在文件中有函数的名称为”keyword”，即使使用命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -k keyword</span><br></pre></td></tr></table></figure>
<p>pytest也不会对”keyword”这个函数进行测试。</p>
<h1 id="将测试函数分组"><a href="#将测试函数分组" class="headerlink" title="将测试函数分组"></a>将测试函数分组</h1><p>pytest运行用户对测试函数使用”marker”，”marker”可以给测试函数添加多种特性，mark本质上是一个函数装饰器。pytest自身提供了一些内建的”marker”，另外用户也可以自定义”marker”。marker在代码中的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.mark.&lt;markname&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_xxxx</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在测试时，可以对pytest命令添加”-m”参数来指定marker，pytest将只会运行有相同marker标记的测试函数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -m &lt;markname&gt;</span><br></pre></td></tr></table></figure>
<font color="red">注意函数名仍然需要以test起始。</font>



<h1 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h1><p>Fixture是一个自定义的函数，这个函数在每个测试函数被执行前，都会执行一遍这个fixture函数。fixture函数通常可以用来给测试函数提供数据源，例如从数据库获取数据等。</p>
<p>声明一个Fixture函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_value</span>():</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>使用Fixture函数：在测试函数中使用fixture函数，需要将fixture函数的函数名作为输入参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_input</span>(<span class="params">input_value</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> input_value % <span class="number">3</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="conftest-py"><a href="#conftest-py" class="headerlink" title="conftest.py"></a>conftest.py</h1><p>conftest.py在使用了pytest的项目中是一个特殊的文件，我们可以在这个文件中定义fixture函数，而在其他所有测试函数中使用定义的fixture函数，并且不必在代码中显示地import这个文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#in conftest.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_value</span>():</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#in other test file</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_input</span>(<span class="params">input_value</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> input_value % <span class="number">3</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="Parameterizing-Tests"><a href="#Parameterizing-Tests" class="headerlink" title="Parameterizing Tests"></a>Parameterizing Tests</h1><p>Parameterizing Tests可以给测试函数指定多个输入参数的值，直接看例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;num&quot;</span>, <span class="string">&quot;output&quot;</span>, [(<span class="params"><span class="number">1</span>, <span class="number">11</span></span>), (<span class="params"><span class="number">2</span>, <span class="number">22</span></span>), (<span class="params"><span class="number">3</span>,<span class="number">35</span></span>), (<span class="params"><span class="number">4</span>, <span class="number">44</span></span>)]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_multiplication_11</span>(<span class="params">num, output</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> num * <span class="number">11</span> == output</span><br></pre></td></tr></table></figure>
<h1 id="Xfail-Skip-Tests"><a href="#Xfail-Skip-Tests" class="headerlink" title="Xfail/Skip Tests"></a>Xfail/Skip Tests</h1><p>使用xfail “marker”标记的测试函数，会被pytest执行，但是不会进入pytest的统计，即使测试函数失败了也不会被打印出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.mark.xfail</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_something</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>使用skip “marker”标记的测试函数，不会被pytest执行。</p>
<h1 id="指定N个测试失败后结束测试"><a href="#指定N个测试失败后结束测试" class="headerlink" title="指定N个测试失败后结束测试"></a>指定N个测试失败后结束测试</h1><p>可以在pytest命令中使用”—maxfail”参数来指定测试多少个函数失败后就停止测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --maxfail=3</span><br></pre></td></tr></table></figure>
<p>一般在测试用例较多，测试时间较长时使用。</p>
<h1 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h1><p>默认情况下，pytest是串行运行测试函数的，当测试函数数量较多时，可能需要并行运行测试函数。要并行运行测试函数，需要下载pytest-xdist插件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-xdist</span><br></pre></td></tr></table></figure>
<p>现在可以使用 pytest -n \<num\>来指定并行度</num\></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -n 3</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/11/hight_performance_linux_coding/IO%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/hight_performance_linux_coding/IO%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">IO复用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-11 10:07:54" itemprop="dateCreated datePublished" datetime="2020-11-11T10:07:54+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-20 10:09:18" itemprop="dateModified" datetime="2021-01-20T10:09:18+08:00">2021-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Select系统调用"><a href="#Select系统调用" class="headerlink" title="Select系统调用"></a>Select系统调用</h1><p>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p>
<p>select系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>nfds参数指定被监听的文件描述符的总数。<font color="red">它通常被设置为select监听的所有文件描述符中的最大值加1</font>因为文件描述符是从0开始计数的。</li>
<li>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。应用程序调用select函数时，通过这三个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。fd_set结构体仅包含一个整型数组，该数组的<font color="red">每个</font>元素的<font color="red">每一位bit</font>标记一个文件描述符。</li>
<li>timeout参数用来设置select函数的超时时间。它是一个timeval结构类型的指针，<font color="red">采用指针参数是因为内核将修改它以告诉应用程序select等待了多久</font>。不过我们不能完全信任select调用返回后的timeout值，比如调用失败时timeout值是不确定的。<font color="red">如果给timeout参数传递NULL，则select将一直阻塞，直到某个文件描述符就绪</font>。</li>
</ul>
<p>select成功时返回就绪(可读、可写和异常)文件描述符的总数。如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno为EINTR。</p>
<p>如果觉得自己手动使用位操作去处理fd_set，可以使用下面的一系列宏和函数来访问fd_set结构体中的位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line">FD_ZERO(fd_set *fdset);	<span class="comment">/*清零fdset的所有位*/</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *fdset);	<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *fdset);	<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure>
<h2 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h2><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。在网络编程中，下列情况可认为socket可读：</p>
<ul>
<li>socket内核接受缓冲区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</li>
<li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li>
<li>监听scoket上有新的连接请求。</li>
<li>socket上有未处理的错误，此时我们可以使用getsockopt来读取和清除错误。</li>
</ul>
<p>下列情况下socket可写：</p>
<ul>
<li>socket内核发送缓存区中的可用字节数小于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</li>
<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li>
<li>socket上有未处理的错误。此时我们可以使用getsocketopt来读取和清除该错误。</li>
</ul>
<p>网络程序中，select能处理的异常情况只有一种：socket上接受到带外数据。</p>
<p>下面是使用select函数处理socket带外数据的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in sockAddress&#123;&#125;;</span><br><span class="line">    sockAddress.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;sockAddress.sin_addr);</span><br><span class="line">    sockAddress.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockFD = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;create socket fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sockFD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockFD, (sockaddr *)&amp;sockAddress, <span class="keyword">sizeof</span>(sockAddress));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket bind fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = listen(sockFD, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket listen fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sockaddr_in clientSock&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientSockLen;</span><br><span class="line">    <span class="keyword">int</span> clientSockFD = accept(sockFD, (sockaddr *)&amp;clientSock, &amp;clientSockLen);</span><br><span class="line">    <span class="keyword">if</span> (clientSockFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket accept fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> clientSockFD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    fd_set  read_fds;</span><br><span class="line">    fd_set exception_fds;</span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">/*每次调用select 前都要重新在read_fds和exception_fds中设置文件描述符clientSockFD，因为事件发生之后，文件描述符集合将被内核修改*/</span></span><br><span class="line">        FD_SET(clientSockFD, &amp;read_fds);</span><br><span class="line">        FD_SET(clientSockFD, &amp;exception_fds);</span><br><span class="line">        ret = select(clientSockFD + <span class="number">1</span>, &amp;read_fds, <span class="literal">nullptr</span>, &amp;exception_fds, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;select fail &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*对于可读事件，采用普通的recv函数读取数据*/</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(clientSockFD, &amp;read_fds)) &#123;</span><br><span class="line">            ret = recv(clientSockFD, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot; bytes of normal data: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(clientSockFD, &amp;exception_fds)) &#123;</span><br><span class="line">            <span class="comment">/*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/</span></span><br><span class="line">            ret = recv(clientSockFD, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot; bytes of oob data: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(clientSockFD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="poll-系统调用"><a href="#poll-系统调用" class="headerlink" title="poll 系统调用"></a>poll 系统调用</h1><p>poll系统调用和select类似，也是在指定时间内轮训一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。</li>
<li>nfds指定被监听事件的fds的数量。它本质是一个整数。</li>
<li>timeout参数指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</li>
</ul>
<p>poll调用的返回值的含义与select相同。</p>
<p>poll函数的第一个参数使用的pollfd结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;					<span class="comment">/*文件描述符*/</span></span><br><span class="line">  <span class="keyword">short</span> events;		<span class="comment">/*注册的事件*/</span></span><br><span class="line">  <span class="keyword">short</span> revents;	<span class="comment">/*实际发生的事件，由内核补充*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fd指定文件描述符</li>
<li>events告诉poll监听fd上的那些事件，他是一系列事件的<font color="red">按位或</font></li>
<li>revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件</li>
</ul>
<p>poll 支持的事件类型如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">是否可作为输入</th>
<th style="text-align:center">是否可作为输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POLLIN</td>
<td style="text-align:center">数据可读（包括普通数据和优先数据）</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLRDNORM</td>
<td style="text-align:center">普通数据可读</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLRDBAND</td>
<td style="text-align:center">优先级带数据可读（Linux不支持）</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLPRI</td>
<td style="text-align:center">高优先级数据可读，比如TCP带外数据</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLOUT</td>
<td style="text-align:center">数据（包括普通数据和优先数据）可写</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLWRNORM</td>
<td style="text-align:center">普通数据可写</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLWRBAND</td>
<td style="text-align:center">优先级带数据可写</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLRDHUP</td>
<td style="text-align:center">TCP连接被对方关闭，或者对方关闭了写操作，它由GNU引入</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLERR</td>
<td style="text-align:center">错误</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLHUP</td>
<td style="text-align:center">挂起。比如管道的写端被关闭后，读端描述符上将收到POLLHUP事件</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">POLLNVAL</td>
<td style="text-align:center">文件描述符没有打开</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
</div>
<h1 id="epoll系统调用"><a href="#epoll系统调用" class="headerlink" title="epoll系统调用"></a>epoll系统调用</h1><h2 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h2><font color="red">epoll是Linux特有的I/O复用函数。</font>它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中。从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。<font color="red">但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用epoll_create函数来创建：</font>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>size<font color="red">参数现在并不起作用</font>，只是给内核一个提示。告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指要访问的内核事件表。</li>
</ul>
<p>下面的函数可以用来操作epoll的内核事件表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>epfd为epoll_create返回的事件表文件描述符</li>
<li>fd为要操作的文件描述符</li>
<li>op指定操作类型，操作类型有如下3种<ul>
<li>EPOLL_CTL_ADD 往事件表中注册fd上的事件</li>
<li>EPOLL_CTL_MOD 修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL 删除fd上对的注册事件</li>
</ul>
</li>
<li>event 参数指定事件，它是epoll_event结构体指针类型。</li>
</ul>
<p>epoll_event结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;	<span class="comment">/* epoll事件 */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;	<span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>event 成员描述事件类型。epoll支持的事件类型和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上”E”。但epoll有<font color="red">两个额外的</font>事件类型——EPOLLET和EPOLLONESHOT，它们对于epoll的高效运作非常关键，这两个事件将在后面讨论。</p>
</li>
<li><p>data成员用于存储用户数据，其类型epoll_data_t的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>epoll_data_t是一个union，其四个成员中使用最多的是fd，它指定事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数据。<font color="orange">但由于epoll_data_t是一个union，我们不能同时使用ptr和fd成员</font>，因此如果要将文件描述符和用户数据关联起来，只能使用其他手段，<font color="orange">比如放弃使用epoll_data_t的fd成员，而在ptr指向的用户数据中包含fd。</font></p>
</li>
</ul>
<p>epoll_ctl成功时返回0，失败时返回-1并设置errno。</p>
<h2 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h2><p>epoll的一系列系统调用的主要接口时epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>timeout参数指定超时时间，单位为毫秒</li>
<li>maxevents参数指定最多监听多少个事件，它必须大于0</li>
<li>events参数，如果epoll_wait函数检测到事件，就将所有就绪的事件从内核事件表中复制到它events指向的数组中。这个数组<font color="red">只用于输出</font>epoll_wait检测到的就绪事件，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检查到的就绪事件。</li>
<li>epfd参数指定内核事件表的文件描述符</li>
</ul>
<h2 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h2><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。<font color="red">LT模式是默认的工作模式，</font>这种模式下epoll相对于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。<font color="red">ET模式时epoll的高效工作模式。</font></p>
<p>对于采用<code>LT</code>工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理事件。<font color="orange">这样当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</font></p>
<p>而对于采用<code>ET</code>工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<font color="orange">应用程序必须立即处理该事件，因为后续epoll_wait调用将不再向应用程序通知这一事件。</font>可见，ET模式在很大程度上降低了epoll事件被重复触发的次数，因此<font color="red">效率要比LT模式高。</font></p>
<h3 id="LT和ET模式下对事件的不同处理方式"><a href="#LT和ET模式下对事件的不同处理方式" class="headerlink" title="LT和ET模式下对事件的不同处理方式"></a>LT和ET模式下对事件的不同处理方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Bytedance-Wall Flower on 2021/1/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUM 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorEventForFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setNonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt_mode</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> listen_fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sock_fd == listen_fd) &#123;</span><br><span class="line">            sockaddr_in client_socket_addr&#123;&#125;;</span><br><span class="line">            <span class="keyword">socklen_t</span> sock_len;</span><br><span class="line">            <span class="keyword">int</span> conn_fd = accept(listen_fd, (sockaddr *)&amp;client_socket_addr, &amp;sock_len);</span><br><span class="line">            monitorEventForFd(epoll_fd, conn_fd, <span class="literal">false</span>); <span class="comment">//使用ET模式监听客户端socket fd</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<span class="comment">//客户端socket fd有数据可读</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client socket fd %d is readable\n&quot;</span>, sock_fd);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">int</span> ret = recv(sock_fd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                close(sock_fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sock fd %d get %d bytes of content: %s\n&quot;</span>, sock_fd, ret, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other event happen in le mode\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et_mode</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> listen_fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sock_fd == listen_fd) &#123;</span><br><span class="line">            sockaddr_in client_socket_addr&#123;&#125;;</span><br><span class="line">            <span class="keyword">socklen_t</span> sock_len;</span><br><span class="line">            <span class="keyword">int</span> conn_fd = accept(listen_fd, (sockaddr *)&amp;client_socket_addr, &amp;sock_len);</span><br><span class="line">            monitorEventForFd(epoll_fd, conn_fd, <span class="literal">true</span>); <span class="comment">//使用ET模式监听客户端socket fd</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client socket fd %d is readable\n&quot;</span>, sock_fd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环读，直到无数据可读</span></span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="keyword">int</span> ret = recv(sock_fd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                        <span class="comment">//对于非阻塞io，下面的条件成立表示数据已经全部读取完毕，</span></span><br><span class="line">                        <span class="comment">//此后epoll 就能再次触发该sock fd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    close(sock_fd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sock_fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sock fd %d get %d bytes of content: %s\n&quot;</span>, sock_fd, ret, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other event happen in et mode\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    server_sock_addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(server_fd, (sockaddr *)&amp;server_sock_addr, <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    epoll_event events[MAX_EVENT_NUM];</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    monitorEventForFd(epoll_fd, server_fd, <span class="literal">true</span>);<span class="comment">//monitor server socket fd use et mode</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUM, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll wait fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lt_mode(events, ret, epoll_fd, server_fd); <span class="comment">//LT mode to process client connection</span></span><br><span class="line"><span class="comment">//        et_mode(events, ret, epoll_fd, server_fd);//ET mode to process client connection</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="orange">注意在ET模式下，当客户端socket有数据可读的时候，需要使用循环一次性把所有数据读完。</font>



<h2 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h2><p>即使使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有数据可读(EPOLLIN再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。这当然不是我们期望的。<font color="orange">我们期望的时一个socket连接在任一时刻都只被一个线程处理。</font>这一点可以使用epoll的EPOLLONESHOT事件实现。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，<font color="orange">除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件</font>。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。<font color="red">但是，反过来，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件</font>，以确保这个socket下一次可读时，其他EPOLLIN事件能被触发。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUM 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FDPair</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd;</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line">&#125; FDPair;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNonBlocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorEventForFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> target_fd, <span class="keyword">bool</span> enable_one_shot)</span> </span>&#123;</span><br><span class="line">    epoll_event event&#123;&#125;;</span><br><span class="line">    event.data.fd = target_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="keyword">if</span> (enable_one_shot) &#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, target_fd, &amp;event);</span><br><span class="line">    setNonBlocking(target_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetOneShot</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> target_fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重置target fd上的事件，这样操作之后，</span></span><br><span class="line">    <span class="comment">//尽管target fd上的EPOLLONESHOT事件被注册，但是操作系统仍然会触发target fd上的EPOLLIN事件，且只触发一次</span></span><br><span class="line">    epoll_event event&#123;&#125;;</span><br><span class="line">    event.data.fd = target_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_MOD, target_fd, &amp;event);<span class="comment">//注意这里的操作是modify</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端socket的工作线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *<span class="built_in">pair</span> = (FDPair *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, <span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = recv(<span class="built_in">pair</span>-&gt;sock_fd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            close(<span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foreigner closed the connection\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//errno是线程安全的，不用担心</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                resetOneShot(<span class="built_in">pair</span>-&gt;epoll_fd, <span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get content: %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="comment">//休眠3s，模拟数据处理过程</span></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on socket fd: %d\n&quot;</span>, <span class="built_in">pair</span>-&gt;sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    server_sock_addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(server_fd, (sockaddr *)&amp;server_sock_addr, <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    epoll_event events[MAX_EVENT_NUM];</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//注意，监听server fd是不能注册EPOLLONESHOT事件的，</span></span><br><span class="line">    <span class="comment">//否则应用程序只能处理一个客户连接，因为后续的客户连接请求将不再触发server_fd上的EPOLLIN事件</span></span><br><span class="line">    monitorEventForFd(epoll_fd, server_fd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> event_count = epoll_wait(epoll_fd, events, MAX_EVENT_NUM, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll wait fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; event_count; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sock_fd == server_fd) &#123;</span><br><span class="line">                sockaddr_in client_sock_addr&#123;&#125;;</span><br><span class="line">                <span class="keyword">socklen_t</span> sock_len;</span><br><span class="line">                <span class="keyword">int</span> client_sock_fd = accept(server_fd, (sockaddr *)&amp;client_sock_addr, &amp;sock_len);</span><br><span class="line">                monitorEventForFd(epoll_fd, client_sock_fd, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">                <span class="keyword">pthread_t</span> thread_handler;</span><br><span class="line">                FDPair <span class="built_in">pair</span>&#123;&#125;;</span><br><span class="line">                <span class="built_in">pair</span>.epoll_fd = epoll_fd;</span><br><span class="line">                <span class="built_in">pair</span>.sock_fd = sock_fd;</span><br><span class="line">                pthread_create(&amp;thread_handler, <span class="literal">nullptr</span>, worker, &amp;<span class="built_in">pair</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;other event happen\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="orange">注意在工作线程中，处理完一次client socket fd上的数据后，需要重置该client socket fd</font>



<h1 id="三个I-O复用函数的比较"><a href="#三个I-O复用函数的比较" class="headerlink" title="三个I/O复用函数的比较"></a>三个I/O复用函数的比较</h1><ul>
<li>每次select和poll调用都返回整个用户注册的事件集合（所有注册的fd，不论是就绪的还是未就绪的），所以应用程序检索就绪文件描述符的时间复杂度为O(n)。而epoll_wait返回的events参数仅用来返回就绪事件，这使得应用程序索引就绪文件描述符的事件复杂度减少到O(1)。</li>
<li>poll和epoll_wait分别使用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能到达系统允许打开的最大文件描述符数目。而select允许监听的最大文件描述符数量通常有限制。虽然用户可以修改这个限制，但这可能导致不可预期的后果。</li>
<li>从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法时间复杂度为O(n)。而epoll_wait采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将就绪事件队列中的内容拷贝到用户空间。因此epoll_wati的算法时间复杂度为O(1)。<font color="red">但是，当活动连接比较多的时候，epoll_wati的效率未必比select和poll高</font>，因为此时回调函数被触发得过于频繁。<font color="red">所以epoll_wait适用于连接数量多，但是活动连接较少的情况</font></li>
</ul>
<h1 id="I-O复用的高级应用一：非阻塞connect"><a href="#I-O复用的高级应用一：非阻塞connect" class="headerlink" title="I/O复用的高级应用一：非阻塞connect"></a>I/O复用的高级应用一：非阻塞connect</h1><p>对于非阻塞的socket调用connect，而连接又没有立即建立时，这个时候，connect会设置errno值为EINPROGRESS。这个时候对于非阻塞的socket，我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码为0，表示连接成功建立，否则连接失败。<font color="red">非阻塞connect的应用：可以同时发起多个连接并一起等待。</font></p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Bytedance-Wall Flower on 2021/1/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNonBlocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nonblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    sockaddr_in server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    server_sock_addr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> old_option =  setNonBlocking(sock_fd);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(sock_fd, (sockaddr *)&amp;server_sock_addr, <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果连接成功，则恢复sock fd的属性</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">        fcntl(sock_fd, F_SETFL, old_option);</span><br><span class="line">        <span class="keyword">return</span> sock_fd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">        <span class="comment">//只有当errno是EINPROGRESS时才表示连接还在进行，</span></span><br><span class="line">        fd_set write_fds;</span><br><span class="line">        timeval select_timeout&#123;&#125;;</span><br><span class="line">        FD_ZERO(&amp;write_fds);</span><br><span class="line">        FD_SET(sock_fd, &amp;write_fds);</span><br><span class="line">        select_timeout.tv_sec = timeout;</span><br><span class="line">        ret = select(sock_fd + <span class="number">1</span>, <span class="literal">nullptr</span>, &amp;write_fds, <span class="literal">nullptr</span>, &amp;select_timeout);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;select timeout\n&quot;</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!FD_ISSET(sock_fd, &amp;write_fds)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no write events on sock fd: %d\n&quot;</span>, sock_fd);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> error_in_sock_fd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">socklen_t</span> error_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">if</span> (getsockopt(sock_fd, SOL_SOCKET, SO_ERROR, &amp;error_in_sock_fd, &amp;error_len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (error_in_sock_fd != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//错误不为0，表示连接出错</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error: %d\n&quot;</span>, error_in_sock_fd);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//连接成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket: %d\n&quot;</span>, sock_fd);</span><br><span class="line">            fcntl(sock_fd, F_SETFL, old_option);<span class="comment">//重置为原来的属性</span></span><br><span class="line">            <span class="keyword">return</span> sock_fd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果连接没有立即建立，连接又不还在进行，出错返回</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;non-block connect unsupported\n&quot;</span>);</span><br><span class="line">        close(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = nonblock_connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *data = <span class="string">&quot;data from client !!!&quot;</span>;</span><br><span class="line">    send(sock_fd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">注意，上面的代码有平台移植的问题：</font>

<ul>
<li>首先，非阻塞的socket可能导致connect始终失败。</li>
<li>其次，select对处于EINPROGRESS状态下的socket可能不起作用</li>
<li>对于出错的socket，getsockopt在有些系统（比如Linux）上返回-1，而在有些系统（比如BSD）上则返回0。</li>
</ul>
<p>这些问题没有一个统一的解决方法，可能需要针对不同的平台使用宏来分别判断。</p>
<h1 id="I-O复用高级应用二：简单聊天室程序"><a href="#I-O复用高级应用二：简单聊天室程序" class="headerlink" title="I/O复用高级应用二：简单聊天室程序"></a>I/O复用高级应用二：简单聊天室程序</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/08/kafka_preliminary/kafka%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/kafka_preliminary/kafka%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">kafka基本操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-08 14:27:32 / Modified: 16:31:48" itemprop="dateCreated datePublished" datetime="2020-11-08T14:27:32+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h1><p>kafka的运行需要java环境和zookeeper，所以需要先下载好jdk和zookeeper，然后启动zookeeper server。详细操作可以参考<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/apache_kafka/apache_kafka_installation_steps.html">这里</a></p>
<p>启动一个kafka server(broker)的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<p>该命令需要传递一个kafka server配置文件的路径，使用默认的配置即可。</p>
<h1 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h1><p>kafka提供了一个名为”kafka-topics.sh”的脚本，用于在kafka server上创建topic，在命令行输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 </span><br><span class="line">--partitions 1 --topic hello-kafka</span><br></pre></td></tr></table></figure>
<p>该命令创建了一个叫做hello-kafka的topic。</p>
<p>创建topic后，也可以使用这个脚本获取服务器中的主题列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>
<h1 id="启动生产者以发送消息"><a href="#启动生产者以发送消息" class="headerlink" title="启动生产者以发送消息"></a>启动生产者以发送消息</h1><p>kafka提供一个kafka-console-producer.sh的脚步用于启动一个producer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name</span><br></pre></td></tr></table></figure>
<p>这个脚步需要两个参数，一个是kafka server(broker)的ip和端口，另外一个参数就是主题的名称。</p>
<p>启动producer后，脚本会从stdin获取输入，然后发送到kafka集群中。默认情况下，每个新行都作为新消息发布，可以在config/producer.properties文件中配置producer的一些属性。</p>
<h1 id="启动消费者以接收消息"><a href="#启动消费者以接收消息" class="headerlink" title="启动消费者以接收消息"></a>启动消费者以接收消息</h1><p>kafka也提供了一个Kafka-console-consumer.sh脚本来启动一个消费者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic-name</span><br></pre></td></tr></table></figure>
<h1 id="单节点多代理配置"><a href="#单节点多代理配置" class="headerlink" title="单节点多代理配置"></a>单节点多代理配置</h1><p>之前的基本操作的说明都是在单节点(一台物理机器)-单代理(一个kafka broker)下的场景下的，现在说明如何在一台物理机上启动多个Kafka server(broker)。</p>
<p>首先需要启动zookeeper服务器，然后由于需要启动多个kafka broker，需要为每个broker创建一个配置文件，可以将config/server.properties文件复制多份，并重新命令为config/server-one.properties，config/server-two.properties，注意需要修改配置文件中的port字段，让broker监听不同的端口。broker默认监听的端口是9092。</p>
<p>在多代理下可以对一个partition创建副本，可以使用Kafka-topics.sh脚本的”—describe”参数来检查哪个broker是partition的leader：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic topic-name</span><br></pre></td></tr></table></figure>
<p><code>在单节点多代理下创建生产者和消费者的方式和在单节点单代理的场景下相同</code>。</p>
<h1 id="修改已有主题的配置"><a href="#修改已有主题的配置" class="headerlink" title="修改已有主题的配置"></a>修改已有主题的配置</h1><p>修改主题使用Kafka-topics.sh脚本来完成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh —zookeeper localhost:2181 --alter --topic topic-name </span><br><span class="line">--partitions count</span><br></pre></td></tr></table></figure>
<p>这个命令可以修改topic-name的分区数量和备份数量。</p>
<h1 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic topic-name</span><br></pre></td></tr></table></figure>
<p>注意，如果配置delete.topic.enable为false，则delete操作不会生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/08/kafka_preliminary/kafka%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/kafka_preliminary/kafka%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">kafka基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-08 10:33:19" itemprop="dateCreated datePublished" datetime="2020-11-08T10:33:19+08:00">2020-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-09 10:54:22" itemprop="dateModified" datetime="2020-11-09T10:54:22+08:00">2020-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kafka简介"><a href="#kafka简介" class="headerlink" title="kafka简介"></a>kafka简介</h1><p>Apache Kafka 是一个分布式发布 - 订阅消息系统和一个强大的消息队列中间件，可以处理大量的数据。 <code>Kafka使用文件存储消息并且会将消息保留在磁盘上</code>，同时在群集内复制以防止数据丢失。 Kafka 构建在 ZooKeeper 同步服务之上。 它与 Apache Storm 和 Spark 非常好地集成，用于实时流式数据分析。</p>
<p>kafka内相关术语：</p>
<ul>
<li>生产者和消费者：消息的发送者叫producer，消息的使用者和接受者叫consumer，生产者将数据保存到kafka集群中，消费者从中获取消息进行业务的处理。</li>
<li>broker：kafka集群中有很多台服务器，其中每一台服务器都可以存储消息，将每台服务器称为一个kafka实例，也叫做broker。</li>
<li>主题（topic）：一个topic表示同一类消息，相当于对消息进行分类，每个producer将消息发送到kafka中，都需要指定消息的topic是哪个，也就是指明这个消息属于哪一类。</li>
<li>分区（partition）：每个topic都可以分成多个partition，每个partition在kafka中其实就是一个文件，任何发布到此partition的消息都会被直接追加到log文件的尾部。<code>为什么对topic进行分区呢</code>：最根本的原因就是kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上线，因此，采用分区的办法，一个分区对应一个文件，这样就可以将数据分别存储到不同的服务器上，另外这样可以做负载均衡，容纳更多的消费者。<code>生产者将消息发送到kafka中时，可以不指定partition，由kafka来决定的分配到那个partition，也可以自己指定partition</code>。</li>
<li>偏移量（offset）：一个分区对应一个磁盘上的文件，而消息在文件中的位置就称为offset，offset是一个long型数字，它可以唯一标记一条消息。由于kafka并没有提供其他额外的索引机制来存储offset，<code>kafka中文件只能顺序地读写，所以在kafka中几乎不允许对消息进行随机读写</code>。</li>
</ul>
<p>综上，总结一下kafka有几个要点：</p>
<ul>
<li>kafka 是一个基于发布-订阅的<code>分布式</code>消息系统（消息队列）</li>
<li>kafak 的消息数据保存在磁盘，每个 partition 对应磁盘上的一个文件，消息写入就是简单的文件追加，文件可以在集群内复制备份以防丢失</li>
<li><code>即使消息被消费，kafka 也不会立即删除该消息</code>，可以通过配置使得过一段时间后自动删除以释放磁盘空间</li>
<li>kafka依赖分布式协调服务Zookeeper，适合离线/在线信息的消费，与storm和saprk等实时流式数据分析常常结合使用</li>
</ul>
<h1 id="kafka基本原理"><a href="#kafka基本原理" class="headerlink" title="kafka基本原理"></a>kafka基本原理</h1><h2 id="分布式和分区"><a href="#分布式和分区" class="headerlink" title="分布式和分区"></a>分布式和分区</h2><p>kafka的分布式和分区总结来说就是：一个topic对应的多个partition分散地存储在集群中的多个broker上，存储的方式是一个partition对应一个文件，每个broker负责存储在自己机器上的partition中的消息读写。</p>
<h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><p>kafka可以配置partition需要备份的个数（replicas），每个partition会被备份到多台机器上，以提高可用性，备份的数量可以通过配置文件指定。 </p>
<p>kakfa对同一partition的多个备份的管理和调度策略是：在每个partition的所有备份中选举一个最为“leader”，由leader负责处理消息的读写，其他partition作为follower只需要简单地与leader进行同步数据即可。如果原来的leader失效，会重新选举其他的folloer来成为新的leader。</p>
<p>至于如果选取leader，这正是Zookeeper所擅长的，kafka使用ZK在broker中选出一个Controller，用于partition分配和Leader选举。</p>
<p>另外，作为leader的服务器承担了该分区所有的读写请求，因此其压力是比较大的，而且，有多少个partition就意味着会有多少个leader，，kafka会将leader分散到不同的broker上，确保整体的负载均衡。</p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>ISR的全称是in-sync replica，翻译过来就是与leader保持同步的replica集合。虽然kafka可以为一个partition配置N个replica，但是这不意味着该partition可以容忍N-1个replica失效而不丢失数据。</p>
<p>Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保持同步状态。只有这个集合中的replica才能被选举为leader，也只有该集合中所有replica都接收到了同一条消息，kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功。</p>
<p>正常情况下，partition的所有replica（含leader replica）都应该与leader replica保持同步，即所有replica都在ISR中。因为各种各样的原因，一小部分replica开始落后于leader replica的进度。当滞后到一定程度时，Kafka会将这些replica“踢”出ISR。相反地，当这些replica重新“追上”了leader的进度时，那么Kafka会将它们加回到ISR中。<code>这一切都是自动维护的，不需要用户进行人工干预</code>，因而在保证了消息交付语义的同时还简化了用户的操作成本。</p>
<h1 id="数据生产流程"><a href="#数据生产流程" class="headerlink" title="数据生产流程"></a>数据生产流程</h1><p>对于生产者要写入一条记录，可以指定四个参数，分别是topic，partition， key和value，其中topic和value是必须指定的，而key和partition是可选的。</p>
<p>对于一条记录，<code>先对其进行序列化</code>，然后按照topic和partition，放进对应的发送队列中，如果partition没有指定，那么会根据以下情况来决定发送到哪个partition：</p>
<ul>
<li>key有指定，按照key进行hash，相同的key去同一个partition。</li>
<li>key没有指定，Round-Robin来选partition。</li>
</ul>
<p><code>producer将会和topic下所有partition leader保持socket连接，消息由producer直接通过socket发送到broker。其中partition leader的位置（ip : port）注册在zookeeper中，producer作为zookeeper client，以及注册了watch用来监听partition leader的变更事件，因此，可以准确的知道谁是当前的leader</code>。</p>
<p>另外，producer端采用异步发送：<code>将多条消息暂且在客户端中buffer起来</code>，并将它们批量的发送到broker，小数据IO太多，会拖慢整体的网络延迟，批量延迟发送提升了网络效率。</p>
<h1 id="数据消费过程"><a href="#数据消费过程" class="headerlink" title="数据消费过程"></a>数据消费过程</h1><p>对于消费者，不是以单独的形式存在的，<code>每一个消费者都属于一个consumer group</code>，可为每个Consumer指定group name，若不指定group name则属于默认的group，一个consumer group包含多个consumer。特别需要注意的是：<code>订阅Topic是以一个消费组来订阅的</code>，发送到topic的消息，只会被订阅了此topic的每个group中的<code>一个</code>consumer消费。一个topic可以被多个组订阅。</p>
<p>具体来说，是根据partition来分的，一个partition，只能被消费组里的一个消费者消费，但是可以同时被多个消费组消费，消费组里的每个消费者是关联到一个partition的，因此有这样的说法，对于同一个topic，同一个group中不能有多于partition个数的consumer，否则将会存在一些consumer无法得到消息。</p>
<p><code>在kafka，consumer采用pull方式获取消息</code>，即consumer在和broker建立连接后，主动去pull消息，这样consumer可以根据自己的消费能去适当的获取消息并处理，且可以控制消费消息的进度。</p>
<p>另外partition中不存在消息状态的控制，也没有消息确认机制。当消息被consumer接收之后，需要保存Offset记录消费到哪，以前保存在ZK中，由于ZK的写性能不好，在0.10版本后，kafka把这个offset的保存从ZK中剥离，保存在一个名叫”consumeroffsets topic”的topic中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/hight_performance_linux_coding/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">高性能服务器程序框架</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 17:22:12" itemprop="dateCreated datePublished" datetime="2020-11-06T17:22:12+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-08 18:28:53" itemprop="dateModified" datetime="2021-01-08T18:28:53+08:00">2021-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h1><h2 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h2><h2 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h2><h1 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h1><h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><p>I/O模型分为两种，阻塞和非阻塞，阻塞I/O执行的系统调用可能因为无法立即完成而被挂起，直到等待的事件发生为止。而非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。</p>
<h1 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h1><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>Reactor模型下，主线程只负责监听是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作。读写数据，以及处理客户请求均在工作线程中完成。</p>
<h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/hight_performance_linux_coding/Linux%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">Linux服务程序规范</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 17:03:43" itemprop="dateCreated datePublished" datetime="2020-11-06T17:03:43+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-08 18:28:46" itemprop="dateModified" datetime="2021-01-08T18:28:46+08:00">2021-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h2><p>在linux中提供一个守护进程来处理系统日志——syslogd，不过现在的linux系统上使用的都是它的升级版——rsyslogd。</p>
<p>rsyslogd守护进程既能接受用户进程输出的日志，又能接收内核日志。用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件/dev/log中，rsyslogd进程则监听该文件以获取用户进程的输出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/hight_performance_linux_coding/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">高级I/O函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 16:41:24" itemprop="dateCreated datePublished" datetime="2020-11-06T16:41:24+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 14:52:30" itemprop="dateModified" datetime="2021-01-15T14:52:30+08:00">2021-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h1><p>pipe函数可用于创建一个管道，以实现进程间通信（例如父子进程间通信）。pipe函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>pipe函数的参数是一个包含两个int型整数的数字指针，是作结果输出的参数。<font color="red">该函数成功时返回0</font>，并将一对打开的文件描述符值填入其参数指向的数组。<font color="red">如果失败，则返回-1，并设置errno。</font></p>
<p>通过pipe函数创建的这两个文件描述符fd[0]，fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出，并且，<font color="red">fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用，如果要实现双向的数据传输，就应该使用两个管道。</font></p>
<p>另外，<font color="red">默认情况下，这一对文件描述符都是阻塞的</font>。如果我们用<code>read</code>系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读，如果我们用write系统调用来读取一个空的管道，则<code>read</code>将被阻塞，同理如果用<code>write</code>系统调用来往一个满的管道中写入数据，则<code>write</code>也将被阻塞，直到管道有足够多的空闲空间可用。</p>
<p>如果管道的写端文件描述符fd[1]的引用计数减少至0，即没有任何进程需要往管道中写入数据，则针对管道的读端文件描述符fd[0]的read操作将返回0，即读取到了文件结束标记(End of File, EOF)；反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对管道的写端文件描述符fd[1]的write操作将失败，并引发<code>SIGPIPE</code>信号。</p>
<p>管道内传输的数据是字节流，<font color="red">管道本身有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少个字节的数据。</font>自Linux2.6.11内核起，管道容量的大小默认是65536字节。我们可以使用<code>fcntl</code>函数来修改管道容量。</p>
<p>其实shell命令中的管道操作的实现也是通过pipe函数来实现的。</p>
<p>pipe的实现原理，其实是在操作系统内核中开辟了一个缓冲区（位于内存），然后让返回的两个文件描述符都指向这个内核缓存区，然后设置一个文件描述符只能读，一个文件描述符只能写。写pipe时需要将数据从用户空间拷贝到内核缓冲区，读数据时需要将数据从内核缓冲区拷贝到用户空间。</p>
<font color="red">pipe只能用在两个有亲缘关系的进程上，例如父子进程；如果要在两个没有关系的进程上用管道通信，需要使用fifo命名管道，FiFo命名管道利用了磁盘文件。</font>



<h1 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h1><p>有时候我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接，这可以通过下面的用于复制文件描述符的dup或者dup2函数来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(inf fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd_one, <span class="keyword">int</span> fd_two)</span></span>;</span><br></pre></td></tr></table></figure>
<p>dup函数创建一个新的文件描述符，该文件描述符和原有文件描述符fd指向相同的文件、管道或者网络连接。<code>并且dup返回的文件描述符总是取系统当前可用的最小整数值</code>。dup2和dup类型，不过它将返回第一个<font color="red">不小于（大于等于）</font>fd_two的整数值。dup和dup2系统调用失败时返回-1并设置errno。</p>
<p>利用dup函数实现将标准输出重定向到一个网络连接中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in sockAddress&#123;&#125;;</span><br><span class="line">    sockAddress.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;sockAddress.sin_addr);</span><br><span class="line">    sockAddress.sin_port = htons(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sockFD = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;create socket fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sockFD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockFD, (sockaddr *)&amp;sockAddress, <span class="keyword">sizeof</span>(sockAddress));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket bind fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = listen(sockFD, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket listen fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    sockaddr_in clientSock&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientSockLen;</span><br><span class="line">    <span class="keyword">int</span> clientSockFD = accept(sockFD, (sockaddr *)&amp;clientSock, &amp;clientSockLen);</span><br><span class="line">    <span class="keyword">if</span> (clientSockFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket accept fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> clientSockFD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        <span class="keyword">int</span> newFd = dup(clientSockFD);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new fd is equal to std out fd: &quot;</span> &lt;&lt; (newFd == STDOUT_FILENO) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is direct from std out&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        close(clientSockFD);</span><br><span class="line">        close(newFd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockFD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h1><p>readv函数将数据从磁盘读到分散的内存块中，即分散读；wirtev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。它们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovect* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>struct iovect用来描述一块内存区，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *iov_base; <span class="comment">//内存起始地址</span></span><br><span class="line">  <span class="keyword">size_t</span> iov_len; <span class="comment">//这块内存长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h1><p>sendfile函数在两个文件描述符之间直接传递数据（<code>完全在内核中操作</code>），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为<code>零拷贝</code>。sendfile函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>in_fd参数是待读出内容的文件描述符</li>
<li>out_fd参数是待写入内容的文件描述符</li>
<li>offset参数指定从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置</li>
<li>count参数指定在文件描述符in_fd和out_fd之间传输的字节数</li>
</ul>
<p>sendfile成功时返回传输的字节数。失败则返回-1并设置errno。</p>
<font color="red">sendfile函数有一个限制：in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket管道；而out_fd则必须是一个socket。</font>由此可见，sendfile几乎是专门为在网络上传输文件而设计的。



# mmap、munmap、msync函数

mmap函数用于申请一段内存空间。`我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中`。munmap函数则释放由mmap创建的这段内存空间。它们定义如下：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>



* start参数允许用户使用某个特定的地址作为这段内存的起始地址，如果它被设置为NULL，则系统自动分配一个地址。
* length参数指定内存段的长度。
* prot参数用来设置内存段的访问权限。它可以取以下几个值的按位或
  * PROT_READ，内存段可读
  * PROT_WRITE，内存段可写
  * PROT_EXEC，内存段可执行
  * PROT_NONE，内存段不能被访问
* flags参数控制内存段内容被修改后程序的行为。它的`常用`取值可以是如下这些值的按位或
  * MAP_SHARED，在进程间共享这段内存，对该内存段的修改将反映到被映射的文件中
  * MAP_PRIVATE，内存段为调用进程所私有，对该段内存的修改不会反映到被映射的文件中
  * MAP_ANONYMOUS，这段内存不是从文件映射来的。其内容被初始化为全0。这种情况下，mmap函数的最后两个参数将被忽略
  * MAP_FIXED，内存段必须位于start参数指定的地址处，<font color="red">start必须是内存页面大小(4096字节)的整数倍</font>，考虑到可移植性，addr 通常设为 NULL ，不指定 MAP_FIXED
  * MAP_HUGETLB，按照“大内存页面”来分配内存空间，“大内存页面”的大小可通过/proc/meminfo文件来查看
* fd参数是被映射文件对应的文件描述符。它一般通过open系统调用来获得
* offset参数设置从文件的何处开始映射

mmap函数成功时返回指向目标内存区域的指针，失败则返回MAP_FAILED，并设置errno。munmap函数成功时返回0，失败时返回-1并设置errno。`当 mmap 成功返回时,fd 就可以关闭，这并不影响创建的映射区。`



`进程退出的时候,映射区会自动删除`。不过当不再需要映射区时，可以调用 munmap 显式删除。当映射区删除后，后续对映射区的引用会生成 SIGSEGV 信号。



文件一旦被映射后，调用mmap()的进程对返回地址的访问是对某一内存区域的访问，暂时脱离了磁盘上文件的影响。所有对mmap()返回的地址空间的操作只在内存中有意义。并且只有在调用了munmap()后或者msync()时，才把内存中的相应内容写回磁盘文件。



## linux内存映射mmap原理

在调用mmap函数的时候，实际上只是创建并初始化了相关的结构体，这个结构体中记录了从`逻辑地址`到磁盘空间的映射，`此时并没有发生任何磁盘数据的传输`。

当使用mmap返回的逻辑地址对数据进行访问时，操作系统将逻辑地址转换为物理地址，如果发现页表项中没有对应的物理页时，此时就会根据mmap建立的映射关系，从磁盘中间对应数据加载到物理页中，`这个物理页是属于用户空间的物理页`



`为什么使用mmap会比使用普通的read/write快？`先看看使用普通的read/write的过程，当使用read/write函数从某个fd上读取数据时，操作系统首先从磁盘将数据加载到属于内核的`物理地址`中，然后需要将这些数据从属于内核的`物理地址`拷贝到属于用户空间的`物理地址`中，此时才会在用户空间中获取到这些数据。这个过程经过了两次数据拷贝的过程。而使用mmap，会直接把数据从磁盘中拷贝到属于用户的物理空间中，只经过了一次数据拷贝的操作。



# splice函数

splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。splice函数的定义如下：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span>* off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

* fd_in参数是需要读数据的文件描述符。
* off_in表示从输入数据流的何处开始读取数据，如果fd_in是一个管道文件描述符，那么off_in参数必须被设置为NULL，表示从输入数据流的当前偏移位置开始读取数据。
* fd_out表示需要写数据的文件描述符。
* off_out表示从何处开始写数据，如果fd_out是一个管道文件描述符，那么off_out参数必须设置为NULL，表示从当前偏移位置开始写数据。
* len参数表示需要拷贝数据的长度
* flags参数控制数据如何移动，它可以被设置为下列这些值的按位或
  * SPLICE_F_MOVE：如果合适的话，按整页内存移动数据。这只是给内核一个提示。不过，因为它的实现存在BUG，自内核2.6.21后，它实际上没有任何效果。
  * SPLICE_F_NONBLOCK：非阻塞的splice操作，<font color="red">但实际效果还会受文件描述符本身的阻塞状态的影响</font>
  * SPLICE_F_MORE：给内核一个提示：后续的splice调用将读取更多的数据
  * SPLICE_F_GIFT：对splice没有效果



<font color="red">使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符，但因为管道文件有大小限制，所以splice函数一次移动太多数据可能会导致长时间阻塞</font>



<h1 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h1><p><code>tee</code>函数在两个<font color="red">管道</font>文件描述符之间复制数据，也是零拷贝操作。<font color="red">它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。</font><code>tee</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">int</span> fd_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>tee</code>函数的参数的含义和<code>splice</code>函数相同，只不过fd_in和fd_out必须都是管道文件描述符。</p>
<h1 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h1><p>fcntl函数，正如其名字（file control）描述的那样，提供了对文件描述符的各种控制操作。另外一个常见的控制文件描述符属性和行为的系统调用是ioctl，而且ioctl比fcntl能够执行更多的操作。但是，对于控制文件描述符常用的属性和行为，fcntl函数是有POSIX规范指定的首选方法。fcntl函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd参数是被操作的文件描述符，cmd参数指定执行何种类型的操纵。根据操作类型的不同，该函数可能还需要第三个可选参数<code>arg</code>。fcnt函数支持的常用操作及其参数如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作分类</th>
<th style="text-align:center">操纵</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">第三个参数类型</th>
<th style="text-align:center">成功时的返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复制文件描述</td>
<td style="text-align:center">F_DUPFD</td>
<td style="text-align:center">创建一个新的文件描述符，其值大于或等于arg</td>
<td style="text-align:center">long</td>
<td style="text-align:center">新创建的文件描述符的值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_DUPFD_CLOEXEC</td>
<td style="text-align:center">于F_DUPFD相似，不过在创建文件描述符的同时，设置其close-on-exec表示</td>
<td style="text-align:center">long</td>
<td style="text-align:center">新创建的文件描述符的值</td>
</tr>
<tr>
<td style="text-align:center">获取和设置文件描述符的标志</td>
<td style="text-align:center">F_GETFD</td>
<td style="text-align:center">获取fd的标志，比如说close-on-exec</td>
<td style="text-align:center">无</td>
<td style="text-align:center">fd的标志</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_SETFD</td>
<td style="text-align:center">设置fd的标志</td>
<td style="text-align:center">long</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">获取和设置文件描述符的状态标志</td>
<td style="text-align:center">F_GETFL</td>
<td style="text-align:center">获取fd的状态标志，这些标志包括由open系统调用设置的标志（O_APPEND、O_CREAT等）和访问模式（O_RDONLY、O_WRONLY和O_RDWR）</td>
<td style="text-align:center">void</td>
<td style="text-align:center">fd的状态标志</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_SETFL</td>
<td style="text-align:center">设置文件的状体标志，但部分标志是不能被修改的（比如访问模式标志）</td>
<td style="text-align:center">long</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">管理信号</td>
<td style="text-align:center">F_GETOWN</td>
<td style="text-align:center">获得SIGIO和SIGURG信号的宿主进程的PID或进程组的组ID</td>
<td style="text-align:center">无</td>
<td style="text-align:center">信号的宿主进程的PID或进程组的组ID</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_SETOWN</td>
<td style="text-align:center">设定SIGIO和SIGURG信号的宿主进程的PID或者进程组的组ID</td>
<td style="text-align:center">long</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_GETSIG</td>
<td style="text-align:center">获取当应用程序被通知fd可读可写时，是那个信号通知该事件的</td>
<td style="text-align:center">无</td>
<td style="text-align:center">信号值，0表示SIGIO</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_SETSIG</td>
<td style="text-align:center">设置当fd可读或可写时，系统应该触发哪个信号来通知应用程序</td>
<td style="text-align:center">long</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">操作管道容量</td>
<td style="text-align:center">F_SETPIPE_SZ</td>
<td style="text-align:center">设置由fd指定的管道的容量，/proc/sys/fs/pipe-size-max内核参数指定了fcntl能设置的管道容量的上限。</td>
<td style="text-align:center">long</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">F_GETPIPE_SZ</td>
<td style="text-align:center">获取由fd指定的管道的容量</td>
<td style="text-align:center">无</td>
<td style="text-align:center">管道容量</td>
</tr>
</tbody>
</table>
</div>
<p>在网络编程中，fcntl函数通常用来将一个socket文件描述符设置为非阻塞的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">  <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">  fcntl(fd, F_SETFL, new_option);</span><br><span class="line">  <span class="keyword">return</span> old_option;<span class="comment">/*返回文件描述符旧的状态标志，方便之后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">此外，SIGIO和SIGURG这两个信号与其他Linux信号不同，他们必须与某个文件描述符相关联才能使用</font>，当被关联的文件描述符可读或可写时，系统将触发SIGIIO信号，当被关联的文件描述符（而且必须是一个socket）上有带外数据可读时，系统将触发SIGURG信号，<font color="red">将信号和文件描述符关联的方法，就是使用fcntl函数为目标文件描述符指定宿主进程或进程组，那么被指定的宿主进程或进程组将捕获这两个信号。</font>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/" class="post-title-link" itemprop="url">Linux网络编程基础API</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 11:04:29" itemprop="dateCreated datePublished" datetime="2020-11-06T11:04:29+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 14:51:55" itemprop="dateModified" datetime="2021-01-15T14:51:55+08:00">2021-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h1><p>字节序分为大端字节序和小端字节序。现代PC大多采用小端字节序，<code>因此小端字节序又称为主机字节序</code>。</p>
<p>当两台字节序不同的主机之间进行通信时，由于字节序的不同就会导致对数据的错误解释。但是接受端也不知道发送端发送过来的数据的字节序到底是大端还是小端，解决办法是：<code>发送端总是把要发送的数据转化为大端字节序数据后再发送</code>，而接受端可以根据自身采用的字节序决定是否对接收到的数据进行转换。因此<code>大端字节序也称为网络字节</code>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>另外需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由Java编写）通信，也要考虑字节序的问题（Java虚拟机采用大端字节序）。</p>
<p>在linux中提供了下面4个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> __hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> __hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> __netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> __netshort)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示”host to network long”，即将32位无符号数从主机字节序转换为网络字节序数据。</p>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h2 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h2><p>Linux C  Socket网络编程接口表示socket地址的结构体sockaddr，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">  	<span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sa_family成员时地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型对应。常见的协议族(protocal family，也称domain，见后文)和对应的地址族如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址族</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">AF_UNIX</td>
<td style="text-align:center">UNIX本地协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">TCP/IPv4协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">TCP/IPv6协议族</td>
</tr>
</tbody>
</table>
</div>
<p>宏PF_*和AF_*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>sa_data成员用于存放socket地址值。但是，不同协议族的地址值具有不同的含义和长度，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td>文件的路径名，长度可到108字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td>16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td>16bit端口号，32bit流标识，128bit IPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
</div>
<p>由上表可见，<code>14字节的sa_data根本无法完全容纳多数协议族的地址值</code>。因此，Linux定义了下面这个新的通用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体不仅能提供了足够大的空间用于存放地址值，而且是内存对齐的(这是__ss_align成员的作用)。</p>
<h2 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h2><p><code>上面的两个通用socket地址结构体显然都不好用</code>，所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地协议族使用如下专用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* 地址族: AF_UNIX */</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];     <span class="comment">/* 文件路径名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TCP/IP协议族有socket_in和sockaddr_in6两个专业socket地址结构体，它们分别用于IPv4和IPv6：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockadddr_in</span>&#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sun_family;		<span class="comment">/* 地址族: AF_INET */</span></span><br><span class="line">  	<span class="keyword">u_int16_t</span> sin_port; 			<span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>		/* <span class="title">IPv4</span>地址结构体 */</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  	<span class="keyword">u_int32_t</span> s_addr;					<span class="comment">/* IPv4地址，要用网络字节序号表示 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sin6_family;			<span class="comment">/* 地址族: AF_INET6 */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;					<span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">  	<span class="keyword">u_int32_t</span> sin6_flowinfo;			<span class="comment">/* 流信息，应设置为0 */</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>		<span class="comment">/* IPv6地址结构体 */</span></span><br><span class="line">  	<span class="keyword">u_int32_t</span> sin6_scope_id;			<span class="comment">/* scope ID, 尚处于实验阶段 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>]; 		<span class="comment">/* IPv6地址，要用网络字节序表示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket类型sockaddr(强制转换即可)，因为socket编程接口使用的地址参数的类型都是sockaddr</code>。</p>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分10进展字符串表示IPv4地址，以及用16进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数才能使用。而记录日志时则相反，我们要把整数表示的IP地址转为可读的字符串。Linux提供了3个用于IP地址形式转化的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>; <span class="comment">/*in_addr 是 __uint32_t 的typdef*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, struct in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Inet_addr函数将用点十进制字符串表示的IPv4地址转为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE</p>
</li>
<li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败时返回0</p>
</li>
<li><p>Inet_ntoa函数将用网络字节序表示的IPv4地址转化为用点十进制表示的IPv4地址。<font color="red">但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的</font>，下面的代码揭示了其不可重入性：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *value1 = inet_ntoa(inet_addr(<span class="string">&quot;1.2.3.4&quot;</span>));</span><br><span class="line"><span class="keyword">char</span> *value2 = inet_ntoa(inet_addr(<span class="string">&quot;10.194.71.60&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 1: %s\n&quot;</span>, value1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 2: %s\n&quot;</span>, value2);</span><br><span class="line"><span class="comment">//最后打印的结果为：</span></span><br><span class="line">address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数相同的功能，并且它们<font color="red">同时适用于IPv4地址和IPv6地址。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *scr, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>inet_pton函数用于将字符串表示的IP地址src(用点十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址)转化成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败时返回0。</p>
</li>
<li><p>inet_ntop函数将网络字节序整数表示的IP地址，转化为IP字符串。前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定字符串dst目标存储单元的大小。有两个宏能帮助我们快速指定这个大小(分别用于IPv4和IPv6)：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<h1 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h1><p>UNIX/Linux的一个思想就是：所有的东西都是文件。socket也不例外，他就是可读、可写、可控制</p>
<p>可关闭的文件描述符。</p>
<p>下面的socket系统调用可创建一个socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domin, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>domin 参数告诉系统使用哪个底层协议族。对于TCP/IP协议族而言，该参数应该设置为PF_INET(Protocal Family of Internet，用于IPv4)或PF_INET6(用于IPv6)，对于UNIX本地协议族而言，该参数应设置为PF_UNIX</li>
<li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_DGRAM（数据报）服务。对于TCP/IP协议族而言，SOCK_STEAM表示传输层使用TCP协议，SOCK_DGRAM表示传输层使用UDP协议。</li>
<li>protocol参数是在前两个参数构成的协议集合下，在选择一个具体的协议。不过这个值通常都是唯一，几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</li>
</ul>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<h1 id="绑定socket"><a href="#绑定socket" class="headerlink" title="绑定socket"></a>绑定socket</h1><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。需要将一个socket与socket地址进行绑定。通常在服务器端中，我们需要进行socket地址绑定，因为只有绑定后，客户端才能知道该如何连接它。客户端通常不需要绑定socket地址，而是采用匿名方式，即使用操作系统自动分配的socket地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bind将addr所指的socket地址分配给未绑定的sockfd文件描述符，addrlen参数指出该socket地址长度。</p>
<h1 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h1><p>socket被命名之后，还不能马上接收客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户端连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd参数指定被监听的sock文件描述符</li>
<li>backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接。客户端也将受到ECONREFUSED错误。在内核版本2.2之前的linux中，backlog参数是值所有处于半连接状态和完全连接状态的socket上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket上限，处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义</li>
</ul>
<p>listen成功返回0，失败时返回-1并设置errno</p>
<h1 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h1><p>下面的系统调用从listen的监听队列中接收一个连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd参数是执行过listen系统调用的监听socket文件描述符。addr参数用来获取客户端的socket地址，该socket地址的长度由addrlen参数返回。</p>
<p><code>accept成功时返回一个新的连接socket文件描述符</code>，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1，并设置errno。</p>
<p><code>当当前监听队列中没有连接时，accept会被阻塞。</code></p>
<p><code>accept只是从监听队列中取出连接，而不管取出连接后，连接处于何种状态（连接或者断开）</code>。</p>
<h1 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h1><p>在客户端需要通过一下系统调用来主动与服务器建立连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklent_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd是由socket系统调用返回的socket文件描述符</li>
<li>serv_addr是服务器监听的socket地址</li>
<li>addrlen参数则serv_addr的长度</li>
</ul>
<p>connect成功时返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno，其中两种常见的errno是ECONNREFUSED和ETIMEOUT，它们的含义分别是连接被拒绝和连接超时。</p>
<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><p>关闭连接实际上就是关闭连接对应的socket文件描述符，可以通过调用关闭普通文件描述符的系统调用来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不过，<code>close系统调用并非总是立即关闭一个连接</code>，而是将fd的引用记数减一，只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，<code>一次fork系统调用默认将父进程中打开的socket文件描述符的引用计数加1</code>。如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用shutdown系统调用（相对于close来说，它是专门为网络编程设计的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<p>howto参数决定了shutdown的行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">可选值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SHUT_RD</td>
<td style="text-align:center">关闭sockfd上读的这一半，应用程序不能再针对socket文件描述符号执行读操作，并且该socket接收缓冲区中的数据都将被丢弃</td>
</tr>
<tr>
<td style="text-align:center">SHUT_WR</td>
<td style="text-align:center">关闭sockfd上写的这一半。sockfd的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socke文件描述符执行写操作。这种情况下，连接处于半关闭状态。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_RDWR</td>
<td style="text-align:center">同时关闭sockfd上的读和写</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，shutdown能分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。shutdow成功时返回0，失败时返回-1，并设置errno。</p>
<h1 id="socket服务端，客户端示例"><a href="#socket服务端，客户端示例" class="headerlink" title="socket服务端，客户端示例"></a>socket服务端，客户端示例</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create socket fd fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sock_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_addr</span>;</span></span><br><span class="line">    sock_addr.sin_family = AF_INET;<span class="comment">//ipv4地址协议族</span></span><br><span class="line">    sock_addr.sin_port = htons(<span class="number">22996</span>); <span class="comment">//转换为网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;sock_addr.sin_addr);<span class="comment">//将字符串类型的地址转换为网络类型地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sock_fd, <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr *&gt;(&amp;sock_addr), <span class="keyword">sizeof</span>(sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    ret = listen(sock_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;listen fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_socklen;</span><br><span class="line">        ret = accept(sock_fd, &amp;client_addr, &amp;client_socklen);</span><br><span class="line">        <span class="keyword">if</span> (client_socklen == <span class="keyword">sizeof</span>(struct sockaddr_in)) &#123;<span class="comment">//如果是ipv4连接</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">client_ipv4_sock</span> =</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *&gt;</span>(&amp;client_addr);</span><br><span class="line">            <span class="keyword">char</span> client_ipv4_str[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connection from &quot;</span></span><br><span class="line">                      &lt;&lt; inet_ntop(client_ipv4_sock-&gt;sin_family, &amp;client_ipv4_sock-&gt;sin_addr, client_ipv4_str, INET_ADDRSTRLEN) <span class="comment">//网络ip地址转换为字符串表示</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                      &lt;&lt; ntohs(client_ipv4_sock-&gt;sin_port) <span class="comment">//网络字节序端口号转主机字节序</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_sock_addr</span>&#123;</span>&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    server_sock_addr.sin_port = htons(<span class="number">22996</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(sock_fd, <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr*&gt;(&amp;server_sock_addr), <span class="keyword">sizeof</span>(server_sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect fail&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h2><p>对文件的读写操作read和write同样适用于socket，但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次recv，才能读取到完整的数据。<code>recv可能返回0，这意味着通信对方已经关闭连接了</code>。recv出错时返回-1并设置errno。</li>
<li>send往sockfd上写入数据，buf和len参数分别指定缓冲区的位置和大小。send成功时返回实际写入的数据长度，失败则返回-1并设置errno。</li>
</ul>
<p>recv和send函数中的flag参数为数据收发提供了额外的控制，它可以取下表所示选项中的一个或几个的逻辑或</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项名</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">send</th>
<th style="text-align:center">recv</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MSG_CONFIRM</td>
<td style="text-align:center">指示数据链路层协议持续监听对方的回应，直到得到答复，它仅能用于SOCK_DGRAM和SOCK_RAW类型的socket</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_DONTROUTE</td>
<td style="text-align:center">不查看路由表，直接将数据发送给本地局域网络内的主机。这表示发送者确切地知道目标主机就在本地网络上</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_DONTWAIT</td>
<td style="text-align:center">对socket的此次操作时非阻塞的。socket的读写操作默认是阻塞的。</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_MORE</td>
<td style="text-align:center">告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送。这样可防止TCP发送过多小的报文段，从而提高效率</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_WAITALL</td>
<td style="text-align:center">读操作仅在读取指定数量的字节后才返回</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_PEEK</td>
<td style="text-align:center">窥探读缓存的数据，此次读操作不会导致这些数据被清除</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_OOB</td>
<td style="text-align:center">发送或接收紧急数据</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_NOSIGNAL</td>
<td style="text-align:center">往读端关闭的管道或者socket连接中写数据不引发SIGPIPE信号</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
</div>
<h2 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h2><p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">sockelen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklent_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数scr_addr所指的内容，addrlen参数则指定该地址的长度。</p>
<p>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接受端的socket地址，addrlen参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均于send/recv系统调用的flags参数及返回值相同。</p>
<p>另外，recvfrom/sendto系统调用也可以用于面向连接(STREAM)的socket数据读写，只需要把最后两个参数都设置为NULL即可。</p>
<h2 id="带外标记检查"><a href="#带外标记检查" class="headerlink" title="带外标记检查"></a>带外标记检查</h2><p>当Linux内核检查到TCP紧急标志时，将通知应用程序有带外数据需要接受。内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。但是，即使应用程序得到了有外带数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据，可以通过以下函数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockadmark判断sockfd是否处于带外标记，即下一个读取到的数据是否是带外数据，如果是，sockatmark返回1，此时就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h1 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h1><p>Linux中有下面两个系统调用是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd参数指定被操作的目标socket文件描述符。level参数指定要操作哪个协议的选项，比如说IPv4、IPv6、TCP等。option_name参数则指定选项的名字。</p>
<p>下表列举了socket通信中几个比较常用的socket选项。option_value和option_len参数分别是被操作选项的值和长度。不同的选项具有不同类型的值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">level</th>
<th style="text-align:center">option name</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOL_SOCKET（通用socket选项，与协议无关）</td>
<td style="text-align:center">SO_DEBUG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">打开调试信息</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_REUSEADDR</td>
<td style="text-align:center">int</td>
<td style="text-align:center">重用本地地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_TYPE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">获取socket类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_ERROR</td>
<td style="text-align:center">int</td>
<td style="text-align:center">获取并清除socket错误状态</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_DONTROUTE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">不查看路由表，直接将数据发送给<font color="orange">本地局域网内</font>的主机。含义和send方法的MSG_DONTROUTE标志类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVBUF</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP接收缓冲区大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDBUF</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP发送缓冲区大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_KEEPALIVE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">发送周期性保活报文以维持连接</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_OOBINLINE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收到的带外数据将保留在普通数据的输入队列中，此时我们不能使用带MSG_OOB标志的读操作来读取带外数据，而应该像读取普通数据那样读取带外数据</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_LINGER</td>
<td style="text-align:center">linger结构体</td>
<td style="text-align:center">若缓冲区中还有数据待发送，则延迟关闭</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVLOWAT</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP接收缓存区低水位标记</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDLOWAT</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP发送缓存区低水位标记</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVTIMEO</td>
<td style="text-align:center">timeval</td>
<td style="text-align:center">接收数据超时</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDTIMEO</td>
<td style="text-align:center">timeval</td>
<td style="text-align:center">发送数据超时</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_TOS</td>
<td style="text-align:center">int</td>
<td style="text-align:center">服务类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IP_TTL</td>
<td style="text-align:center">int</td>
<td style="text-align:center">存活时间</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IPV6</td>
<td style="text-align:center">IPV6_NEXTHOP</td>
<td style="text-align:center">sockaddr_in6</td>
<td style="text-align:center">下一跳IP地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_RECVPKTINFO</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收分组信息</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_DONTFRAG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">禁止分片</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_RECVTCLASS</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收通信类型</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP_MAXSEG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP最大报文段大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">TCP_NODELAY</td>
<td style="text-align:center">int</td>
<td style="text-align:center">禁止Nagle算法</td>
</tr>
</tbody>
</table>
</div>
<p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno</p>
<p><code>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前对socket设置才有效</code>。这是因为连接socket只能有accept调用返回，<code>而accept从监听队列中接受的连接至少已经完成TCP三次握手的前两个步骤</code>，这说明服务器已经向客户端发出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。这种情况Linux给开发人员提供的解决方案是：<code>在调用listen前，对socket设置的这些socket选项，那么accept返回的连接socket将自动继承这些选项。这些选项选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SDNLOWAT、TCP_MAXSEG、TCP_NODELAY</code>。<code>而对客户端而言，这些socket选项则应该在调用connect函数之前设置</code>，因为connect调用成功返回之后，TCP三次握手已完成。</p>
<h2 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h2><p>对于处于TIME_WAIT状态的TCP连接，服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_addr</span>;</span></span><br><span class="line">sock_addr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip_string, &amp;sock_addr.sin_addr);</span><br><span class="line">sock_addr.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock, (sturct sockaddr *)&amp;sockaddr, <span class="keyword">sizeof</span>(sockaddr));</span><br></pre></td></tr></table></figure>
<p>经过setsockopt的设置后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h2 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a>SO_RCVBUF和SO_SNDBUF选项</h2><p>SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区的发送缓冲区的大小。不过，当我们用setsockopt来设置TCP的接受缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接受缓冲区的最小值时256字节，而发送缓冲区的最小值是2048字节（不过，不同的系统可能有不同的默认值）。系统这样做的目的，主要是确保一个TCP连接有足够的空闲缓冲区来处理拥塞（比如说快重传算法就期望TCP接收缓冲区能至少容纳4个大小为最大报文段长度的TCP报文段）。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。</p>
<h2 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h2><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记，它们一般被I/O复用系统调用用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总量大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据；当TCP发送缓冲区中的<code>空闲空间</code>（可以写入数据的空间）大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写数据。</p>
<p><code>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节</code>。</p>
<h2 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h2><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭socket时，close将立即返回，TCP模块负责将socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>设置（获取SO_LINGER选项值时），我们需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l_onoff;	<span class="comment">/* 开启（非0）还是关闭（0）该选项 */</span></span><br><span class="line">  <span class="keyword">int</span> l_linger;	<span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据linger结构中两个成员变量的不同值，close系统调用可能产生如下3中行为之一：</p>
<ul>
<li>l_onoff等于0，此时SO_LINGER选项不起作用，close用默认行为来关闭socket</li>
<li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将<code>丢弃</code>被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供一了异常终止一个连接的方法。</li>
<li>l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送玩所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送玩残留数据并得到对方确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/tcpdump%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/hight_performance_linux_coding/tcpdump%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">tcpdump工具使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 11:03:49" itemprop="dateCreated datePublished" datetime="2020-11-06T11:03:49+08:00">2020-11-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/02/others/c++%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/others/c++%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Untitled</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-02 09:49:58" itemprop="dateCreated datePublished" datetime="2020-11-02T09:49:58+08:00">2020-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-19 22:36:32" itemprop="dateModified" datetime="2020-12-19T22:36:32+08:00">2020-12-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="不使用任何构建工具"><a href="#不使用任何构建工具" class="headerlink" title="不使用任何构建工具"></a>不使用任何构建工具</h1><p>对于C/C++代码来说，不使用任何构建工具来辅助编译C/C++代码的话，就需要自己手动指定使用的编译器(clang、gcc/g++或者其他编译器)，一般来说需要在编译命令下指定这些：</p>
<ul>
<li>指定需要编译的源文件</li>
<li>指定头文件的搜索目录</li>
<li>指定库文件的搜索目录</li>
<li>需要链接的动态库和静态库</li>
<li>指定需要额外定义的宏或者取消定义的宏来控制编译</li>
<li>指定编译优化选项</li>
<li>指定语言标准</li>
<li>等等</li>
</ul>
<p>以gcc/g++为例，使用-D指定额外定义的宏，-U取消宏定义：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-DUseXX //#define UseXX</span><br><span class="line">-DMaxSize=500 //#define MaxSize 500</span><br><span class="line">-UUseXX //#undef UseXX</span><br></pre></td></tr></table></figure>
<p>-I（i的大写） 添加头文件搜索目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-I/usr/local/include/xxx -I/usr/local/Cellor/yyy</span><br></pre></td></tr></table></figure>
<p>-L 添加库文件搜索目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L/usr/local/lib -L/usr/local/Cellor/lib</span><br></pre></td></tr></table></figure>
<p>-l（L的小写）添加链接库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-la -lb -lz</span><br></pre></td></tr></table></figure>
<p>-g生成调试信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-g #以操作系统的本地格式产生调试信息</span><br><span class="line">-g1 #输出的调试信息</span><br><span class="line">-g2 #输出默认量的调试信息</span><br><span class="line">-g3 #输出更多的调试信息</span><br></pre></td></tr></table></figure>
<p>警告选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-w #关闭显示所有警告信息</span><br><span class="line">-Wall #开启大部分警告提示，默认</span><br><span class="line">-Werror #将警告视为错误，出现警告即放弃编译</span><br></pre></td></tr></table></figure>
<p>-O优化选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-O0 #不优化</span><br><span class="line">-O1 #</span><br><span class="line">-O2</span><br><span class="line">-O3</span><br></pre></td></tr></table></figure>
<p>语言选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-ansi #支持符合ANSI标准的C程序</span><br><span class="line">-std=c99 #C99标准</span><br><span class="line">-std=c++11 # c++11标准</span><br></pre></td></tr></table></figure>
<p>直接使用gcc/g++命令在使用代码文件不多，库直接的依赖关系不复杂的情况下是可以接受的。但是在一些大型项目中，源文件上千上万，各个文件和库直接的依赖关系复杂，如果还手动输入编译命令的话，复杂度就会变得很大。</p>
<h1 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h1><p>make工具是一个从源码自动构建所需“目标”的构建工具，他依赖通过读取一个叫做Makefile的脚本文件来实现自动化构建。</p>
<p>Makefile本身其实一种管理代码源文件之间依赖关系的脚本，在这个脚本中描述了项目工程中的各个“目标”或者源文件之间的依赖关系以及构建各个目标所需要的命令。</p>
<p>斯图亚特·费尔德曼在1977年在贝尔实验室里制作了最初的make程序，最初的make程序被多次重/改写，形成了多种版本的make工具，比较出名的有GNU make， BSD make，microsoft nmake等等。这些make工具都有不同的规范和标准，使用的Makefile的语法标准也不同。</p>
<p>下面以GNU Make使用的Makefile的格式对Makefile进行简介。</p>
<h2 id="GNU-Makefile格式"><a href="#GNU-Makefile格式" class="headerlink" title="GNU Makefile格式"></a>GNU Makefile格式</h2><p>编写Makefile的规则一般如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">[tab]COMMAND</span><br><span class="line">[tab]COMMAND</span><br><span class="line">		 ...</span><br><span class="line">		 ...</span><br><span class="line">		 ...</span><br><span class="line"></span><br><span class="line"><span class="section">target2: prerequisites</span></span><br><span class="line">		...</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<p>Makefile中target就是make命令中所需指定的构建目标。<code>make会把在Makefile中定义的第一target作为默认target，即如果不给make命令传递target参数，则默认为makefile中的第一个定义的target。</code></p>
<p>prerequisites说明了这个target依赖哪些其他的target或者文件，这个字段可以为空，说明这个target没有依赖。如果target有依赖的情况下，make会记录target是否有更新，如果依赖没有更新，make就不会重复构建target。</p>
<p>command就是这个生成这个target所需要的命令，这个命令可以是任意的命令</p>
<p><code>注意，可能有一个误区就是prerequisites字段只是用来让make进行依赖解析和判断target是否需要重建的，依赖和command本身没有任何关系。如果以为某个target依赖了某些源文件，那么make在解析的时候自动会将这些源文件传递给命令，这是不对的。</code>例如target main依赖了main.cpp文件，那么这么写是没有用的：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.cpp</span></span><br><span class="line">	g++ -o main</span><br></pre></td></tr></table></figure>
<p>应该这么写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.cpp</span></span><br><span class="line">	g++ -o main main.cpp</span><br></pre></td></tr></table></figure>
<p>下面举一个例子来使用makefile构建一个可执行文件，在a.h定义了类A，在a.cpp中实现了类A的方法，在main.cpp中引入了a.h使用了类A的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  a.say();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Makefile的一种形式</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line"><span class="section">main: a.cpp.o main.cpp.o</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o test main.o a.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: a.h main.cpp</span></span><br><span class="line">	echo <span class="string">&quot;main&quot;</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c main.cpp -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">a.o: a.h a.cpp</span></span><br><span class="line">	echo <span class="string">&quot;a&quot;</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c a.cpp -o a.o</span><br></pre></td></tr></table></figure>
<p>还有很多其他写法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line"><span class="section">main: a.h a.cpp main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o test main.cpp a.cpp</span><br></pre></td></tr></table></figure>
<p>但是这种写法不好的地方在于，如果a.h，a.cpp，main.cpp中有任意一个文件有变化，这几个文件都要重新再编译一次。</p>
<p>执行make命令就会构建出目标main，生成test可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make #等价使用make main</span><br></pre></td></tr></table></figure>
<p>也可以不构建目标main，选择构建其他目标，例如构建main.cpp.o目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make main.cpp.o #执行g++ -c main.cpp，生成main.o文件</span><br></pre></td></tr></table></figure>
<p>make对target依赖的解析是一个类似递归的过程，例如上例中目标main依赖了目录a.cpp.o和main.cpp.o那么make会先去执行a.cpp.o下的命令和main.cpp.o下的命令，然后再来执行目标main定义的命令。</p>
<p>在make file中有几个特殊的target，一个是clean，另外一个是install，<code>不是说这些命令必须执行某种命令，而是大家默认了使用cmake执行这些target应该做的事</code>，clean就应该是去清除之前构建目标生成出来的文件，而install应该将构建目标生成出来的文件安装到指定目录下。你也可以在Makefile中将clean定义为执行安装操作的命令，然后把install定义为执行clean操作的命令，但是这不合理。</p>
<p>之前提到Makefile本质上就是一个脚本文件，既然是脚本文件，<code>那就可以在Makefile中定义变量，使用变量，使用条件控制语句，定义函数，使用函数，include其他Makefile文件等</code>。这些使用可以去网上自己去搜索。</p>
<p>Makefile本身只关心各个文件或目标之间的依赖关系，省去了开发者在修改某些代码文件后判断需要重新编译生成目标文件的时间。但是在Makefile中最后还是需要自己去调用编译器命令，在命令中指定include的目录，链接库的路径，需要链接的库。另外在不同的操作系统下还需要指定不同的编译器，指定不同的include头文件目录等等。</p>
<p>最后说明一下，由于Makefile本身不关心编译过程的，因为最后的编译还是通过在Makefile中编写调用编译命令，所以使用make+Makefile理论上可以用来编译任何代码。</p>
<h1 id="GNU-Autotools"><a href="#GNU-Autotools" class="headerlink" title="GNU Autotools"></a>GNU Autotools</h1><p>之前说到在不同的代码运行平台下，可能需要在Makefile中指定不同的编译器的名称，指定不同的头文件路径，链接不同的链接库等等，如果用make工具，那么就需要对不同的运行平台，就需要编写不同的Makefile，这不仅会增加工作量，而且要求程序员对各个平台也要有一定的熟悉程度。GNU Autotools的目的就是为了在不同类Unix平台下，针对GNU make工具快速生成对应的Makefile文件。</p>
<p>GUN Autotools是一个GNU工具集，它包括autoscan、autoheader，autoconf，automake，aclocal和libtool等等。最主要使用的两个工具就是autoconf和automake。使用Autotools最终也会生成Makefile文件，然后调用make命令来构建出项目。使用Autotools构建项目的三部曲一般是./configure，make，make install。</p>
<p>运行configure脚本用于系统检测，一般主要检测当前平台的编译器、库文件、头文件等等，这些检查的结果将用于将config.h.in和Makefile.in文件转化为最终的config.h和Makefile文件。configure脚本一般有几千行，非常复杂，如果要手写的话很困难，可以使用autoconf工具来自动生成这个configure脚本。autoconf工具通过读取一个configure.ac的模版文件，来生成configure脚本。configure.ac文件是一个由m4宏编写的文件，autoconf在处理configure.ac文件时就会将这些宏展开为shell脚本代码。</p>
<p>在开始的时候，可以使用autoscan工具来生成一个configure.ac的模版，autoscan生成的文件的名字为configure.scan，直接修改configure.scan名字为configure.ac即可。</p>
<p>再以写Makefile时的示例项目为例，通过对autoscan生成的模版再进行修改的情况下，编写的configure.ac文件如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">                                               -*- Autoconf -*-</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Process this file with autoconf to produce a configure script.</span></span><br><span class="line"></span><br><span class="line">AC_PREREQ([2.69]) #autoconf版本最低要求2.69</span><br><span class="line">AC_INIT([test], [1.0], [www.xxx-bug-report.com]) #设置项目名称，版本号，bug上报网址</span><br><span class="line">AM_INIT_AUTOMAKE # 项目需要使用automake，初始化automake</span><br><span class="line">AC_CONFIG_FILES([Makefile]) #告诉configure 根据系统信息和Makefile.in生成Makefile文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Checks <span class="keyword">for</span> programs.</span></span><br><span class="line">AC_PROG_CXX #告诉configure 检查c++编译器，由于没有指定这个宏的参数，默认参数为g++</span><br><span class="line">AC_PROG_CC  #告诉configure 检查c编译器，由于没有指定这个宏的参数，默认参数为gcc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Checks <span class="keyword">for</span> libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Checks <span class="keyword">for</span> header files.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Checks <span class="keyword">for</span> typedefs, structures, and compiler characteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Checks <span class="keyword">for</span> library <span class="built_in">functions</span>.</span></span><br><span class="line"></span><br><span class="line">AC_OUTPUT</span><br></pre></td></tr></table></figure>
<p>configure脚本会根据Makefile.in来生成Makefile，但是Makefile.in的脚本也是又长又复杂的，但是和configure的生成一样，Makefile.in可以由一个模版文件通过automake来生成，这个模版文件就是Makefile.am。</p>
<p>在这个例子下，对应的Makefile.am：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS = foreign #因为这里的例子不是标准的 GNU 项目的结构，所以结构声明为 foreign</span><br><span class="line">bin_PROGRAMS = test #告诉automake 需要Makefile构建的项目是一个可执行文件，其名称为test</span><br><span class="line">test_SOURCES = main.cpp a.cpp #告诉automake 项目使用的源文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">test_CPPFLAGS = <span class="comment">#设置c++编译的编译选项，这里不需要额外的编译选项</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">test_LDFLAGS = <span class="comment">#设置链接选项，这了不需要额外的链接选项，</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">test_LDADD = <span class="comment">#设置要链接的库文件，这里也没有</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">INCLUDES = <span class="comment">#设置头文件搜索目录，这里也没有额外的头文件</span></span></span><br></pre></td></tr></table></figure>
<p>接下来，依次运行下面几个命令即可完成对项目的编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aclocal #使用aclocal初始化m4环境</span><br><span class="line">autoconf #将configure.ac生成configure脚本</span><br><span class="line">automake --add-missing #将Makefile.am生成Makefile.in</span><br><span class="line">./configure #检查系统环境，将Makefile.in和config.h.in(这里没有使用到)生成Makefile和config.h</span><br><span class="line">make </span><br></pre></td></tr></table></figure>
<p>在发布软件的时候，不需要将configure.ac和Makefile.am文件发布出去，只需要将Makefile.in，config.in.h和configure脚本发布出去即可。</p>
<p>GNU Autotools工具对类Unix系统的用户来说比较友好，对于使用windows系统的用户来说就很不友好了，需要进行很多的配置才行。</p>
<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>之前提到不同的平台下，不同的IDE间使用的make工具的规范和标准是不同的，Makefile的标准也就不同，CMake的出现解决了不同make工具之间规范和标准不同的问题。</p>
<p>CMake让构建人员通过一个与平台无关的CMakeList.txt文件来说明这个项目的构建流程，然后再根据目标平台生成对应的Makefile文件。</p>
<p>CMakeList.txt是使用CMake自己的一套语法来编写的。还是以之前的例子来说明一个CMaList.txt有哪些内容：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.13</span>) <span class="comment">#cmake最低版本3.13</span></span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">Test</span>) <span class="comment">#设置CMake项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>) <span class="comment">#设置C++标准为C++11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(TEST_SRC main.cpp a.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> <span class="variable">$&#123;TEST_SRC&#125;</span>) <span class="comment">#添加说明要构建一个可执行文件，文件名为test，源码文件为main.cpp，a.cpp</span></span><br></pre></td></tr></table></figure>
<p>之后执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>就可以完成对项目的编译构建。</p>
<p>CMake会自动检查当前平台使用的编译器信息，当然也可以在CMake中要使用的编译器</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="代码构建工具的目的"><a href="#代码构建工具的目的" class="headerlink" title="代码构建工具的目的"></a>代码构建工具的目的</h2><p>1、代码构建工具的首要目的就是帮助程序员能够从代码构建出最后的产物</p>
<p>2、帮助管理代码中的依赖问题</p>
<p>3、加快编译构建速度，能够并行编译，并且只对需要重新编译的部分进行编译。</p>
<h2 id="为什么c-c-的项目这么难管理"><a href="#为什么c-c-的项目这么难管理" class="headerlink" title="为什么c/c++的项目这么难管理"></a>为什么c/c++的项目这么难管理</h2><p>以下原因只是我的主观看法：</p>
<p>1、c/c++发展的太早，早到发展初期根本没有想到依赖管理的问题，早到当时根本没有考虑各个平台下统一标准，统一规范的问题。</p>
<p>2、</p>
<p>3、与系统强相关，在不同系统中，使用的c/c++的头文件，库文件都是不同的，另外，在一个平台下编译出来的二进制文件有可能无法在另外一个平台下使用，需要从源码重新编译。</p>
<p>TODO: 将PPT中的一些内容补充到这篇博客中</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/10/18/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E9%9F%B3%E9%A2%91/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/18/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E9%9F%B3%E9%A2%91/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">音频基础知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-18 20:09:39" itemprop="dateCreated datePublished" datetime="2020-10-18T20:09:39+08:00">2020-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-30 20:36:21" itemprop="dateModified" datetime="2020-10-30T20:36:21+08:00">2020-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9F%B3%E9%A2%91/" itemprop="url" rel="index">
                    <span itemprop="name">音频</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="声音的产生"><a href="#声音的产生" class="headerlink" title="声音的产生"></a>声音的产生</h1><p>物体的<code>振动</code>产生声波，通过声音传播<code>介质</code>，传入人的鼓膜，再到听小骨，最后到听觉神经和大脑。</p>
<h1 id="声音的三要素"><a href="#声音的三要素" class="headerlink" title="声音的三要素"></a>声音的三要素</h1><ul>
<li>音调：由声音的频率决定，频率越高，声音越高，在乐音中，规定国际标准音高为440HZ，对应为音名为A4。</li>
<li>响度：又称为音量，音强，由振幅和人离声源距离决定。</li>
<li>音色：由发生物体材料和结构决定</li>
</ul>
<h1 id="模拟信号和数字信号"><a href="#模拟信号和数字信号" class="headerlink" title="模拟信号和数字信号"></a>模拟信号和数字信号</h1><h2 id="模拟音频信号"><a href="#模拟音频信号" class="headerlink" title="模拟音频信号"></a>模拟音频信号</h2><p>模拟音频信号是指时间轴连续，振幅轴连续的音频信号。自然界中存在的声音都算是模拟信号。</p>
<h2 id="数字音频信号"><a href="#数字音频信号" class="headerlink" title="数字音频信号"></a>数字音频信号</h2><p>时间和幅度都用离散的数字表示的信号。计算机只能存储和处理数字音频信号。</p>
<h2 id="A-D，D-A转换"><a href="#A-D，D-A转换" class="headerlink" title="A/D，D/A转换"></a>A/D，D/A转换</h2><ul>
<li>A/D转换：模/数转换，模拟信号转为数字信号</li>
<li>D/转换：数/模转换，数字信号转为模拟信号</li>
</ul>
<p>一般计算机处理音频信号的过程：对模拟信号进行采样、量化、编码、压缩转换成数字信号(设备一般是麦克风🎤和声卡)，然后对数字音频进行处理(变声、降噪、存储)，要播放音频的时候，将音频信号再还原成模拟信号播放(设备一般是声卡和扬声器🔉)。</p>
<h1 id="模拟信号到数字音频的转换-A-D转换"><a href="#模拟信号到数字音频的转换-A-D转换" class="headerlink" title="模拟信号到数字音频的转换(A/D转换)"></a>模拟信号到数字音频的转换(A/D转换)</h1><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>在模拟信号的时间轴上每隔一定时间抽取一个信号的幅度样本（时间轴数字化）。</p>
<ul>
<li>采样周期(T)：每隔T秒进行一次采样</li>
<li>采样频率(F)：一秒采样多少次</li>
<li>T = 1/F</li>
</ul>
<p><code>奈奎斯特采样定理</code>：如果想要通过数字信号重建原始模拟信号，那么采样频率必须大于模拟信号最高频率的两倍。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p>由于在采样的时候，从模拟信号中获取到的幅度值其实本质上是个模拟量，这个模拟量可能是在计算机中是无法表示的，因为即使是使用浮点数，可以表示的值也都是离散的小数值，所以如果想要把采样过的值存储到计算机中进行处理，就需要将这些值转换为计算机可以处理的值。这个过程就是<code>量化</code>。</p>
<p>在将计算机不能存储和处理的值转换为计算机可以存储和处理的值的时候，最后计算机存储的结果可能和和实际的结果存在偏差。这就是<code>量化误差</code>。例如：某个计算只能存储int类型的值，但是某次采样到的数据的值为3.1，那么量化后的值应该为3，那么就产生了量化误差。</p>
<p>在音频信号处理中，<code>一般采用8bit、16bit、24bit</code>去存储经过量化过后的值(既可以使用整型数据，也可以使用浮点型数据，使用整型数据属于<strong>均匀量化</strong>，使用浮点数据属于<strong>非均匀量化</strong>)，使用的bit位数越多，可以表示的数据量就越多，可以表示的精度就越高。所以一般高清音质，高保真音质使用的24bit来存储量化后的值。</p>
<h2 id="PCM文件"><a href="#PCM文件" class="headerlink" title="PCM文件"></a>PCM文件</h2><h2 id="WAV文件"><a href="#WAV文件" class="headerlink" title="WAV文件"></a>WAV文件</h2><h1 id="音频编解码"><a href="#音频编解码" class="headerlink" title="音频编解码"></a>音频编解码</h1><p>音频编解码用于对量化后的音频数据进行压缩，方便对音频数据的存储和传输。</p>
<h2 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h2><h3 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h3><p>指音频(或视频)文件在单位时间内使用的数据量，单位一般是Kb/s或者Mb/s(注意是bit)。固定码率是指音频(或视频)文件在每一个单位时间内使用的数据量都相等。可变码率指不同单位时间内使用的数据量可以不同。</p>
<h3 id="压缩比"><a href="#压缩比" class="headerlink" title="压缩比"></a>压缩比</h3><p>原始数据和压缩后的数据总体的大小占比。一般来说，对于同一个原始数据，压缩比越小，码率越高，最后还原出来的数据越真实。</p>
<h2 id="三大主要音频编解码标准"><a href="#三大主要音频编解码标准" class="headerlink" title="三大主要音频编解码标准"></a>三大主要音频编解码标准</h2><h3 id="ITU"><a href="#ITU" class="headerlink" title="ITU"></a>ITU</h3><p>主要指定有线语言压缩标准，一般用于语音通话</p>
<h3 id="3GPP"><a href="#3GPP" class="headerlink" title="3GPP"></a>3GPP</h3><p>主要指定无线语音压缩标准</p>
<h3 id="MPEG"><a href="#MPEG" class="headerlink" title="MPEG"></a>MPEG</h3><p>主要指定音乐压缩标准等，例如MP3、AAC编解码标准</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/10/08/opengl/shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/08/opengl/shader/" class="post-title-link" itemprop="url">shader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-08 15:35:23 / Modified: 16:55:58" itemprop="dateCreated datePublished" datetime="2020-10-08T15:35:23+08:00">2020-10-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shader简介"><a href="#shader简介" class="headerlink" title="shader简介"></a>shader简介</h1><p>shader程序是</p>
<h1 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h1><p>Shaders always begin with a version declaration, followed by a list of input and output variables, uniforms and its main function. Each shader’s entry point is at its main function where we process any input variables and output the results in its output variables. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#version version_number</span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line">  </span><br><span class="line">uniform type uniform_name;</span><br><span class="line">  </span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; process input(s) and do some weird graphics stuff</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; output processed stuff to output variable</span><br><span class="line">  out_variable_name &#x3D; weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is a maximum number of vertex attributes we’re allowed to declare limited by the hardware. OpenGL guarantees there are always at least 16 4-component vertex attributes available, but some hardware may allow for more which you can retrieve by querying GL_MAX_VERTEX_ATTRIBS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line">std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>This often returns the minimum of <code>16</code> which should be more than enough for most purposes.</p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>GLSL has most of the default basic types we know from languages like C: <code>int</code>, <code>float</code>, <code>double</code>, <code>uint</code> and <code>bool</code>. GLSL also features two container types:  <code>vectors</code> and <code>matrices</code>. </p>
<h3 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h3><p>A vector in GLSL is a 1,2,3 or 4 component container for any of the basic types just mentioned. They can take the following form (<code>n</code> represents the number of components):</p>
<ul>
<li><code>vecn</code>: the default vector of <code>n</code> floats.</li>
<li><code>bvecn</code>: a vector of <code>n</code> booleans.</li>
<li><code>ivecn</code>: a vector of <code>n</code> integers.</li>
<li><code>uvecn</code>: a vector of <code>n</code> unsigned integers.</li>
<li><code>dvecn</code>: a vector of <code>n</code> double components.</li>
</ul>
<p>You can use <code>.x</code>, <code>.y</code>, <code>.z</code> and <code>.w</code> to access their first, second, third and fourth component respectively.</p>
<h2 id="Ins-And-Outs"><a href="#Ins-And-Outs" class="headerlink" title="Ins And Outs"></a>Ins And Outs</h2><p>Each shader can specify inputs and outputs using those keywords and wherever an output variable matches with an input variable of the next shader stage they’re passed along. </p>
<p><code>The vertex shader differs in its input</code>, in that it receives its input straight from the vertex data(given by user). </p>
<p><code>When we&#39;re talking specifically about the vertex shader each input variable is also known as a vertex attribute.</code></p>
<p>To define how the vertex data is organized we specify the input variables with location metadata so we can configure the vertex attributes on the CPU. </p>
<p>The vertex shader thus requires an extra layout specification for its inputs so we can link it with the vertex data.</p>
<p>The other exception is that <code>the fragment shader requires a vec4 color output variable</code>, since the fragment shaders needs to generate a final output color. If you fail to specify an output color in your fragment shader, the color buffer output for those fragments will be undefined (which usually means OpenGL will render them either black or white).</p>
<p>So if we want to send data from one shader to the other we’d have to declare an output in the sending shader and a similar input in the receiving shader. When the types and the names are equal on both sides OpenGL will link those variables together and then it is possible to send data between shaders (this is done when linking a program object). </p>
<h2 id="Uniforms"><a href="#Uniforms" class="headerlink" title="Uniforms"></a>Uniforms</h2><p>Uniforms are another way to pass data from our application on the CPU to the shaders on the GPU. Uniforms are however slightly different compared to vertex attributes. First of all, uniforms are global. Global, meaning that a uniform variable is <code>unique per shader program object</code>, and can be <code>accessed from any shader at any stage in the shader program</code>. Second, whatever you set the uniform value to, uniforms will keep their values until they’re either reset or updated.</p>
<p><code>If you declare a uniform that isn&#39;t used anywhere in your GLSL code the compiler will silently remove the variable from the compiled version which is the cause for several frustrating errors; keep this in mind!</code></p>
<p>To fill an empty uniform variable, we first need to find the index/location of the uniform attribute in our shader. Once we have the index/location of the uniform, we can update its values. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="keyword">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<p>Note that finding the uniform location does not require you to use the shader program first, but updating a uniform <strong>does</strong> <code>require you to first use the program</code> (by calling glUseProgram), <code>because it sets the uniform on the currently active shader program.</code></p>
<p>As you can see, uniforms are a useful tool for setting attributes that may change every frame, or for interchanging data between your application and your shaders, but what if we want to set a color for each vertex? In that case we’d have to declare as many uniforms as we have vertices. A better solution would be to include more data in the vertex attributes.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
