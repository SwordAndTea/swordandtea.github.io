<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="xiangwei&#39;s blog">
<meta property="og:url" content="http://swordandtea.github.io/page/5/index.html">
<meta property="og:site_name" content="xiangwei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SwordAndTea">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>xiangwei's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiangwei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/02/20/machine_learning/neural_network&deep_learning/parameter-initialization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/machine_learning/neural_network&deep_learning/parameter-initialization/" class="post-title-link" itemprop="url">parameter_initialization</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-20 17:27:22" itemprop="dateCreated datePublished" datetime="2021-02-20T17:27:22+08:00">2021-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-23 20:43:34" itemprop="dateModified" datetime="2021-02-23T20:43:34+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index">
                    <span itemprop="name">machine learning</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>576</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在深度学习中，参数初始化也是很重要的一步，糟糕的初始参数可能会导致模型在训练时遇到<code>梯度消失</code>和<code>梯度爆炸</code>这两个情况</p>
<h1 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h1><p>梯度消失是指在训练是，参数的梯度变为0，或者是非常接近0，导致参数在迭代过程中不再更新或者说更新很小。</p>
<p>除了糟糕的初始化参数，<font color="orange">另外一个导致梯度消失原因是激活函数的选择</font>，曾经，sigmoid函数$\frac{1}{1+e^{-x}}$常常作为激活函数，但是sigmoid函数的梯度在自变量较小和自变量较大时，对应的导数值都非常接近0，所以水用sigmoid激活函数往往会导致梯度消失的问题。所以现在大家基本上都选择ReLU函数作为默认的激活函数。</p>
<h1 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h1><p>梯度爆炸是指在训练时，参数的梯度变得非常大。</p>
<h1 id="参数对称问题"><a href="#参数对称问题" class="headerlink" title="参数对称问题"></a>参数对称问题</h1><p>如果初始化参数时，如果参数出现很多相似的参数，那个就可能会导致多个神经元表现得像一个神经元。一个极端的例子，如果在输出化参数时，所有参数都初始化为一个常数，如果输入样本的特征也是相同的话，那么对于每次迭代，每个参数的偏导数值也是相同的，更新之后的值也是相同的，那么这些神经元就和一个神经元的效果一样了。</p>
<h1 id="参数初始化的方法"><a href="#参数初始化的方法" class="headerlink" title="参数初始化的方法"></a>参数初始化的方法</h1><h2 id="Default-Initialization"><a href="#Default-Initialization" class="headerlink" title="Default Initialization"></a>Default Initialization</h2><p>在使用深度学习框架创建网络时，如果是传入模型初始化方法的参数，则会使用深度学习框架默认的参数初始化方法，通常不会出现什么大问题。</p>
<h2 id="Xavier-Initialization"><a href="#Xavier-Initialization" class="headerlink" title="Xavier Initialization"></a>Xavier Initialization</h2><p>Xavier Initialization使用期望为0，方差为$\frac{2}{n_{in} + n_{out}}$的正态分布来初始化参数，其中$n_{in}$为<font color="orange">当前层</font>的输入神经元个数，$n_{out}$为当前层的输出神经元的个数，即下一层神经元的个数。</p>
<h1 id="others"><a href="#others" class="headerlink" title="others"></a>others</h1><p>神经网络中的参数初始化方法也是目前研究的一个领域</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/02/13/machine_learning/neural_network&deep_learning/dropout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/13/machine_learning/neural_network&deep_learning/dropout/" class="post-title-link" itemprop="url">dropout</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-13 10:49:18" itemprop="dateCreated datePublished" datetime="2021-02-13T10:49:18+08:00">2021-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-03 20:43:35" itemprop="dateModified" datetime="2021-04-03T20:43:35+08:00">2021-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index">
                    <span itemprop="name">machine learning</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>811</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通常，在深度学习任务中，我们可以通过在损失函数中添加正则化项来避免过拟合，L2正则化项是通常使用的正则化项，L2正则化项使得模型最终的权重值分布比较均匀，<font color="orange">使用L2正则化项时，我们就假设了我们的模型的对于样本的每个特征都相似的看重，而不只是看重某几个可能是关键特征的特征。</font></p>
<font color="orange">对于线形模型，在样本特征多样本数量少的情况下，线形模型很有可能会过拟合，但是只要增加样本数量，线形模型大概率就能摆脱过拟合的风险。</font>但是线形这种可靠的特性也是有代价的，线形模型不关系样本特征之间的关系。对于每个样本特征，线形模型就只是要么给一个正的权重或者负的权重，而不会考虑任何背景信息。

不同于线形模型，神经网络通常不会独立对待每个样本特征，神经网络能够学习样本之间的关系，<font color="red">但是，对于深度神经网络来说，即使样本数量远远多于样本特征，深度神经网络仍然会有过拟合的风险。</font>

<p>同时来说，使用简单的模型可以避免过拟合。使用更少纬度的特征、使用正则化项让权重值分布比较均匀都可以让模型变得简单。另外还有一种让模型变得简单的方法叫做<code>光滑(smoothness)</code>，即模型不会对输入的细微改变而敏感。</p>
<font color="orange">在神经网络中，训练时，对于每层网络向后传播的过程中，引入噪声就能让神经网络变得`光滑`，这种方法被叫做dropout。</font>这种方法已经成为了一种训练神经网络的标准方法。叫做dropout的原因是因为在训练时对于每层网络我们都会随机丢弃一些神经元。<font color="red">在丢弃神经元的时候，我们要保证丢弃后的该层网络神经元的期望值和丢弃前的值是一致的。</font>



<h1 id="dropout函数"><a href="#dropout函数" class="headerlink" title="dropout函数"></a>dropout函数</h1><p>在标准的dropout中，其定义为：对于<font color="orange">每层</font>的每个<font color="orange">神经</font>元，都有$p$的概率丢弃掉（置零），如果没有丢弃，则值变为$\frac{x}{1-p}$，$x$为该神经元的原始输出值。即：</p>
<script type="math/tex; mode=display">
x' = 
\begin{cases} 
    0, \space with \space probability \space p \\
    \frac{x}{1-p}, \space otherwise
\end{cases}</script><p>可以证明$E(x) = x$</p>
<h1 id="drop-out-代码实现"><a href="#drop-out-代码实现" class="headerlink" title="drop out 代码实现"></a>drop out 代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dropout_layer</span>(<span class="params">one_layer: tf.tensor, dropout_probability: <span class="built_in">float</span></span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= dropout_probability &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> dropout_probability == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># in this case, all elements are dropped out</span></span><br><span class="line">        <span class="keyword">return</span> tf.zeros_like(one_layer)  <span class="comment"># tf.zeros_like: create a tensor with all elements set to zero</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dropout_probability == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># in this case, all elements are kept</span></span><br><span class="line">        <span class="keyword">return</span> one_layer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tf.random.uniform: outputs random values from a uniform distribution.</span></span><br><span class="line">    <span class="comment"># with (1-p)&#x27;s probability that value will become x / (1-p)</span></span><br><span class="line">    mask = tf.random.uniform(shape=tf.shape(one_layer), minval=<span class="number">0</span>, maxval=<span class="number">1</span>) &lt; (<span class="number">1</span> - dropout_probability)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf.cast(mask, dtype=tf.float32) * one_layer / (<span class="number">1.0</span> - dropout_probability)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在框架中使用快速调用drop out</span></span><br><span class="line">net = tf.keras.models.Sequential([tf.keras.layers.Dense(<span class="number">256</span>, activation=tf.nn.relu,</span><br><span class="line">                                                        kernel_regularizer=tf.keras.regularizers.l2(<span class="number">0.3</span>)),</span><br><span class="line">                                  tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">                                  tf.keras.layers.Dense(<span class="number">256</span>, activation=tf.nn.relu,</span><br><span class="line">                                                        kernel_regularizer=tf.keras.regularizers.l2(<span class="number">0.3</span>)),</span><br><span class="line">                                  tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">                                  tf.keras.layers.Dense(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/02/04/machine_learning/neural_network&deep_learning/multilayer-perceptrons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/machine_learning/neural_network&deep_learning/multilayer-perceptrons/" class="post-title-link" itemprop="url">multilayer_perceptrons</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-04 07:41:24" itemprop="dateCreated datePublished" datetime="2021-02-04T07:41:24+08:00">2021-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-05 07:59:34" itemprop="dateModified" datetime="2021-02-05T07:59:34+08:00">2021-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index">
                    <span itemprop="name">machine learning</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>714</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h1><p>在许多学习任务中，样本的特征和输出标签之间并不是线形关系。对于单层神经网络，它的能处理的学习任务比较有限。我们可以通过在输入层和输出层之间增加一层或多层的隐藏层来解决增加模型的复杂度，来增加模型的学习能力。<font color="red">但是如果只是增加隐藏层，这个网络仍然是线形模型。</font>原因是每相邻的两层神经网络之间都是一个仿射变换，而仿射变换之上再叠加一个仿射变换，仍然是一个仿射变换。<font color="orange">所以为将线形的神经网络变成非线性的神经网络，我们需要引入激活函数。</font>激活函数决定一个一个神经元是否应该继续参与后续的计算。激活函数通常是非线性的函数。</p>
<h1 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h1><p>激活函数决定一个一个神经元是否应该继续参与后续的计算。激活函数通常是非线性的函数</p>
<h2 id="ReLU-Function"><a href="#ReLU-Function" class="headerlink" title="ReLU Function"></a>ReLU Function</h2><p>ReLu激活函数是最流行的一种激活函数，应为它的实现简单并且使用ReLU的神经网络效果也很好。它的定义如下：</p>
<script type="math/tex; mode=display">
ReLU(x) = max(x, 0)</script><p>即ReLU函数只保留正值的神经元，并且原封不动的进行传播，同时将所有负值的神经元丢弃。</p>
<p>对于ReLU函数的导数来说，当自变量小于0时，ReLU函数的梯度等于0，当自变量大于0时，函数的梯度等于1。但是当自变量的取值为0时，ReLu函数是不可导的。通常在工程上的处理是，当自变量为0时，认为梯度等于0。</p>
<h2 id="pReLU-Function"><a href="#pReLU-Function" class="headerlink" title="pReLU Function"></a>pReLU Function</h2><p>pReLU函数是ReLU函数的一个变种，它允许负值输入有限的向后传播：</p>
<script type="math/tex; mode=display">
pReLU(x) = max(0, x) + \alpha min(0, x)</script><h2 id="Sigmoid-Function"><a href="#Sigmoid-Function" class="headerlink" title="Sigmoid Function"></a>Sigmoid Function</h2><p>在logistic-regression中我们使用过sigmoid function来作为对输出的处理。同时sigmoid 函数也可以作为神经网络中的激活函数。</p>
<script type="math/tex; mode=display">
sigmoid(x) = \frac{1}{1+e^{(-x)}}</script><p>sigmoid函数将取值为任意实数的输入映射到一个（0，1）的区间，所以sigmoid函数也被叫做squashing函数。</p>
<p>sigmoid函数是一个光滑的，任意阶可导的函数，它的一阶导数在自变量为0时最大，从0向两边逐渐减小。</p>
<p>sigmoid function通常用于二分类任务神经网络输出层的激活函数。</p>
<h2 id="Tanh-Function"><a href="#Tanh-Function" class="headerlink" title="Tanh Function"></a>Tanh Function</h2><p>类似sigmoid function，tanh（hyperbolic tangent）也将实数范围内的输入挤压到（-1，1）之间的输出。</p>
<script type="math/tex; mode=display">
tanh(x) = \frac{1 - e^{(-2x)}}{1 + e^{(-2x)}}</script><p>tanh的函数图像和一阶导函数的图像和sigmoid函数十分类似。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/31/machine_learning/linear_model/softmax-regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/31/machine_learning/linear_model/softmax-regression/" class="post-title-link" itemprop="url">softmax_regress</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-31 16:17:48" itemprop="dateCreated datePublished" datetime="2021-01-31T16:17:48+08:00">2021-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-14 19:39:17" itemprop="dateModified" datetime="2023-03-14T19:39:17+08:00">2023-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index">
                    <span itemprop="name">machine learning</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>在多分类问题中，一些分类器是利用多个二分类器来做分类的，有些模型则能直接进行多分类学习。softmax-regress就是一种能够直接进行多分类学习的线形分类模型（虽然叫regress，但本身是分类模型，有点像logistic-regression）。</p>
<h1 id="one-hot-encoding"><a href="#one-hot-encoding" class="headerlink" title="one-hot encoding"></a>one-hot encoding</h1><p>对于多分类学习任务，我们通常会把可能的分类结果种类用数字来表示，例如对于一个可能有3种分类结果的学习任务，我们可以使用${1, 2, 3}$来分别表示第一类到第三类。如果使用这个自然序编码来对分类结果种类进行编码，那么对于每一个训练样本，我们需要的输出就只有一个。</p>
<p>使用自然序编码时，如果分类结果之间本身没有自然序的关系， 对于模型的输出和样本真实的标签之间的距离将不好表示。例如对于某个样本来说，模型的输出结果是1，表示第二类，但样本真实的标签为3，表示第3类，此时如果将距离定义为$|1-3| = 2$，这在分类结果之间本身没有自然序的关系的情况下显然是不太合理的。</p>
<p>另外一种表示分类结果的方法就是one-hot encoding。one-hot encoding将每一种分类结果用一个向量表示，例如，还是对于一个可能有3种分类结果的学习任务，我们可以使用${ {1, 0, 0}, {0, 1, 0}, {0, 0, 1} }$来分别表示第一类到第三类，这样每个种类之间可以看作是没有直接关系的（种类的表示向量之间两两正交）。</p>
<p>所以，对于种类之间有自然序关系的分类学习任务，可以使用自然序来对结果进行编码。但是如果种类之间没有自然序关系，应该尽量使用one-hot encoding。</p>
<p>softmax-regression模型使用的就是one-hot encoding来对分类结果进行表示。</p>
<h1 id="softmax-regression-网络结构"><a href="#softmax-regression-网络结构" class="headerlink" title="softmax-regression 网络结构"></a>softmax-regression 网络结构</h1><p>对于一个有n个输入特征，m个可能分类结果的网络来说，其结构为：</p>
<script type="math/tex; mode=display">
o_1 = x_1w_{11} + x_2w_{21} + \dots + x_nw_{n1} + b_1 \\
o_2 = x_1w_{12} + x_2w_{22} + \dots + x_nw_{n2} +b_2 \\
\dots \\
o_m = x_1w_{1m} + x_2w_{2m} + \dots + x_nw_{nm} + b_m</script><p>由此可见一个softmax-regression网络是一个单层的全连接网络。</p>
<p><img src="/2021/01/31/machine_learning/linear_model/softmax-regression/softmax_regression_net_structure.png" alt="net structure" style="zoom:50%;"></p>
<h1 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h1><p>在softmax-regression的网络中，我们可将每个输出看作一个样本可能是某一类别的概率，输出结果最大的那个就是最有可能的分类结果。但是最为概率，就需要输出的值位于$[0, 1]$之间，并且所有值之和为1。这对于使用线形模型的输出来说有些困难。所以为了保证让网络输出的结果能够作为概率，需要对输出作为进一步处理，保证输出的结果必须为非负并且和为1。softmax函数就是一个这样的函数:</p>
<script type="math/tex; mode=display">
y_i = softmax(o_i) = \frac{e^{(oi)}}{\sum_{j=0}^{m} e^{(o_j)}}</script><font color="orange">虽然softmax函数不是一个线性函数，但是softmax-regression的输出仍然是由输入特征的线形变换（仿射变换）决定的，所以softmax-regression仍然是一个线形模型。</font>

<h1 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h1><p>交叉熵是一个信息论中的概念，它衡量了预测的概率分布和真实的概率分布之间的差异。在softmax-regression中，可以将网络预测的输出看作预测的概率分布，将样本的真实类别对应的ont-hot编码看作是真实概率分布，这样就可以定义模型的损失函数了。其定义如下：</p>
<script type="math/tex; mode=display">
l(\hat{y}, y) = - \sum_{j=0}^M y_j \space log \space \hat{y_j}</script><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>有了模型和损失函数后，就可以使用随机梯度下降法（Stochastic Gradient Descent）对模型进行训练了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> liner_regression.fashion_mnist_dataset <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># read data</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_data_iter, test_data_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initial model parameters</span></span><br><span class="line"><span class="comment"># each image in dataset is a 28 * 28 image, in this section, we will flatten each image,</span></span><br><span class="line"><span class="comment"># treat them as vectors of length 784</span></span><br><span class="line"><span class="comment"># so X&#x27;s size is 256 * 784, W&#x27;s size is 784 * 10, b&#x27;s size is 1 * 10, y&#x27;s size is 256 * 10 (y = softmax(XW + b))</span></span><br><span class="line">num_inputs = <span class="number">28</span> * <span class="number">28</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = tf.Variable(tf.random.normal(shape=(num_inputs, num_outputs), mean=<span class="number">0</span>, stddev=<span class="number">0.01</span>))</span><br><span class="line">b = tf.Variable(tf.zeros(num_outputs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define softmax operation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">linear_result: tf.Variable</span>):</span><br><span class="line">    <span class="comment"># if linear_result is n * m matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># exped is n * m matrix</span></span><br><span class="line">    exped = tf.exp(linear_result)</span><br><span class="line">    <span class="comment"># sum_of_each_line is n * 1 matrix, if keepdims=False, then sum_of_each_line will be 1 * n matrix</span></span><br><span class="line">    sum_of_each_line = tf.reduce_sum(exped, <span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> exped / sum_of_each_line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define modal</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">data_x, param_w, param_b</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(tf.matmul(data_x, param_w) + param_b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define loss, use cross-entropy loss</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">predicted_y, label_y</span>):</span><br><span class="line">    <span class="comment"># predicted_y is a n * m matrix, then label_y is a 1 * n matrix</span></span><br><span class="line">    <span class="comment"># in this example, predicted_y is 256 * 10, label_y = 1 * 256</span></span><br><span class="line">    <span class="keyword">return</span> -tf.math.log(tf.boolean_mask(predicted_y, tf.one_hot(label_y, depth=predicted_y.shape[-<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define optimizer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stochastic_gradient_descent</span>(<span class="params">params, gradients, batch_size, learning_rate: <span class="built_in">float</span></span>):</span><br><span class="line">    <span class="comment"># Because our loss is calculated as a sum over the mini-batch of examples,</span></span><br><span class="line">    <span class="comment"># we normalize our step size by the batch size (batch_size),</span></span><br><span class="line">    <span class="comment"># so that the magnitude of a typical step size does not depend heavily on our choice of the batch size.</span></span><br><span class="line">    <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(params, gradients):</span><br><span class="line">        param.assign_sub(grad * learning_rate / batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># classification accuracy</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">predicted_y, label_y</span>):</span><br><span class="line">    <span class="comment"># predicted_y is a n * m matrix, then label_y is a 1 * n matrix</span></span><br><span class="line">    <span class="comment"># in this example, predicted_y is 256 * 10, label_y = 1 * 256</span></span><br><span class="line">    <span class="comment"># tf.argmax returns the index with the largest value across axes of a tensor.</span></span><br><span class="line">    predicted_y = tf.argmax(predicted_y, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cmp is a 1 * n `boolean` matrix</span></span><br><span class="line">    cmp = tf.cast(predicted_y, label_y.dtype) == label_y</span><br><span class="line">    <span class="comment"># return num of right predictions and the total num of predictions</span></span><br><span class="line">    <span class="keyword">return</span> tf.reduce_sum(tf.cast(cmp, label_y.dtype)), label_y.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        num_right_predictions = <span class="number">0</span></span><br><span class="line">        num_total_predictions = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> train_data_iter:</span><br><span class="line">            <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> g:</span><br><span class="line">                x = tf.reshape(x, shape=(x.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">                y_hat = net(x, W, b)</span><br><span class="line">                l = cross_entropy(y_hat, y)</span><br><span class="line"></span><br><span class="line">            dw, db = g.gradient(l, [W, b])</span><br><span class="line">            stochastic_gradient_descent([W, b], [dw, db], batch_size, <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">            right_pred, total_pred = accuracy(y_hat, y)</span><br><span class="line">            num_right_predictions += right_pred</span><br><span class="line">            num_total_predictions += total_pred</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;accuracy after one epoch is : &#x27;</span>, <span class="built_in">float</span>(num_right_predictions) / <span class="built_in">float</span>(num_total_predictions))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main&quot;</span>:</span><br><span class="line">    train()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/15/others/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/others/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">常用git命令总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-15 17:29:14" itemprop="dateCreated datePublished" datetime="2021-01-15T17:29:14+08:00">2021-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-06 15:08:26" itemprop="dateModified" datetime="2022-06-06T15:08:26+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="clone-仓库相关"><a href="#clone-仓库相关" class="headerlink" title="clone 仓库相关"></a>clone 仓库相关</h1><p>git clone仓库有两种形式，一种是以ssh协议的形式，另外一种是以https协议的形式。使用ssh协议的形式时，需要将ssh公钥上传到github或者gitlab。使用https协议需要在clone的时候输入github或者gitlab的账号和密码。</p>
<ul>
<li><code>git clone [-b &lt;branch name&gt;] &lt;repository url&gt;</code> <ul>
<li>-b 执行需要拉取的分支，不指定则拉取master分支</li>
</ul>
</li>
<li><code>git clone https://&lt;username&gt;:&lt;password&gt;@&lt;repository url&gt;</code><ul>
<li>在使用https协议拉取仓库的时候，直接在url中指定账户和密码，@作为分割符，如果账户或者密码中含有“@”符，则需要将其替换为“%40”</li>
</ul>
</li>
</ul>
<h1 id="工作区、暂存区状态相关"><a href="#工作区、暂存区状态相关" class="headerlink" title="工作区、暂存区状态相关"></a>工作区、暂存区状态相关</h1><ul>
<li><p><code>git status</code></p>
<ul>
<li>查看工作区和暂存区的文件状态</li>
</ul>
</li>
<li><p><code>git add &lt;filename&gt;</code></p>
<ul>
<li>将工作区的某个文件添加到暂存区</li>
</ul>
</li>
<li><p><code>git add .</code></p>
<ul>
<li>将工作区全部文件添加到暂存区</li>
</ul>
</li>
<li><p><code>git commit -m&quot;[commit message]&quot;</code></p>
<ul>
<li>提交暂存区的文件修改到本地仓库</li>
</ul>
</li>
<li><p><code>git rm &lt;filename&gt;</code></p>
<ul>
<li>取消对文件的追踪</li>
</ul>
</li>
</ul>
<h1 id="提交历史相关"><a href="#提交历史相关" class="headerlink" title="提交历史相关"></a>提交历史相关</h1><ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit [filename]</code><ul>
<li>查看当前分支的提交历史</li>
<li>—graph：以图表的新式</li>
<li>—pretty=oneline：只显示commit信息，不显示提交作者和时间等其他信息</li>
<li>—abbrev-commit：commit id以简写的形式展示</li>
<li>filename: 可选项，只显示某个文件的提交历史</li>
</ul>
</li>
<li><code>git reflog</code><ul>
<li>查看操作记录，<font color="red">借助该命令可以取消版本回退。</font></li>
</ul>
</li>
<li><code>git reset [--soft|--mixed|--hard] HEAD^</code><ul>
<li>将当前分支的提交回退到上一个提交</li>
<li>—soft：当前提交修改会保存到暂存区，并且<font color="orange">当前工作区和暂存区的修改也会保留</font></li>
<li>—mix：当前提交的修改会保存到工作区，并且<font color="orange">当前暂存区的修改都会移到工作区</font></li>
<li>—hard: 丢弃当前提交的修改，并且<font color="red">丢弃当前工作区和暂存区的修改</font></li>
<li><font color="orange">--mix是默认的选项</font></li>
<li>一个快速清除当前暂存区和工作区的命令：<code>git add . &amp;&amp; git reset --hard HEAD</code>。注意没有”^”，否则就回退到了上个提交</li>
</ul>
</li>
<li><code>git reset [--soft|--mixed|--hard] HEAD~&lt;number&gt;</code><ul>
<li>回退当前分支提交到上number个版本</li>
</ul>
</li>
<li><code>git reset [--soft|--mixed|--hard] HEAD &lt;commit id&gt;</code><ul>
<li>回退当前分支提交到指定的commit id</li>
</ul>
</li>
<li><code>git checkout &lt;commit id&gt; &lt;filename&gt;</code><ul>
<li>只将某个文件回退到某个版本</li>
</ul>
</li>
</ul>
<h1 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h1><ul>
<li><p><code>git branch</code></p>
<ul>
<li>查看本地有哪些分支</li>
</ul>
</li>
<li><p><code>git branch &lt;branch name&gt;</code></p>
<ul>
<li>创建分支，但是目前仍然位于当前分支</li>
</ul>
</li>
<li><p><code>git branch &lt;branch name&gt; &lt;commit id&gt;</code></p>
<ul>
<li>基于commit id创建分支，目前仍位于当前分支</li>
</ul>
</li>
<li><p><code>git checkout -b &lt;branch name&gt;</code></p>
<ul>
<li>创建并切换分支</li>
</ul>
</li>
<li><p><code>git checkout -b &lt;branch name&gt; &lt;commit id&gt;</code></p>
<ul>
<li>基于某个commit id创建并切换分支</li>
</ul>
</li>
<li><p><code>git checkout &lt;branch name&gt;</code></p>
<ul>
<li>切换分支，<font color="orange">如果本地没有对应分支但是远程仓库有</font>，则将对应的远程分支拉取到本地并切换到对应分支</li>
</ul>
</li>
<li><p><code>git branch -d &lt;branch name&gt;</code></p>
<ul>
<li>删除分支，如果分支有提交但是没有合入其他分支，会报错</li>
</ul>
</li>
<li><p><code>git branch -D &lt;branch name&gt;</code></p>
<ul>
<li>强制删除某个分支</li>
</ul>
</li>
<li><p><code>git checkout -f &lt;branch name&gt;</code></p>
<ul>
<li>强行切换到某个分支，<font color="red">如果当前工作区和暂存区有内容，将丢弃这些内容</font></li>
</ul>
</li>
</ul>
<h1 id="合并相关"><a href="#合并相关" class="headerlink" title="合并相关"></a>合并相关</h1><ul>
<li><p><code>git merge &lt;branch name&gt;</code></p>
<ul>
<li>将branch name对应的分支合并到当前分支</li>
<li>如果合并有冲突，需要手动解决冲突（到有冲突的文件进行编辑）后，执行add和commit</li>
</ul>
</li>
</ul>
<h1 id="远程仓库相关"><a href="#远程仓库相关" class="headerlink" title="远程仓库相关"></a>远程仓库相关</h1><ul>
<li><code>git remote add origin &lt;remote repository url&gt;</code><ul>
<li>关联远程仓库</li>
</ul>
</li>
<li><code>git remote remove origin</code><ul>
<li>取消关联远程仓库</li>
</ul>
</li>
<li><code>git push origin &lt;branch&gt;</code><ul>
<li>将本地分支的commit推送到到远程分支</li>
</ul>
</li>
<li><code>git push --force-with-lease origin &lt;branch&gt;</code><ul>
<li>以最小强制更新的手段，将本地分支推送到远程分支</li>
<li><font color="red">尽量不要强制推送远程分支，尤其是其他人开发的分支</font></li>
</ul>
</li>
<li><code>git push origin --delete &lt;branch&gt;</code><ul>
<li>删除远程分支</li>
</ul>
</li>
</ul>
<h1 id="子模块相关"><a href="#子模块相关" class="headerlink" title="子模块相关"></a>子模块相关</h1><ul>
<li><p><code>git submodule add &lt;repository&gt; &lt;dir&gt;</code></p>
<ul>
<li>添加子模块，子模块的链接为url，添加到相对于当前目录的dir目录下</li>
</ul>
</li>
<li><p><code>git submodule init</code></p>
<ul>
<li>读取本地子模块配置文件</li>
</ul>
</li>
<li><p><code>git submodule update</code></p>
<ul>
<li>拉取子模块</li>
</ul>
</li>
<li><p><code>git submoduel update &lt;submodule dir path&gt;</code></p>
<ul>
<li>拉取指定的子模块</li>
</ul>
</li>
<li><p><code>git clone --recurse-submodules</code></p>
<ul>
<li>拉取带有子模块的仓库时，同时也拉取子模块</li>
</ul>
</li>
</ul>
<h1 id="tag相关"><a href="#tag相关" class="headerlink" title="tag相关"></a>tag相关</h1><ul>
<li><code>git tag</code><ul>
<li>查看所有的标签</li>
</ul>
</li>
<li><code>git tag &lt;tag name&gt;</code><ul>
<li>创建一个轻量标签，轻量标签建议在创建临时标签时使用</li>
</ul>
</li>
<li><code>git tag -a &lt;tag name&gt; -m &lt;tag message&gt;</code><ul>
<li>创建一个附注标签，正式标签使用</li>
</ul>
</li>
<li><code>git show &lt;tag name&gt;</code><ul>
<li>查看标签信息和与之对应的提交信息</li>
</ul>
</li>
<li><code>git push origin &lt;tag name&gt;</code><ul>
<li>将标签推送到远程仓库</li>
</ul>
</li>
<li><code>git tag -d &lt;tag name&gt;</code><ul>
<li>删除本地标签</li>
</ul>
</li>
<li><code>git push origin --delete &lt;tag name&gt;</code><ul>
<li>删除远程标签</li>
</ul>
</li>
</ul>
<h1 id="rebase相关"><a href="#rebase相关" class="headerlink" title="rebase相关"></a>rebase相关</h1><ul>
<li><code>git rebase &lt;branch name&gt;</code><ul>
<li>将当前分支rebase到branch name对应的分支</li>
</ul>
</li>
<li><code>git rebase -i HEAD~&lt;num&gt;</code><ul>
<li>将当前提交和当前提交前的共num个提交合并为</li>
</ul>
</li>
<li><code>git rebase --abort</code><ul>
<li>rebase 有冲突时，取消rebase</li>
</ul>
</li>
<li><code>git rebase --continue</code><ul>
<li>rebase 冲击解决后，继续执行rebase操作</li>
</ul>
</li>
</ul>
<h1 id="stash-相关"><a href="#stash-相关" class="headerlink" title="stash 相关"></a>stash 相关</h1><p>stash 通常用于当前在一个分支有代码的更新放在工作区或者暂存区，但是需要临时去处理其他分支的代码，又不行在当前分支进行提交操作，那么可以先将当前分支中工作区和暂存区的代码stash起来，之后再pop回来。</p>
<ul>
<li><code>git stash save &lt;message&gt;</code><ul>
<li>将当前工作区和暂存区的修改保存到其他地方，并将当前工作区和暂存区清空</li>
</ul>
</li>
<li><code>git stash list</code><ul>
<li>查看stash 的列表</li>
</ul>
</li>
<li><code>git stash pop [index | stash_id]</code> <ul>
<li>如果不传index或者stash id参数，将stash列表的最后一个stash恢复到工作区和暂存区，并将该stash从stash list中删除</li>
<li><font color="red">stash list的存储结构是一个栈结构，最后stash的stash id最小，也最新被pop出来</font></li>
<li>如果传入index或者stash id参数，则将其对应的stash恢复到工作去和暂存区，并将该stash从stash list中删除</li>
</ul>
</li>
<li><code>git stash apply [index | stash_id]</code><ul>
<li>除了不删除对应的stash外，其他 和 <code>git stash pop</code>相同</li>
</ul>
</li>
<li><code>git stash drop [stash id]</code><ul>
<li>删除一个存储进度</li>
</ul>
</li>
<li><code>git stash clear</code><ul>
<li>清除stash list</li>
</ul>
</li>
</ul>
<h1 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h1><ul>
<li><code>.gitignore</code><ul>
<li>记录git应该不对哪些文件进行跟踪的配置</li>
</ul>
</li>
<li><code>.gitmoduels</code><ul>
<li>记录子模块信息的文件</li>
</ul>
</li>
<li><code>.gitattributes</code><ul>
<li>git-lfs应该处理的文件信息</li>
</ul>
</li>
<li><code>.gitlab-ci.yml</code><ul>
<li>gitlab ci配置文件</li>
</ul>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><p>git-lfs</p>
<ul>
<li><p>git大文件处理工具</p>
</li>
<li><p><code>git lfs install</code>：开启lfs</p>
</li>
<li><p><code>git lfs track *.zip</code>：将zip文件作为lfs文件管理</p>
</li>
<li><p><code>GIT_LFS_SKIP_SMUDGE=1 git xxx</code>：此次操作不会去下载lfs文件</p>
</li>
</ul>
</li>
<li>分离头指针<ul>
<li>当前HEAD指针所指向的commit没有和任何分支关联，这种情况一般出现在直接从某个commit checkout出来的情况（即执行了<code>git checkout &lt;commit id&gt;</code> ）。<font color="red">如果在分离头指针进行了代码修改并提交后，再切换到其他分支，那么这个提交就会丢失，活都白干了。</font>正确做法是为该分离的头指针创建branch进行关联，这时执行<code>git checkout -b &lt;branch&gt;</code>即可。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/06/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">原型模式与单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-06 17:09:24" itemprop="dateCreated datePublished" datetime="2021-01-06T17:09:24+08:00">2021-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:02:33" itemprop="dateModified" datetime="2021-03-03T17:02:33+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>68</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原型模式简介"><a href="#原型模式简介" class="headerlink" title="原型模式简介"></a>原型模式简介</h1><p>原型模式将对象的复制过程交给被复制的实际对象本身。原型模式为所有支持复制的对象声明了一个通用接口，该接口能够让你克隆对象。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2021/01/02/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">生成器模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-02 16:27:31" itemprop="dateCreated datePublished" datetime="2021-01-02T16:27:31+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:02:18" itemprop="dateModified" datetime="2021-03-03T17:02:18+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>生成器模式使你能够<font color="red">分步</font>创建复杂对象。假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中。</p>
<p>例如你想要示例化一个有车库、带游泳池和花园的房子对象。</p>
<p>一种实现方式是：设计一个”House”的基类，并让每种类型的房子继承自这个”House”基类，例如”HouseWithGarage”、”HouseWithGarden”、”HouseWithGarageAndGraden”等等。但是这种方式的结果就是你可能需要编写许多子类代码。</p>
<p>另外一种实现方式：无需生成子类，只设计一个”House”的类，同时这个”House”类拥有一个包括所有可能参数的超级构造函数，例如<code>House(bool hasGarage, bool hasGraden, bool hasSwimmingPool, ...)</code>。这种方式可以避免生成子类，但是如果需要增加一种房子类型，那么就不得不修改构造函数，这可能会导致使用之前构造函数的代码失效。另外这个超级构造函数中可能大多数参数最后都没有实际被使用到，导致构造函数的调用形式不简洁。</p>
<p>这种情况就可以考虑使用生成器模式了。</p>
<h2 id="生成器模式简介"><a href="#生成器模式简介" class="headerlink" title="生成器模式简介"></a>生成器模式简介</h2><p>生成器模式将构造对象的代码从产品类中抽取出来，并将其放在一个名为生成器的独立类中。当创建对象的时候，是需要按需调用生成器提供的构造步骤即可。在一下情况下，你需要设计多种类型的生成器来构建出有相同接口但是表现形式不同的对象。</p>
<p>另外，你可以将用于创建对象的一系列的生成器调用步骤抽取出来形成一个单独的主管类。主管类非常适合放入各种例行构造流程，以便在程序中反复使用。</p>
<h2 id="生成器代码样例"><a href="#生成器代码样例" class="headerlink" title="生成器代码样例"></a>生成器代码样例</h2><p>一个创建汽车和汽车使用手册的设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//other class a car builder that need</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarEngine</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPS</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//a pure abstract class to use as an interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSeats</span><span class="params">(<span class="type">int</span> number)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setEngine</span><span class="params">(<span class="type">const</span> CarEngine &amp;engine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setGPS</span><span class="params">(<span class="type">const</span> GPS &amp;gps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>;</span><br><span class="line"><span class="comment">//a car builder that build car itself</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarCarBuilder</span>: <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car *_car;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_car) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _car;</span><br><span class="line">        &#125;</span><br><span class="line">        _car = <span class="keyword">new</span> <span class="built_in">Car</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSeats</span><span class="params">(<span class="type">int</span> number)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//set seat for car itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setEngine</span><span class="params">(<span class="type">const</span> CarEngine &amp;engine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//set engine for car itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setGPS</span><span class="params">(<span class="type">const</span> GPS &amp;gps)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//set gps for car itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _car;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManual</span>;</span><br><span class="line"><span class="comment">//a car builder that build car&#x27;s manual</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span>: <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CarManual *_manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_manual) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _manual;</span><br><span class="line">        &#125;</span><br><span class="line">        _manual = <span class="keyword">new</span> <span class="built_in">CarManual</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="built_in">setSeats</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">//add description for how to use seats in manual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="built_in">setEngine</span>(<span class="type">const</span> CarEngine &amp;engine) <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">//add car engine description in manual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="built_in">setGPS</span>(<span class="type">const</span> GPS &amp;pgs) <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">//add gps use guide in manual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> CarManual* <span class="built_in">getResult</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _manual;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a manager class that use builder to build car</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarCarBuilderDirector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">buildSUV</span><span class="params">(CarBuilder &amp;builder)</span> </span>&#123;</span><br><span class="line">        builder.<span class="built_in">setSeats</span>(<span class="number">4</span>);</span><br><span class="line">        NormalEngine normalEngine;</span><br><span class="line">        builder.<span class="built_in">setEngine</span>(normalEngine);</span><br><span class="line">        NormalGPS normalGps;</span><br><span class="line">        builder.<span class="built_in">setGPS</span>(normalGps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car* <span class="title">buildSportsCar</span><span class="params">(CarBuilder &amp;builder)</span> </span>&#123;</span><br><span class="line">        builder.<span class="built_in">setSeats</span>(<span class="number">2</span>);</span><br><span class="line">        SportEngine sportEngine;</span><br><span class="line">        builder.<span class="built_in">setEngine</span>(sportEngine);</span><br><span class="line">        SportCarGPS sportCarGps;</span><br><span class="line">        builder.<span class="built_in">setGPS</span>(sportCarGps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在CarCarBuilderDirector这个生成器主管类可以创建SUV类型的车辆对象，也可以创建SportsCar类型的对象。但在上例中我们没有定义基于CarBuilder接口的SUVCarBuilder类和SportsCarBuilder类。不是说不可以，而是说要结合具体的实际情况判断是否需要再定义SUVCarBuilder和SportsCarBuilder类，如果创建SUV和创建SportsCar的实现方式有差别的话，那么就可以再去定义SUVCarBuilder类和SportsCarBuilder类。</p>
<p>另外，我们在生成器接口中并没有提供获取构造结果对象的方法，因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</p>
<p>总之还是那句话，<font color="red">不基于实际应用场景的设计模式都是耍流氓</font>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。</p>
<p>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/28/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/design_patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工厂模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-28 09:08:46" itemprop="dateCreated datePublished" datetime="2020-12-28T09:08:46+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:02:05" itemprop="dateModified" datetime="2021-03-03T17:02:05+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>624</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式保护简单工厂模式、工厂方法模式、抽象工厂模式</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="简单工厂模式简介"><a href="#简单工厂模式简介" class="headerlink" title="简单工厂模式简介"></a>简单工厂模式简介</h2><ul>
<li><font color="red">一个</font>抽象产品类，根据这个抽象产品类可派生出多个具体产品类</li>
<li><font color="red">一个</font>具体工厂类，具体工厂类用于生产多个具体产品类</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIDrawable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw button code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBox</span>: <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw check box code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GUIType</span> &#123;</span><br><span class="line">    GUITypeButton,</span><br><span class="line">    GUITypeCheckBox,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">GUIDrawable* <span class="title">create</span><span class="params">(GUIType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> GUITypeButton:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Button</span>();</span><br><span class="line">            <span class="keyword">case</span> GUITypeCheckBox:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CheckBox</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="工厂方法模式简介"><a href="#工厂方法模式简介" class="headerlink" title="工厂方法模式简介"></a>工厂方法模式简介</h2><ul>
<li><font color="red">一个</font>抽象产品类，根据这个抽象产品类可派生出多个具体产品类</li>
<li><font color="red">一个</font>抽象工厂类，可以派生出多个具体工厂类</li>
<li><font color="red">每个</font>具体工厂只能创建<font color="red">一个</font>具体产品</li>
</ul>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIDrawable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw button code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBox</span>: <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw check box code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIDrawableFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GUIDrawable* <span class="title">create</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GUIDrawable* <span class="title">create</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Button</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBoxFactory</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GUIDrawable* <span class="title">create</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CheckBox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="抽象工厂模式简介"><a href="#抽象工厂模式简介" class="headerlink" title="抽象工厂模式简介"></a>抽象工厂模式简介</h2><ul>
<li><font color="red">多个</font>抽象产品类，每个抽象产品类可以派生出多个具体产品类</li>
<li><font color="red">一个</font>抽象工厂类，可以派生出多个具体工厂类</li>
<li><font color="red">每个</font>具体工厂可以创建<font color="red">多个</font>具体产品</li>
</ul>
<h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIDrawable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="keyword">public</span> GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clicked</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBox</span>: GUIDrawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">checked</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span>: Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw win button code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clicked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckBox</span>: CheckBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw win label code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">checked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span>: Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw mac button code here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clicked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckBox</span>: CheckBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//draw mac label code here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">checked</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CheckBox* <span class="title">createCheckBox</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinGUIFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WinButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CheckBox* <span class="title">createCheckBox</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WinCheckBox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacGUIFactory</span>: <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CheckBox* <span class="title">createLabel</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MacCheckBox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在许多设计工作的初期都会使用简单工厂模式，随后演化为使用工厂方法模式， 随后演化为使用抽象工厂模式，甚至继续演化为使用原型模式或生成器模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/27/design_patterns/design-pattern-first-of-all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/design_patterns/design-pattern-first-of-all/" class="post-title-link" itemprop="url">design_pattern_first_of_all</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-27 21:32:23" itemprop="dateCreated datePublished" datetime="2020-12-27T21:32:23+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-03 17:01:21" itemprop="dateModified" datetime="2021-03-03T17:01:21+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>150</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font color="red">设计模式应该作为代码编写的一种指导，而不是一种准则，任何不结合实际应用场景的设计模式都是耍流氓。</font>

<p>设计模式中主要涉及到三种类型的设计模式：创建型模式（construct design pattern）、结构型模式（structure design pattern）、行为模式（behavior design pattern）。</p>
<ul>
<li>创建型模式主要关注如何合理地构造对象</li>
<li>结构型模式主要关注如何组织一个系统内部的各个类</li>
<li>行为模式主要定义类与类之间交互的方式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/19/Linux/Linux%E5%91%BD%E4%BB%A4%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/Linux/Linux%E5%91%BD%E4%BB%A4%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">Linux命令初步</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-19 22:35:25" itemprop="dateCreated datePublished" datetime="2020-12-19T22:35:25+08:00">2020-12-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/12/01/av_processing/video/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/av_processing/video/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">图像基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-01 09:08:46" itemprop="dateCreated datePublished" datetime="2020-12-01T09:08:46+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-28 20:15:19" itemprop="dateModified" datetime="2020-12-28T20:15:19+08:00">2020-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/video-processing/" itemprop="url" rel="index">
                    <span itemprop="name">video processing</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是颜色"><a href="#什么是颜色" class="headerlink" title="什么是颜色"></a>什么是颜色</h1><p>颜色是有不同波长的光发出的能量对人眼产生刺激后，人产生的一种感觉。</p>
<ul>
<li>不同波长的电磁波对应不同的颜色</li>
<li>人眼对在380nm(紫光)到760nm(红光)波长的光很敏感</li>
</ul>
<h1 id="光的光谱分布"><a href="#光的光谱分布" class="headerlink" title="光的光谱分布"></a>光的光谱分布</h1><p>光是一种多种波长，每种波长的强度不同的电磁波的混合。对于白光，就意味光中包含的所有波长的电磁波具有一样的强度。</p>
<p>光谱分布就是一个光的强度和波长的函数。</p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200709161946882.png" alt="image-20200709161946882" style="zoom:33%;"></p>
<p>由于颜色就是光对人眼产生的刺激，因此颜色也就可以用光谱分布表示。但是使用光谱分布来表示颜色太复杂，并且现实中也存在异谱同色的现象。</p>
<h1 id="颜色表示方法"><a href="#颜色表示方法" class="headerlink" title="颜色表示方法"></a>颜色表示方法</h1><h2 id="RGB颜色空间"><a href="#RGB颜色空间" class="headerlink" title="RGB颜色空间"></a>RGB颜色空间</h2><p>RGB是被用得最广泛的颜色空间，颜色用三个通道(r, g, b)表示，r表示red，g表示green，b表示blue。通常每个通道中值都是0～1的浮点数，或者用8比特表示的0～255之间的数。</p>
<p>人类的视觉系统也是基于RBG三原色的。</p>
<p><strong>但是有些颜色并不能由RBG三原色的组合表示，因为有些颜色的R通道是负的。</strong></p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200709200933168.png" alt="image-20200709200933168" style="zoom:33%;"></p>
<h2 id="CMY颜色空间"><a href="#CMY颜色空间" class="headerlink" title="CMY颜色空间"></a>CMY颜色空间</h2><p>颜色用三个通道(c, m, y)表示，c表示cyan(青)，m表示magenta(品红)，y表示yellow，它和RBG颜色空间的对应方式为：</p>
<script type="math/tex; mode=display">
(c, m, y) = (1, 1, 1) - (r, g, b)</script><p>CMY颜色空间也被叫做减色系统，因为RBG颜色空间随着每个通道值的增加颜色逐渐从黑变为白，而CMY颜色空间的颜色随着每个通道值的增加颜色逐渐从白色变为黑色。</p>
<h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>HSV颜色空间用色调(Hue)，饱和度(Saturation)，明度(Value of Brightness)来分别颜色。</p>
<ul>
<li>色调意味着基础颜色，它是表明不同颜色的主要因素，用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°，蓝色为240°。它们的补色是：黄色为60°，青色为180°，紫色为300°。</li>
<li>饱和度表示颜色的纯度，取值为0～1的浮点数，饱和度越低，颜色越接近白色。</li>
<li>明度表示颜色的明亮程度，亮度越低，颜色越接近黑色。</li>
</ul>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200709202938841.png" alt="image-20200709202938841" style="zoom:33%;"></p>
<p><strong>RGB和CMY颜色模型都是面向硬件的，而HSV颜色模型是面向用户的。</strong></p>
<h2 id="YUV，YCbCr颜色空间"><a href="#YUV，YCbCr颜色空间" class="headerlink" title="YUV，YCbCr颜色空间"></a>YUV，YCbCr颜色空间</h2><p>Y分量表示明亮度(Lumiance或着Luma)，U(Cr)和V(Br)表示色度，人眼一般对亮度信息比较敏感，对颜色信息比较不敏感。</p>
<p>YUV 用在 模拟 PAL or 模拟 NTSC视频格式，不用在数字视频格式</p>
<p>YCbCr 是用于数字视频表示的则是色度(Chrominance或Chroma).</p>
<p>YUV(YCbCr)的颜色空间存储有几种方式：plane、bi-plane、packed，</p>
<p>plane的存储方式为先存储所有的像素中的Y通道的值，然后存储所有像素中的U通道的值，然后是U通道的值(不一定所有像素都有U和V值，这和采样有关，后续再说明)。bi-plane存储方式为先存储所有像素中的Y通道值作为一个plane，然后交替存储像素中的U和V的值作为第二个plane。packed存储方式为交替存储每个像素中的YUV值。</p>
<p>采样率(数字信号才谈采样)，YCbCr颜色空间一般有4:4:4，4:2:2和4:2:0这几种采样方式。4:4:4——每采样一个Y通道，同时采样一个Cb、Cr通道。4:2:2——每采样两个Y，采样一个Cb和Cr，要显示4：2：2的YCbCr数据，首先将其转换为4：4：4的YCbCr数据，使用内插生成缺少的Cb和Cr样本。4:2:0并不意味着只有Cb分量，没有Cr分量。它指的是对于每行扫描线来说，4:2:0——只有一种色度分量以2:1的抽样率存储。相邻的扫描线存储不同的色度分量，也就是说一行是4:2:0的话，下一行就是4:0:2，下一行又是4:2:0，以此类推。要显示4：2：0的YCbCr数据，首先将其转换为4：4：4的YCbCr数据，使用内插生成新的Cb和Cr样本。</p>
<h2 id="CIE-XYZ颜色空间"><a href="#CIE-XYZ颜色空间" class="headerlink" title="CIE XYZ颜色空间"></a>CIE XYZ颜色空间</h2><p>由CIE(International Commission on Illumination)提出，它可以用来表示所有的可见光</p>
<h1 id="图像和像素"><a href="#图像和像素" class="headerlink" title="图像和像素"></a>图像和像素</h1><p>//TODO：虽然知道相关概念，但还是写一下吧。</p>
<h1 id="网格绘制"><a href="#网格绘制" class="headerlink" title="网格绘制"></a>网格绘制</h1><p>在计算机图形中，表示一个3D图形一般使用三角网格或者参数曲线(曲面)。一个三角网格数据结构一般包括一个三角形数组，</p>
<h1 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h1><p>当光照射到物体表面时,物体对光会发生反射、透射、吸收、衍射、折射、和干涉,其中被物体吸收的部分转化为热，反射、透射的光进入人的视觉系统,使我们能看见物体。为模拟这一现象,我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。</p>
<h1 id="局部光照"><a href="#局部光照" class="headerlink" title="局部光照"></a>局部光照</h1><p>在真实感图形学中,仅处理光源直接照射物体表面的光照明模型被称为局部光照明模型。</p>
<h1 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h1><p>全局光照模型是基于光学物理原理的，光照强度的计算依赖于光能在现实世界中的传播情况，考虑光线与整个场景中各物体表面及物体表面间的相互影响，包括多次反射 、透射 、散射等。因此，与局部光照模型相比，全局光照模型需要相当大的计算量 ，但同时也能取得非常逼真的真实效果 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/20/program_language/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/program_language/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">类与对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-20 17:33:45" itemprop="dateCreated datePublished" datetime="2020-11-20T17:33:45+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-09 16:43:57" itemprop="dateModified" datetime="2022-02-09T16:43:57+08:00">2022-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-primer-plus/" itemprop="url" rel="index">
                    <span itemprop="name">c++ primer plus</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>26 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的声明只是说明了如何创建一个对象，并没有实际分配内存，只有当有对象被创建的时候才会分配内存。</p>
<h1 id="类内定义的成员函数"><a href="#类内定义的成员函数" class="headerlink" title="类内定义的成员函数"></a>类内定义的成员函数</h1><font color="orange">在类的定义声明并实现的成员函数默认为inline函数，不论前面是否加了inline关键字</font>

<h1 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h1><p>构造函数和析构函数都没有返回值</p>
<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><font color="orange">当程序创建未被显示初始化的类对象时，总是调用默认构造函数</font>

<p>如果没有提供任何构造函数，则编译器将自动提供默认构造函数，这个构造函数不会做任何事。它是默认构造函数的隐式版本。</p>
<font color="orange">当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数</font>

<p>显示定义默认构造函数的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1:给构造函数所有参数提供默认值</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> string &amp;co = <span class="string">&quot;&quot;</span>, <span class="type">int</span> n = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2:提供一个没有参数的构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>
<font color="orange">不要同时采用这两种方法，否则会产生二义性，编译器在需要用到默认构造函数的时候不知道使用哪一个</font>

<p>隐式地调用默认构造函数的时候，不要使用圆括号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class;<span class="comment">//隐式调用默认构造函数</span></span><br><span class="line">MyClass my_class = <span class="built_in">MyClass</span>();<span class="comment">//显示调用默认构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">my_class</span><span class="params">()</span></span>;<span class="comment">//这个变成了一个函数声明</span></span><br></pre></td></tr></table></figure>
<h2 id="nullptr-构造函数"><a href="#nullptr-构造函数" class="headerlink" title="nullptr 构造函数"></a>nullptr 构造函数</h2><p>nullptr构造函数用于解决<font color="orange">存在多个</font>（如果只有一个，传入空指针也不会产生歧义）接受指针的构造函数时，如果传入空指针时函数不明确的问题，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> *data) &#123;std::cout &lt;&lt; <span class="string">&quot;int constructor&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> *data) &#123;std::cout &lt;&lt; <span class="string">&quot;double constructor&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(std::<span class="type">nullptr_t</span>) &#123;std::cout &lt;&lt; <span class="string">&quot;nullptr constructor&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数的实际运行"><a href="#构造函数的实际运行" class="headerlink" title="构造函数的实际运行"></a>构造函数的实际运行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = <span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，编译器有两种实现方式。第一种：不会创建临时对象，直接将对象赋给my_class；第二种：调用构造函数来创建一个临时对象，然后将该临时对象拷贝到my_class中，并丢弃该临时对象，则这样会为临时对象调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = <span class="built_in">MyClass</span>();</span><br><span class="line">my_class = <span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>
<p>对于上述代码的第二个赋值语句，在这样的赋值语句中使用构造函数<code>总会</code>导致在赋值前创建一个临时对象。</p>
<p><code>如果既可以通过初始化，也可以通过赋值来设置对象的值，应采用初始化方式，通常这种方式的效率更高，即可以避免创建临时对象。</code></p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>每个类都只能有一个析构函数</p>
<h2 id="类成员的构造和析构顺序"><a href="#类成员的构造和析构顺序" class="headerlink" title="类成员的构造和析构顺序"></a>类成员的构造和析构顺序</h2><ul>
<li><p>构造时</p>
<ul>
<li><p>如果某个类具有父类，先执行父类的构造函数</p>
</li>
<li><p>类的非静态数据成员，按照声明的顺序创建</p>
</li>
<li><p>执行构造函数体内部的代码</p>
</li>
</ul>
</li>
<li><p>析构时</p>
<ul>
<li><p>调用类的析构函数</p>
</li>
<li><p>销毁数据成员，与创建的顺序相反</p>
</li>
<li><p>如果有父类，调用父类的析构函数</p>
</li>
</ul>
</li>
</ul>
<h1 id="带const的类成员函数"><a href="#带const的类成员函数" class="headerlink" title="带const的类成员函数"></a>带const的类成员函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> MyClass my_class;</span><br><span class="line">my_class.<span class="built_in">func</span>();<span class="comment">//编译器可能会拒绝执行该方法，因为func方法可能无法保证调用对象不被修改</span></span><br></pre></td></tr></table></figure>
<p>但是如果func()的类方法声明为const类方法就可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//承诺不修改调用对象</span></span><br></pre></td></tr></table></figure>
<font color="orange">只要类方法不修改调用对象，就应将其声明为const</font>

<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_classes[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>上述声明要求，这个类要么显式的定义了默认构造函数，要么没有显式地定义任何构造函数（即编译器提供了默认构造函数）</p>
<p>可以使用构造函数来初始化数组元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_classes[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="string">&quot;&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码初始化了对象数组的部分元素，剩余的2个将会使用默认构造函数进行初始化。</p>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。<font color="orange">因此，要创建对象数组并且有部分数组元素未使用显式构造函数创建时，则这个类必须要有默认构造函数。</font></p>
<h1 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">egg</span> &#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">t_shirt</span> &#123;Small, Mediun, Large, Xlarge&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码在两个枚举中定义了同一个枚举变量，会发生冲突，编译器会报错。</p>
<p>为了避免这种冲突，C++11提供了一种新枚举，其枚举变量的作用域为类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">egg</span> &#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">t_shirt</span> &#123;Small, Mediun, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure>
<p>可以使用关键字struc代替关键字class，<font color="orange">创建作用域内枚举时都需要使用枚举名来限定枚举量</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egg choice = egg::Large;</span><br><span class="line">t_shirt Floyd = t_shirt::Large;</span><br></pre></td></tr></table></figure>
<font color="orange">常规的枚举变量可以自动转换为整型，但是作用域内枚举不能隐式地转换为整型。但是必要时可以进行显式类型转换</font>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = egg::Small;<span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> b = <span class="built_in">int</span>(egg::Small);<span class="comment">//b = 0</span></span><br></pre></td></tr></table></figure>
<p>作用域内枚举变量可以设置底层数据类型，但是必须为整型数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> : <span class="type">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;<span class="comment">//指定底层类型为短整型</span></span><br></pre></td></tr></table></figure>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>要重载运算符，需使用被称为运算符函数的特殊形式。运算符函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>-type <span class="keyword">operator</span> <span class="built_in">op</span>(argument-list);</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">MyClass <span class="keyword">operator</span> +(<span class="type">const</span> Myclass &amp;my_class);</span><br></pre></td></tr></table></figure>
<p>当编译器发现如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = my_class_1 + my_class_2;</span><br></pre></td></tr></table></figure>
<p>编译器会使相印的运算符函数替换上述运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = my_class_1.<span class="keyword">operator</span>+(my_class_2);</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载限制："><a href="#运算符重载限制：" class="headerlink" title="运算符重载限制："></a>运算符重载限制：</h2><ul>
<li><p>重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符</p>
</li>
<li><p>使用运算符时不能违反运算符原来的句法规则</p>
</li>
</ul>
<font color="orange">运算符的重载可以通过成员函数或非成员函数进行重载</font>，但下面的运算符只能通过成员函数进行重载：

* "=" : 赋值运算符
* "()": 函数调用运算符
* "[]": 下标运算符
* "->": 通过指针访问类成员的运算符

# 友元

友元有三种：

* 友元函数
* 友元类
* 友元成员函数

<font color="orange">通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限</font>

<h2 id="为什么要使用友元？"><a href="#为什么要使用友元？" class="headerlink" title="为什么要使用友元？"></a>为什么要使用友元？</h2><p>对于如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设类A实现了A operator +(int value);</span></span><br><span class="line">A b = a + <span class="number">3</span>;<span class="comment">//转换成a.operator+(3);</span></span><br><span class="line">A b = <span class="number">3</span> + a;<span class="comment">//因为3不是A类对象，编译器无法使用成员函数来替换该表达式</span></span><br></pre></td></tr></table></figure>
<p>使用友元函数可以解决这个问题</p>
<h2 id="创建友元函数"><a href="#创建友元函数" class="headerlink" title="创建友元函数"></a>创建友元函数</h2><p>创建友元函数的第一步是将其<code>原型放在类声明中</code>，并在原型声明前加上关键字friend</p>
<p>第二步编写函数定义，因为友元函数不是成员函数，所以<code>不要使用&quot;::&quot;限定符，且在定义中不要使用关键字friend</code></p>
<p>所以对于上面的这个问题，只需要实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="type">int</span> value, <span class="type">const</span> A &amp;a)</span><br></pre></td></tr></table></figure>
<font color="orange">注意：只有类声明可以决定哪一个函数是友元</font>

<h2 id="重载-lt-lt-运算符"><a href="#重载-lt-lt-运算符" class="headerlink" title="重载&lt;&lt;运算符"></a>重载<code>&lt;&lt;</code>运算符</h2><p>直接上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种重载方式</span></span><br><span class="line"><span class="type">void</span> opeartor&lt;&lt;(<span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">    cout &lt;&lt; a.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种重载方式</span></span><br><span class="line"><span class="type">void</span> opeartor&lt;&lt;(ostream &amp;os) &#123;</span><br><span class="line">    os &lt;&lt; <span class="keyword">this</span>-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种重载方式</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">    os &lt;&lt; a.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这是定义同时也是实现，单独实现的时候不加friend</span></span><br></pre></td></tr></table></figure>
<p>对于上述代码1，你觉得可以这样使用吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">cout &lt;&lt; a;</span><br></pre></td></tr></table></figure>
<p>答案是不可以</p>
<p>对于上述代码2，调用的格式因该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a &lt;&lt; cout;</span><br></pre></td></tr></table></figure>
<p>很别扭是吧</p>
<p>第三种方式可以实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; a.data</span><br></pre></td></tr></table></figure>
<p>但是第三种方式有种缺憾，就是不可以这样调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;a.data is&quot;</span> &lt;&lt; a.data &lt;&lt; <span class="string">&quot;and b.data is&quot;</span> &lt;&lt; b.data;</span><br></pre></td></tr></table></figure>
<p>解决方法——让第三种方式返回ostream对象的引用即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(osteam &amp;os, <span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">    os &lt;&lt; a.data;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载单操作数运算符"><a href="#重载单操作数运算符" class="headerlink" title="重载单操作数运算符"></a>重载单操作数运算符</h3><p>对于某些运算符既可以作单数运算符，又可以作为双操作数运算符。例如“-”既可以作为自反运算符，又可以作为减号操作符。<br>那么重载这种运算符的时候，作为单操作数运算符是不同于双操作运算符的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为成员函数的情况</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>-();<span class="comment">//用作单操作运算符</span></span><br><span class="line">return_type <span class="keyword">operator</span>-(parameter);<span class="comment">//用作双操作运算符</span></span><br></pre></td></tr></table></figure>
<p>有了上述成员函数的情况，作为非成员函数的情况就可以类推出来了</p>
<h4 id="重载-和—运算符"><a href="#重载-和—运算符" class="headerlink" title="重载++和—运算符"></a>重载++和—运算符</h4><p>++运算符和—运算符既可以做前缀可以做后缀，重载前缀++(—)和后缀++(—)的情况是不同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>++();<span class="comment">//前缀++</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>++(<span class="type">int</span>);<span class="comment">//后缀++</span></span><br></pre></td></tr></table></figure>
<p><code>C++规定后缀形式有一个int类型的参数，但是这个参数永远不会用到，所以不必写参数名，也不要写这个参数名。</code></p>
<h3 id="运算符重载：作为成员函数还是非成员函数？"><a href="#运算符重载：作为成员函数还是非成员函数？" class="headerlink" title="运算符重载：作为成员函数还是非成员函数？"></a>运算符重载：作为成员函数还是非成员函数？</h3><p>前面说过运算符的重载可以通过成员函数或非成员函数进行重载，但是不能同时声明这两种格式，否则将造成二义性错误，导致编译错误。</p>
<p>对于某些运算符来说，成员函数是唯一合法的选择，例如前面说的”=”(赋值运算符)。有时，根据类设计，使用非成员函数版本可能更好（尤其是为类定义类型转换时）。其他情况下，这两种格式没有太大区别。</p>
<h3 id="可以对运算符重载再进行重载"><a href="#可以对运算符重载再进行重载" class="headerlink" title="可以对运算符重载再进行重载"></a>可以对运算符重载再进行重载</h3><p>例如对于”-“运算符，它既可以表示减法，也可以表示自反，那么就可以实现两种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以向量为例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span>-(<span class="type">const</span> Vector &amp;v) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x - v.x, y - v.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vecotor <span class="keyword">operator</span>-()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h1><p>在c++中，如果一个类有接受一个参数的构造函数，则c++支持将与该参数相同类型的值转换为类。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> data) : <span class="built_in">data</span>(data) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>程序将使用构造函数A(10)来创建一个临时对象，并将19.6作为初始化值，然后将该临时对象复制到a中。这一过程称为隐式转换。</p>
<p>c++中新增了关键字explicit用于关闭这种自动特性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> data)</span> : data(data) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="number">10</span>;<span class="comment">//报错，不能再隐式转换</span></span><br><span class="line">A a = (A) <span class="number">10</span>;<span class="comment">//仍然可以使用显示转换</span></span><br></pre></td></tr></table></figure>
<p><code>explicit关键字只有用来修饰单参数的构造函数才有意义</code></p>
<p><code>建议不要使用隐式转换，最好将单参数的构造函数都加上explicit关键字，使用强制类型转换</code></p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>上面的例子是将整型转换成A类型，同时转换函数可以让A类型转换成整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> data)</span> : data(data) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> b = a;<span class="comment">//b = 10</span></span><br></pre></td></tr></table></figure>
<p><code>声明转换函数注意以下几点</code>：</p>
<ul>
<li>转换函数必须是类方法</li>
<li>转换函数不能指定返回类型</li>
<li>转换函数不能有参数</li>
</ul>
<p>同时c++11及之后可以将explicit关键字用于转换函数，这样就只能进行强制类型转换而不能进行隐式类型转换</p>
<p><code>使用转换函数的原则</code>：<br>谨慎使用转换函数，最好使用功能相同的非转换函数，例如上例中完全可以实现一个int to_int();的成员方法来实现相同的功能。</p>
<h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><h4 id="static成员变量的声明及初始化"><a href="#static成员变量的声明及初始化" class="headerlink" title="static成员变量的声明及初始化"></a>static成员变量的声明及初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static成员变量初始化</span></span><br><span class="line"><span class="type">double</span> MyClass::d = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<p>一般不能在类声明中初始化静态成员变量，这是因为类声明只描述了如何分配内存，但不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句指出了类型，并使用了作用域运算符，<code>但没有使用关键字static</code>。</p>
<p><code>但是如果静态成员是const整型或const枚举型，则可以在类声明中初始化。</code></p>
<h4 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h4><ul>
<li>不能通过对象调用static成员函数，对于声明在共有部分的static成员函数，可以使用类名和作用域解析运算符来调用它。</li>
<li><code>static成员函数中不能使用this指针</code></li>
<li>static成员函数只能访问static成员变量</li>
</ul>
<h4 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h4><p>c++自动提供了下面这些成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数</li>
<li>默认析构函数，如果没有定义</li>
<li>复制(拷贝)构造函数，如果没有定义</li>
<li>赋值运算符(“=”)，如果没有定义</li>
<li>地址运算符(“&amp;”)，如果没有定义</li>
</ul>
<h5 id="复制-拷贝-构造函数"><a href="#复制-拷贝-构造函数" class="headerlink" title="复制(拷贝)构造函数"></a>复制(拷贝)构造函数</h5><p>复制构造函数用于将一个对象复制到新创建的对象中，也就是说，它用于初始化过程中。复制构造函数的原型通常如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;);</span><br></pre></td></tr></table></figure>
<p><code>调用复制构造函数的时机：</code></p>
<ul>
<li><code>新建一个对象并</code>将其初始化为同类对象时，复制(拷贝)构造函数都将被调用。</li>
<li>当函数按值传递对象或函数返回对象时(<code>返回引用则不会调用</code>)，都将使用复制(拷贝)构造函数</li>
</ul>
<p>默认的复制(拷贝)构造函数逐个复制非静态成员的值（即<code>浅拷贝</code>）</p>
<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>将已有对象赋值给另一个对象时，将使用重载的赋值运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class_1;</span><br><span class="line">MyClass my_class_2 = my_class_1;<span class="comment">//使用复制(拷贝)构造函数，可能使用赋值运算符——可能先使用复制(拷贝)构造函数创建一个临时对象，然后使用赋值构造函数将这个临时对象赋值给my_class_2</span></span><br><span class="line">MyClass my_class_3;</span><br><span class="line">my_class_3 = my_class_1;<span class="comment">//使用赋值运算符</span></span><br></pre></td></tr></table></figure>
<p>同默认的复制(拷贝)构造函数一样，<code>默认的赋值运算函数也对成员进行逐个复制（浅拷贝）</code></p>
<p><code>编写赋值运算符函数的规范：</code></p>
<ul>
<li><p>由于目标对象可能引用了以前分配的数据，所以函数应使用delete或delete[]来释放这些数据</p>
</li>
<li><p>函数应当避免将对象赋给自身，首先这样做没有太大意义，并且，给对象重新赋值前，释放内存操作可能删除对象的内容(详见示例代码)</p>
</li>
<li><p>函数最后返回一个指向调用对象的引用，这是为了能够连续赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyClass &amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass &amp; my_class) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;my_class) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放动态内存，如果有的话</span></span><br><span class="line">  <span class="comment">//如果没有上面的判断且this == &amp;my_class的话，那么 delete p也会将my_class中的p delete掉，那么下面的内存拷贝就会出错</span></span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  data = my_class.data;</span><br><span class="line">  p = <span class="keyword">new</span> ...;<span class="comment">//重新分配动态内存</span></span><br><span class="line">  <span class="built_in">memcpy</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="调用拷贝构造函数还是赋值运算符函数？"><a href="#调用拷贝构造函数还是赋值运算符函数？" class="headerlink" title="调用拷贝构造函数还是赋值运算符函数？"></a>调用拷贝构造函数还是赋值运算符函数？</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">my1</span><span class="params">(my2)</span></span>;<span class="comment">//只调用拷贝构造函数</span></span><br><span class="line">MyClass my1 = my2;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">MyClass my1;</span><br><span class="line">my1 = my2;<span class="comment">//调用赋值运算符函数</span></span><br></pre></td></tr></table></figure>
<p>一般有新对象被创建时就会调用一个构造函数，可能就是拷贝构造函数</p>
<h3 id="重载-运算符的一个技巧"><a href="#重载-运算符的一个技巧" class="headerlink" title="重载[]运算符的一个技巧"></a>重载[]运算符的一个技巧</h3><p>重载运算符最好能够返回引用，因为这样不仅能够使用”[index]”获取值，而且可以方便的为”[index]”处对应的值进行赋值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> i);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> i) <span class="type">const</span>;<span class="comment">//const成员函数返回一定是const char &amp;</span></span><br><span class="line">string str;</span><br><span class="line"><span class="type">char</span> c = str[<span class="number">1</span>];</span><br><span class="line">str[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//如果返回不是引用那么修改的就只是一个临时对象而已</span></span><br></pre></td></tr></table></figure>
<p>使用const版本的operator[]实现非const版本的operator[]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> i) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span> &amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> MyClass&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次cast将<em>this转换成const MyClass&amp;类型，即为</em>this添加const，第二次则从const operator[]的返回值中移除const。<br><code>只能用const版本来实现非const版本，注意不要用非const版本来实现const版本。</code>是否需要const版本来实现非const版本取决于你自己。</p>
<h3 id="包含类成员的类的逐成员复制"><a href="#包含类成员的类的逐成员复制" class="headerlink" title="包含类成员的类的逐成员复制"></a>包含类成员的类的逐成员复制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBigClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MySmallClass1 my_small_class1;</span><br><span class="line">MySmallClass2 my_small_class2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于MyBigClass而言，<code>默认的逐成员复制和赋值行为有一定的智能，逐成员复制或赋值将使用成员类型定义的复制(拷贝)构造函数和赋值运算符</code>。然而，如果MyBigClass有需要定义复制(拷贝)构造函数和赋值运算符函数，则最好重新为MyBigClass编写复制(拷贝)构造函数和赋值运算符函数。</p>
<h3 id="需要重新编写复制-拷贝-构造函数和赋值运算符函数的一种情况"><a href="#需要重新编写复制-拷贝-构造函数和赋值运算符函数的一种情况" class="headerlink" title="需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况"></a>需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况</h3><p>如果一个类的成员是需要动态内存分配的，那么这个类一般是在构造函数中动态申请内存，而在析构函数中一般会释放该动态内存。</p>
<p>因为默认复制(拷贝)构造函数和赋值运算符函数是浅拷贝，所以浅拷贝复制的只是指向动态内存的指针的值，当其中一个对象被释放掉了，其析构函数释放掉动态内存，那个另外一个对象也将不再拥有该动态分配的内存。</p>
<p>这时就应该为该类重新编写复制(拷贝)构造函数和赋值运算符函数，让其进行深拷贝，即重新申请内存，而不是简单的指针赋值。</p>
<h3 id="对于使用定位new运算符分配的动态对象"><a href="#对于使用定位new运算符分配的动态对象" class="headerlink" title="对于使用定位new运算符分配的动态对象"></a>对于使用定位new运算符分配的动态对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">MyClass *p1 = <span class="built_in">new</span> (buffer) MyClass;</span><br></pre></td></tr></table></figure>
<p>由于对于定位new运算符不能使用delete，所以，<code>对使用定义new运算符创建的对象，要显式的调用函数的析构函数</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure>
<h1 id="嵌套结构和类"><a href="#嵌套结构和类" class="headerlink" title="嵌套结构和类"></a>嵌套结构和类</h1><p>在类声明的结构、类或枚举被称为是嵌套在类中的，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是类的私有部分进行的，则只能在这个类使用被声明的类型，如果声明是在共有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类。</p>
<h1 id="成员初始化列表的语法"><a href="#成员初始化列表的语法" class="headerlink" title="成员初始化列表的语法"></a>成员初始化列表的语法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">mem1</span>(a), <span class="built_in">mem2</span>(b), <span class="built_in">mem3</span>(a * b + <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员初始化列表格式只能用于构造函数</li>
<li><code>必须使用这个格式来初始化非静态const数据成员，即单const修饰的成员</code></li>
<li><code>必须用这种格式来初始化引用数据成员</code>（一般很少有引用数据成员，因为这种设计很不好）</li>
<li><code>当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序</code>。如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要了。</li>
</ul>
<p>成员初始化列表会覆盖类内初始化的成员的初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//类内初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">10</span>)<span class="comment">//将会覆盖掉a，a=10</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="子类的初始化"><a href="#子类的初始化" class="headerlink" title="子类的初始化"></a>子类的初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubClass</span>(<span class="type">int</span> a, <span class="type">double</span> b, <span class="type">char</span> c): <span class="built_in">BaseClass</span>(a, b), <span class="built_in">c</span>(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类的构造函数必须使用<code>相邻基类</code>的构造函数，<code>且只能使用成员初始化列表的方式</code>，创建派生类对象时，程序首先创建基类对象。如果不显示的调用基类的构造函数，程序将使用默认的基类构造函数(如果有的话，否则将会报错)</p>
<p>派生类对象过期时，程序将先调用派生类的析构函数，然后再调用基类析构函数</p>
<h3 id="在派生类成员函数中调用父类的方法"><a href="#在派生类成员函数中调用父类的方法" class="headerlink" title="在派生类成员函数中调用父类的方法"></a>在派生类成员函数中调用父类的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BaseClass::<span class="built_in">func</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在派生类成员函数中调用父类定义的方法是使用作用域解析运算符来调用的。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h3><p>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的条件下引用派生类对象，也可以将派生对象赋给基类对象（向上强制转换）。但是不可以将基类对象赋给派生类对象和派生类引用，不可以把基类对象地址赋给派生类对象指针（向下强制转换）</p>
<h3 id="虚函数-virtual-function-与多态实现"><a href="#虚函数-virtual-function-与多态实现" class="headerlink" title="虚函数(virtual function)与多态实现"></a>虚函数(virtual function)与多态实现</h3><p>如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用virtual，程序将根据引用或指针指向的具体对象的类型来选择方法<br>不使用virtual：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseClass base;</span><br><span class="line">SubClass sub;</span><br><span class="line">BaseClass *b1 = &amp;base;</span><br><span class="line">BaseClass *b2 = ⊂</span><br><span class="line">b1-&gt;<span class="built_in">func</span>(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b2-&gt;<span class="built_in">func</span>(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">BaseClass &amp;b3 = base;</span><br><span class="line">BaseClass &amp;b4 = sub;</span><br><span class="line">b3.<span class="built_in">func</span>(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b4.<span class="built_in">func</span>(); <span class="comment">// 使用 BaseClass::func()</span></span><br></pre></td></tr></table></figure>
<p>使用virtual关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;<span class="comment">//只能对virtual方法标记override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseClass base;</span><br><span class="line">SubClass sub;</span><br><span class="line">BaseClass *b1 = &amp;base;</span><br><span class="line">BaseClass *b2 = ⊂</span><br><span class="line">b1-&gt;<span class="built_in">func</span>(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b2-&gt;<span class="built_in">func</span>(); <span class="comment">// 使用 SubClass::func()</span></span><br><span class="line">BaseClass &amp;b3 = base;</span><br><span class="line">BaseClass &amp;b4 = sub;</span><br><span class="line">b3.<span class="built_in">func</span>(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b4.<span class="built_in">func</span>(); <span class="comment">// 使用 SubClass::func()</span></span><br></pre></td></tr></table></figure>
<p>经常在基类中将派生类会重新定义的方法声明为虚方法，方法在基类中被声明为虚方法后，它在<code>所有派生类中</code>将<code>自动成为</code>虚方法。但是最好在派生类声明中使用virtual来指出哪些函数是虚函数，这可以增加程序的可读性</p>
<p><code>virtual关键字只用于类声明的方法原型中，而不用于方法实现中</code></p>
<h4 id="总结实现多态的方法"><a href="#总结实现多态的方法" class="headerlink" title="总结实现多态的方法"></a>总结实现多态的方法</h4><ul>
<li><code>公有继承</code>，因为只有公有继承是才允许将基类指针或基类引用指向派生类</li>
<li>成员函数要用virtual修饰</li>
<li>使用对象的引用或指针</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SubClass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseClass *p1 = <span class="keyword">new</span> <span class="built_in">BaseClass</span>();</span><br><span class="line">BaseClass *p2 = <span class="keyword">new</span> <span class="built_in">SubClass</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，如果析构函数不是虚函数，当delete p2时，将只会调用基类的虚构函数。如果是虚析构函数，则当delete p2时，将会调用SubClass的析构函数。</p>
<p><code>所以，一般将类的析构函数定义为虚函数</code></p>
<h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。在程序运行时选择正确的函数代码块，被称为动态联编（dynamic binding），又称为晚期联编（late dinding）</p>
<p>为什么有两种类型的联编？：<br>由于动态联编需要采用一些方法来追踪基类指针或引用指向的对象类型，这增加了额外的开销，所以静态联编的效率比动态联编的效率高，因此<code>静态联编也被设置为c++的默认选择</code>。</p>
<h4 id="虚成员函数与动态联编"><a href="#虚成员函数与动态联编" class="headerlink" title="虚成员函数与动态联编"></a>虚成员函数与动态联编</h4><p>编译器会对非虚方法使用静态联编，对虚方法使用动态联编。但是由于动态联编需要额外开销，所以<code>对不需要重新定义的成员函数，不要将这些函数设置为虚函数</code>，这样有两种好处：首先效率更高；<code>其次，指出不要重新定义该函数</code>。仅将那些需要被重新定义的方法声明为虚的</p>
<h3 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a><code>虚函数的工作原理</code></h3><p>编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这个指针一般会成为对象的第一个数据成员。这个数组被称为<code>虚函数表</code>。虚函数表中存储了为类对象进行声明的虚函数的地址。无论类中包含的虚函数还是1个还是10个，都只需要在对象中添加一个地址成员，只是表的大小不同而已。<code>使用虚函数表也就是为了不增大类所占的内存，并加快函数查找速度</code><br><img src="/2020/11/20/program_language/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/虚函数机制.jpg" alt="虚函数机制" style="zoom:25%;"></p>
<p>对于上图，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个<code>指向独立地址</code>的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，虚函数表将<code>保存函数原始版本的地址</code>。如果派生类定义了新的虚函数，则该函数的地址也将被添加到虚函数表中。</p>
<p>如果使用类声明中定义的第一个虚函数，则程序将使用数组 中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</p>
<h3 id="虚表指针初始化的时机"><a href="#虚表指针初始化的时机" class="headerlink" title="虚表指针初始化的时机"></a><code>虚表指针初始化的时机</code></h3><p>序表指针的初始化在进入类构造函数之前，<br>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SubClass&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass s;</span><br></pre></td></tr></table></figure>
<p>最后打印的结构为“Base”，因为在进入s的构造函数之前，会先进行Base的构造，而在进入Base的构造函数之前，虚表指针被初始化为指向Base的虚函数表，所以这是执行虚函数调用的是父类的虚函数。当父类被构造完，进入自己的构造函数之前，虚表指针再被初始化为指向自己的虚函数表</p>
<h3 id="关于虚函数的注意事项"><a href="#关于虚函数的注意事项" class="headerlink" title="关于虚函数的注意事项"></a>关于虚函数的注意事项</h3><ul>
<li><code>构造函数不能是虚函数</code>，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。</li>
<li><code>析构函数最好设计成虚函数</code>，除非类不用做基类。也就是说即使基类不需要显示析构函数提供服务，也不应该依赖于默认析构函数，而应该提供析构函数，</li>
<li><code>友元不能是虚函数</code>，因为友元不是类成员，<code>而只有成员才能是虚函数。</code></li>
</ul>
<h1 id="在派生类中重新定义方法将隐藏方法"><a href="#在派生类中重新定义方法将隐藏方法" class="headerlink" title="在派生类中重新定义方法将隐藏方法"></a>在派生类中重新定义方法将隐藏方法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不在继承类中重新定义showperks方法，则继承类中可以使用基类所有的showperks方法。但是重新定义将showperks()定义为一个不接受任何参数的函数。<code>重新定义不会生成函数的两个重载版本</code>，而是隐藏了接收一个int参数的基类版本。总之，<code>重新定义继承的方法并不是重载</code>。</p>
<p><code>这引出了两条经验准则</code>：<br>第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类应用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Dwelling &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>: <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Hovel &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>注意这种例外只适用于返回值，而不适用于参数</code></p>
<p>第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本，或者使用<code>继承方法函数</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法1：重新定义所有的基类版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>: <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法2：使用继承方法函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>: <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Dwelling::showperks;<span class="comment">//can use all showperks now</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;<span class="comment">//还可以定义自己的showperks(double x)，而不使用基类的showperks(double x)。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> <span class="type">const</span></span>;<span class="comment">//还可以定义其他的showperks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>如果派生类中只定义一个版本，则另外两个版本将被隐藏，派生对象将无法使用它们。如果不需要需要修改，则新定义可只调用基类版本</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hovel::showperks</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Dwelling::<span class="built_in">showperks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="当typedef出现在类定义的私有部分"><a href="#当typedef出现在类定义的私有部分" class="headerlink" title="当typedef出现在类定义的私有部分"></a>当typedef出现在类定义的私有部分</h1><p>则只有在类中使用，在类外和子类中不能使用</p>
<h1 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h1><p>使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，基类的私有成员子类无法访问。使用私有继承时，只能在派生类中访问基类的非私有成员及成员函数。</p>
<p><code>使用私有继承，不支持隐式向上转换(隐式向上转换：无需进行显示类型转换，就可以将基类指针或引用指向派生类对象)</code></p>
<h1 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h1><p>基类的公有成员和保护成员都将成为派生类的保护成员</p>
<h1 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h1><p>使用保护继承或私有继承时， 基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，方法之一是定义一个使用基类方法的派生类方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pri_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : protect BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pri_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种方法是使用一个using声明，来指出派生类可以使用特定的基类成员，即使采用的是私有派生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="keyword">private</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> BaseClass::pri_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>注意using声明只使用成员名——没有圆括号、函数特征标和返回类型。且using声明只适用于继承，而不适用于包含</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwordAndTea"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SwordAndTea" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SwordAndTea" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">183k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">10:11</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
