<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="主机字节序和网络字节序字节序分为大端字节序和小端字节序。现代PC大多采用小端字节序，因此小端字节序又称为主机字节序。 当两台字节序不同的主机之间进行通信时，由于字节序的不同就会导致对数据的错误解释。但是接受端也不知道发送端发送过来的数据的字节序到底是大端还是小端，解决办法是：发送端总是把要发送的数据转化为大端字节序数据后再发送，而接受端可以根据自身采用的字节序决定是否对接收到的数据进行转换。因此大">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程基础API">
<meta property="og:url" content="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/index.html">
<meta property="og:site_name" content="xiangwei&#39;s blog">
<meta property="og:description" content="主机字节序和网络字节序字节序分为大端字节序和小端字节序。现代PC大多采用小端字节序，因此小端字节序又称为主机字节序。 当两台字节序不同的主机之间进行通信时，由于字节序的不同就会导致对数据的错误解释。但是接受端也不知道发送端发送过来的数据的字节序到底是大端还是小端，解决办法是：发送端总是把要发送的数据转化为大端字节序数据后再发送，而接受端可以根据自身采用的字节序决定是否对接收到的数据进行转换。因此大">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-06T03:04:29.000Z">
<meta property="article:modified_time" content="2023-01-11T03:20:06.088Z">
<meta property="article:author" content="SwordAndTea">
<meta property="article:tag" content="Linux socket">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Linux网络编程基础API | xiangwei's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiangwei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiangwei's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux网络编程基础API
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-06 11:04:29" itemprop="dateCreated datePublished" datetime="2020-11-06T11:04:29+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-11 11:20:06" itemprop="dateModified" datetime="2023-01-11T11:20:06+08:00">2023-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux高性能服务器编程笔记</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h1><p>字节序分为大端字节序和小端字节序。现代PC大多采用小端字节序，<code>因此小端字节序又称为主机字节序</code>。</p>
<p>当两台字节序不同的主机之间进行通信时，由于字节序的不同就会导致对数据的错误解释。但是接受端也不知道发送端发送过来的数据的字节序到底是大端还是小端，解决办法是：<code>发送端总是把要发送的数据转化为大端字节序数据后再发送</code>，而接受端可以根据自身采用的字节序决定是否对接收到的数据进行转换。因此<code>大端字节序也称为网络字节</code>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>另外需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由Java编写）通信，也要考虑字节序的问题（Java虚拟机采用大端字节序）。</p>
<p>在linux中提供了下面4个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> __hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> __hostshort)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> __netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> __netshort)</span>;</span><br></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示”host to network long”，即将32位无符号数从主机字节序转换为网络字节序数据。</p>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h2 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h2><p>Linux C  Socket网络编程接口表示socket地址的结构体sockaddr，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sa_family成员是地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型对应。常见的协议族(protocal family，也称domain，见后文)和对应的地址族如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址族</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">AF_UNIX</td>
<td style="text-align:center">UNIX本地协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">TCP/IPv4协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">TCP/IPv6协议族</td>
</tr>
</tbody>
</table>
</div>
<p>宏PF_*和AF_*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>sa_data成员用于存放socket地址值。但是，不同协议族的地址值具有不同的含义和长度，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td>文件的路径名，长度可到108字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td>16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td>16bit端口号，32bit流标识，128bit IPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
</div>
<p>由上表可见，<font color="orange">14字节的sa_data根本无法完全容纳多数协议族的地址值</font>。因此，Linux定义了下面这个新的通用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体不仅能提供了足够大的空间用于存放地址值，而且是内存对齐的(这是__ss_align成员的作用)。</p>
<h2 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h2><p><code>上面的两个通用socket地址结构体显然都不好用</code>，所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地协议族使用如下专用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">/* 地址族: AF_UNIX */</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];     <span class="comment">/* 文件路径名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TCP/IP协议族有socket_in和sockaddr_in6两个专业socket地址结构体，它们分别用于IPv4和IPv6：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockadddr_in</span>&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family;        <span class="comment">/* 地址族: AF_INET */</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;             <span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>        /* <span class="title">IPv4</span>地址结构体 */</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;                    <span class="comment">/* IPv4地址，要用网络字节序号表示 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;            <span class="comment">/* 地址族: AF_INET6 */</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;                    <span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;            <span class="comment">/* 流信息，应设置为0 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>        <span class="comment">/* IPv6地址结构体 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;            <span class="comment">/* scope ID, 尚处于实验阶段 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];         <span class="comment">/* IPv6地址，要用网络字节序表示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket类型sockaddr(强制转换即可)，因为socket编程接口使用的地址参数的类型都是sockaddr</code>。</p>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分10进展字符串表示IPv4地址，以及用16进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数才能使用。而记录日志时则相反，我们要把整数表示的IP地址转为可读的字符串。Linux提供了3个用于IP地址形式转化的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr)</span>; <span class="comment">/*in_addr 是 __uint32_t 的typdef*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="keyword">struct</span> in_addr* inp)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Inet_addr函数将用点十进制字符串表示的IPv4地址转为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE</p>
</li>
<li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败时返回0</p>
</li>
<li><p>Inet_ntoa函数将用网络字节序表示的IPv4地址转化为用点十进制表示的IPv4地址。<font color="red">但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的</font>，下面的代码揭示了其不可重入性：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *value1 = inet_ntoa(inet_addr(<span class="string">&quot;1.2.3.4&quot;</span>));</span><br><span class="line"><span class="type">char</span> *value2 = inet_ntoa(inet_addr(<span class="string">&quot;10.194.71.60&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 1: %s\n&quot;</span>, value1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 2: %s\n&quot;</span>, value2);</span><br><span class="line"><span class="comment">//最后打印的结果为：</span></span><br><span class="line">address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数相同的功能，并且它们<font color="red">同时适用于IPv4地址和IPv6地址。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *scr, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>inet_pton函数用于将字符串表示的IP地址src(用点十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址)转化成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败时返回0。</p>
</li>
<li><p>inet_ntop函数将网络字节序整数表示的IP地址，转化为IP字符串。前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定字符串dst目标存储单元的大小。有两个宏能帮助我们快速指定这个大小(分别用于IPv4和IPv6)：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<h1 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h1><p>UNIX/Linux的一个思想就是：所有的东西都是文件。socket也不例外，他就是可读、可写、可控制、可关闭的文件描述符。</p>
<p>下面的socket系统调用可创建一个socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domin, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>domin 参数告诉系统使用哪个底层协议族。对于TCP/IP协议族而言，该参数应该设置为PF_INET(Protocal Family of Internet，用于IPv4)或PF_INET6(用于IPv6)，对于UNIX本地协议族而言，该参数应设置为PF_UNIX</li>
<li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_DGRAM（数据报）服务。对于TCP/IP协议族而言，SOCK_STEAM表示传输层使用TCP协议，SOCK_DGRAM表示传输层使用UDP协议。</li>
<li>protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一，几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</li>
</ul>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<h1 id="绑定socket"><a href="#绑定socket" class="headerlink" title="绑定socket"></a>绑定socket</h1><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。需要将一个socket与socket地址进行绑定。通常在服务器端中，我们需要进行socket地址绑定，因为只有绑定后，客户端才能知道该如何连接它。客户端通常不需要绑定socket地址，而是采用匿名方式，即使用操作系统自动分配的socket地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>bind将addr所指的socket地址分配给未绑定的sockfd文件描述符，addrlen参数指出该socket地址长度。</p>
<h1 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h1><p>socket被命名之后，还不能马上接收客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户端连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd参数指定被监听的sock文件描述符</li>
<li>backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接。客户端也将受到ECONREFUSED错误。在内核版本2.2之前的linux中，backlog参数是值所有处于半连接状态和完全连接状态的socket上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket上限，处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义</li>
</ul>
<p>listen成功返回0，失败时返回-1并设置errno</p>
<h1 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h1><p>下面的系统调用从listen的监听队列中接收一个连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>sockfd参数是执行过listen系统调用的监听socket文件描述符。addr参数用来获取客户端的socket地址，该socket地址的长度由addrlen参数返回。</p>
<p><code>accept成功时返回一个新的连接socket文件描述符</code>，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1，并设置errno。</p>
<p><code>当当前监听队列中没有连接时，accept会被阻塞。</code></p>
<p><code>accept只是从监听队列中取出连接，而不管取出连接后，连接处于何种状态（连接或者断开）</code>。</p>
<h1 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h1><p>在客户端需要通过一下系统调用来主动与服务器建立连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* serv_addr, <span class="type">socklent_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd是由socket系统调用返回的socket文件描述符</li>
<li>serv_addr是服务器监听的socket地址</li>
<li>addrlen参数则serv_addr的长度</li>
</ul>
<p>connect成功时返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno，其中两种常见的errno是ECONNREFUSED和ETIMEOUT，它们的含义分别是连接被拒绝和连接超时。</p>
<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><p>关闭连接实际上就是关闭连接对应的socket文件描述符，可以通过调用关闭普通文件描述符的系统调用来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>
<p>不过，<code>close系统调用并非总是立即关闭一个连接</code>，而是将fd的引用记数减一，只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，<code>一次fork系统调用默认将父进程中打开的socket文件描述符的引用计数加1</code>。如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用shutdown系统调用（相对于close来说，它是专门为网络编程设计的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span>;</span><br></pre></td></tr></table></figure>
<p>howto参数决定了shutdown的行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">可选值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SHUT_RD</td>
<td style="text-align:center">关闭sockfd上读的这一半，应用程序不能再针对socket文件描述符号执行读操作，并且该socket接收缓冲区中的数据都将被丢弃</td>
</tr>
<tr>
<td style="text-align:center">SHUT_WR</td>
<td style="text-align:center">关闭sockfd上写的这一半。sockfd的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socke文件描述符执行写操作。这种情况下，连接处于半关闭状态。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_RDWR</td>
<td style="text-align:center">同时关闭sockfd上的读和写</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，shutdown能分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。shutdow成功时返回0，失败时返回-1，并设置errno。</p>
<h1 id="socket服务端，客户端示例"><a href="#socket服务端，客户端示例" class="headerlink" title="socket服务端，客户端示例"></a>socket服务端，客户端示例</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket fd fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sock_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sock_addr;</span><br><span class="line">    sock_addr.sin_family = AF_INET;<span class="comment">//ipv4地址协议族</span></span><br><span class="line">    sock_addr.sin_port = <span class="built_in">htons</span>(<span class="number">22996</span>); <span class="comment">//转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;sock_addr.sin_addr);<span class="comment">//将字符串类型的地址转换为网络类型地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock_fd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr *&gt;(&amp;sock_addr), <span class="built_in">sizeof</span>(sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr</span> client_addr;</span><br><span class="line">        <span class="type">socklen_t</span> client_socklen;</span><br><span class="line">        ret = <span class="built_in">accept</span>(sock_fd, &amp;client_addr, &amp;client_socklen);</span><br><span class="line">        <span class="keyword">if</span> (client_socklen == <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in)) &#123;<span class="comment">//如果是ipv4连接</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> *client_ipv4_sock = <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr_in *&gt;(&amp;client_addr);</span><br><span class="line">            <span class="type">char</span> client_ipv4_str[INET_ADDRSTRLEN];</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connection from &quot;</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">inet_ntop</span>(client_ipv4_sock-&gt;sin_family, &amp;client_ipv4_sock-&gt;sin_addr, client_ipv4_str, INET_ADDRSTRLEN) <span class="comment">//网络ip地址转换为字符串表示</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">ntohs</span>(client_ipv4_sock-&gt;sin_port) <span class="comment">//网络字节序端口号转主机字节序</span></span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_sock_addr&#123;&#125;;</span><br><span class="line">    server_sock_addr.sin_family = AF_INET;</span><br><span class="line">    server_sock_addr.sin_port = <span class="built_in">htons</span>(<span class="number">22996</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;localhost&quot;</span>, &amp;server_sock_addr.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(sock_fd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;server_sock_addr), <span class="built_in">sizeof</span>(server_sock_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;connect fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="built_in">close</span>(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h2><p>对文件的读写操作read和write同样适用于socket，但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次recv，才能读取到完整的数据。<code>recv可能返回0，这意味着通信对方已经关闭连接了</code>。recv出错时返回-1并设置errno。</li>
<li>send往sockfd上写入数据，buf和len参数分别指定缓冲区的位置和大小。send成功时返回实际写入的数据长度，失败则返回-1并设置errno。</li>
</ul>
<p>recv和send函数中的flag参数为数据收发提供了额外的控制，它可以取下表所示选项中的一个或几个的逻辑或</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项名</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">send</th>
<th style="text-align:center">recv</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MSG_CONFIRM</td>
<td style="text-align:center">指示数据链路层协议持续监听对方的回应，直到得到答复，它仅能用于SOCK_DGRAM和SOCK_RAW类型的socket</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_DONTROUTE</td>
<td style="text-align:center">不查看路由表，直接将数据发送给本地局域网络内的主机。这表示发送者确切地知道目标主机就在本地网络上</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_DONTWAIT</td>
<td style="text-align:center">对socket的此次操作时非阻塞的。socket的读写操作默认是阻塞的。</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_MORE</td>
<td style="text-align:center">告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送。这样可防止TCP发送过多小的报文段，从而提高效率</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">MSG_WAITALL</td>
<td style="text-align:center">读操作仅在读取指定数量的字节后才返回</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_PEEK</td>
<td style="text-align:center">窥探读缓存的数据，此次读操作不会导致这些数据被清除</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_OOB</td>
<td style="text-align:center">发送或接收紧急数据</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">MSG_NOSIGNAL</td>
<td style="text-align:center">往读端关闭的管道或者socket连接中写数据不引发SIGPIPE信号</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
</div>
<h2 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h2><p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">sockelen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklent_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数scr_addr所指的内容，addrlen参数则指定该地址的长度。</p>
<p>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接受端的socket地址，addrlen参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均于send/recv系统调用的flags参数及返回值相同。</p>
<p>另外，recvfrom/sendto系统调用也可以用于面向连接(STREAM)的socket数据读写，只需要把最后两个参数都设置为NULL即可。</p>
<h2 id="带外标记检查"><a href="#带外标记检查" class="headerlink" title="带外标记检查"></a>带外标记检查</h2><p>当Linux内核检查到TCP紧急标志时，将通知应用程序有带外数据需要接受。内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。但是，即使应用程序得到了有外带数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据，可以通过以下函数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br></pre></td></tr></table></figure>
<p>sockadmark判断sockfd是否处于带外标记，即下一个读取到的数据是否是带外数据，如果是，sockatmark返回1，此时就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h1 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h1><p>Linux中有下面两个系统调用是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value, <span class="type">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span>* option_value, <span class="type">socklen_t</span> option_len)</span>;</span><br></pre></td></tr></table></figure>
<p>sockfd参数指定被操作的目标socket文件描述符。level参数指定要操作哪个协议的选项，比如说IPv4、IPv6、TCP等。option_name参数则指定选项的名字。</p>
<p>下表列举了socket通信中几个比较常用的socket选项。option_value和option_len参数分别是被操作选项的值和长度。不同的选项具有不同类型的值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">level</th>
<th style="text-align:center">option name</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOL_SOCKET（通用socket选项，与协议无关）</td>
<td style="text-align:center">SO_DEBUG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">打开调试信息</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_REUSEADDR</td>
<td style="text-align:center">int</td>
<td style="text-align:center">重用本地地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_TYPE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">获取socket类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_ERROR</td>
<td style="text-align:center">int</td>
<td style="text-align:center">获取并清除socket错误状态</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_DONTROUTE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">不查看路由表，直接将数据发送给<font color="orange">本地局域网内</font>的主机。含义和send方法的MSG_DONTROUTE标志类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVBUF</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP接收缓冲区大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDBUF</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP发送缓冲区大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_KEEPALIVE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">发送周期性保活报文以维持连接</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_OOBINLINE</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收到的带外数据将保留在普通数据的输入队列中，此时我们不能使用带MSG_OOB标志的读操作来读取带外数据，而应该像读取普通数据那样读取带外数据</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_LINGER</td>
<td style="text-align:center">linger结构体</td>
<td style="text-align:center">若缓冲区中还有数据待发送，则延迟关闭</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVLOWAT</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP接收缓存区低水位标记</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDLOWAT</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP发送缓存区低水位标记</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_RCVTIMEO</td>
<td style="text-align:center">timeval</td>
<td style="text-align:center">接收数据超时</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">SO_SNDTIMEO</td>
<td style="text-align:center">timeval</td>
<td style="text-align:center">发送数据超时</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_TOS</td>
<td style="text-align:center">int</td>
<td style="text-align:center">服务类型</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IP_TTL</td>
<td style="text-align:center">int</td>
<td style="text-align:center">存活时间</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IPV6</td>
<td style="text-align:center">IPV6_NEXTHOP</td>
<td style="text-align:center">sockaddr_in6</td>
<td style="text-align:center">下一跳IP地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_RECVPKTINFO</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收分组信息</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_DONTFRAG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">禁止分片</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">IPV6_RECVTCLASS</td>
<td style="text-align:center">int</td>
<td style="text-align:center">接收通信类型</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP_MAXSEG</td>
<td style="text-align:center">int</td>
<td style="text-align:center">TCP最大报文段大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">TCP_NODELAY</td>
<td style="text-align:center">int</td>
<td style="text-align:center">禁止Nagle算法</td>
</tr>
</tbody>
</table>
</div>
<p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno</p>
<p><code>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前对socket设置才有效</code>。这是因为连接socket只能有accept调用返回，<code>而accept从监听队列中接受的连接至少已经完成TCP三次握手的前两个步骤</code>，这说明服务器已经向客户端发出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。这种情况Linux给开发人员提供的解决方案是：<code>在调用listen前，对socket设置的这些socket选项，那么accept返回的连接socket将自动继承这些选项。这些选项选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SDNLOWAT、TCP_MAXSEG、TCP_NODELAY</code>。<code>而对客户端而言，这些socket选项则应该在调用connect函数之前设置</code>，因为connect调用成功返回之后，TCP三次握手已完成。</p>
<h2 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h2><p>对于处于TIME_WAIT状态的TCP连接，服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert</span>(sock &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="built_in">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sock_addr;</span><br><span class="line">sock_addr.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip_string, &amp;sock_addr.sin_addr);</span><br><span class="line">sock_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (sturct sockaddr *)&amp;sockaddr, <span class="built_in">sizeof</span>(sockaddr));</span><br></pre></td></tr></table></figure>
<p>经过setsockopt的设置后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h2 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a>SO_RCVBUF和SO_SNDBUF选项</h2><p>SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区的发送缓冲区的大小。不过，当我们用setsockopt来设置TCP的接受缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接受缓冲区的最小值时256字节，而发送缓冲区的最小值是2048字节（不过，不同的系统可能有不同的默认值）。系统这样做的目的，主要是确保一个TCP连接有足够的空闲缓冲区来处理拥塞（比如说快重传算法就期望TCP接收缓冲区能至少容纳4个大小为最大报文段长度的TCP报文段）。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。</p>
<h2 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h2><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记，它们一般被I/O复用系统调用用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总量大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据；当TCP发送缓冲区中的<code>空闲空间</code>（可以写入数据的空间）大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写数据。</p>
<p><code>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节</code>。</p>
<h2 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h2><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭socket时，close将立即返回，TCP模块负责将socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>设置（获取SO_LINGER选项值时），我们需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> l_onoff;    <span class="comment">/* 开启（非0）还是关闭（0）该选项 */</span></span><br><span class="line">  <span class="type">int</span> l_linger;    <span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据linger结构中两个成员变量的不同值，close系统调用可能产生如下3中行为之一：</p>
<ul>
<li>l_onoff等于0，此时SO_LINGER选项不起作用，close用默认行为来关闭socket</li>
<li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将<code>丢弃</code>被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供一了异常终止一个连接的方法。</li>
<li>l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送玩所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送玩残留数据并得到对方确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux-socket/" rel="tag"># Linux socket</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/18/av_processing/audio/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="prev" title="音频基础知识">
      <i class="fa fa-chevron-left"></i> 音频基础知识
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/06/hight_performance_linux_coding/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/" rel="next" title="高级I/O函数">
      高级I/O函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">主机字节序和网络字节序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket"><span class="nav-number">2.</span> <span class="nav-text">socket</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="nav-number">2.1.</span> <span class="nav-text">通用socket地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.</span> <span class="nav-text">专用socket地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">IP地址转换函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAsocket"><span class="nav-number">3.</span> <span class="nav-text">创建socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%91%E5%AE%9Asocket"><span class="nav-number">4.</span> <span class="nav-text">绑定socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%91%E5%90%ACsocket"><span class="nav-number">5.</span> <span class="nav-text">监听socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">接收连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="nav-number">7.</span> <span class="nav-text">发起连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.</span> <span class="nav-text">关闭连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B"><span class="nav-number">9.</span> <span class="nav-text">socket服务端，客户端示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">9.1.</span> <span class="nav-text">服务端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">9.2.</span> <span class="nav-text">客户端</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">10.</span> <span class="nav-text">数据读写</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">10.1.</span> <span class="nav-text">TCP数据读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">10.2.</span> <span class="nav-text">UDP数据读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0%E6%A3%80%E6%9F%A5"><span class="nav-number">10.3.</span> <span class="nav-text">带外标记检查</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket%E9%80%89%E9%A1%B9"><span class="nav-number">11.</span> <span class="nav-text">socket选项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SO-REUSEADDR%E9%80%89%E9%A1%B9"><span class="nav-number">11.1.</span> <span class="nav-text">SO_REUSEADDR选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SO-RCVBUF%E5%92%8CSO-SNDBUF%E9%80%89%E9%A1%B9"><span class="nav-number">11.2.</span> <span class="nav-text">SO_RCVBUF和SO_SNDBUF选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SO-RCVLOWAT%E5%92%8CSO-SNDLOWAT%E9%80%89%E9%A1%B9"><span class="nav-number">11.3.</span> <span class="nav-text">SO_RCVLOWAT和SO_SNDLOWAT选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SO-LINGER%E9%80%89%E9%A1%B9"><span class="nav-number">11.4.</span> <span class="nav-text">SO_LINGER选项</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwordAndTea"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SwordAndTea" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SwordAndTea" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">183k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">10:11</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
