<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://SwordAndTea.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="类类的声明只是说明了如何创建一个对象，并没有实际分配内存，只有当有对象被创建的时候才会分配内存。 类内定义的成员函数在类的定义声明并实现的成员函数默认为inline函数，不论前面是否加了inline关键字 类的构造函数和析构函数 构造函数和析构函数都没有返回值  默认构造函数当程序创建未被显示初始化的类对象时，总是调用默认构造函数 如果没有提供任何构造函数，则编译器将自动提供默认构造函数，这个构造">
<meta property="og:type" content="article">
<meta property="og:title" content="类与对象">
<meta property="og:url" content="http://swordandtea.github.io/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="SwordAndTea&#39;s Blog">
<meta property="og:description" content="类类的声明只是说明了如何创建一个对象，并没有实际分配内存，只有当有对象被创建的时候才会分配内存。 类内定义的成员函数在类的定义声明并实现的成员函数默认为inline函数，不论前面是否加了inline关键字 类的构造函数和析构函数 构造函数和析构函数都没有返回值  默认构造函数当程序创建未被显示初始化的类对象时，总是调用默认构造函数 如果没有提供任何构造函数，则编译器将自动提供默认构造函数，这个构造">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://swordandtea.github.io/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/虚函数机制.jpg">
<meta property="article:published_time" content="2020-11-20T09:33:45.000Z">
<meta property="article:modified_time" content="2020-11-20T09:41:56.000Z">
<meta property="article:author" content="SwordAndTea">
<meta property="article:tag" content="c++ primer plus">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://swordandtea.github.io/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/虚函数机制.jpg">

<link rel="canonical" href="http://swordandtea.github.io/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>类与对象 | SwordAndTea's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SwordAndTea's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://swordandtea.github.io/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SwordAndTea">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwordAndTea's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          类与对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-20 17:33:45 / Modified: 17:41:56" itemprop="dateCreated datePublished" datetime="2020-11-20T17:33:45+08:00">2020-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-primer-plus/" itemprop="url" rel="index">
                    <span itemprop="name">c++ primer plus</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的声明只是说明了如何创建一个对象，并没有实际分配内存，只有当有对象被创建的时候才会分配内存。</p>
<h1 id="类内定义的成员函数"><a href="#类内定义的成员函数" class="headerlink" title="类内定义的成员函数"></a>类内定义的成员函数</h1><p>在类的定义声明并实现的成员函数默认为inline函数，不论前面是否加了inline关键字</p>
<h1 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h1><ul>
<li>构造函数和析构函数都没有返回值</li>
</ul>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p><code>当程序创建未被显示初始化的类对象时，总是调用默认构造函数</code></p>
<p>如果没有提供任何构造函数，则编译器将自动提供默认构造函数，这个构造函数不会做任何事。它是默认构造函数的隐式版本。<br><code>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数</code></p>
<p>显示定义默认构造函数的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1:给构造函数所有参数提供默认值</span></span><br><span class="line">MyClass(<span class="keyword">const</span> <span class="built_in">string</span> &amp;co = <span class="string">&quot;&quot;</span>, <span class="keyword">int</span> n = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2:提供一个没有参数的构造函数</span></span><br><span class="line">MyClass();</span><br></pre></td></tr></table></figure><br><code>不要同时采用这两种方法，否则会产生二义性，编译器在需要用到默认构造函数的时候不知道使用哪一个</code></p>
<p><code>隐式地调用默认构造函数的时候，不要使用圆括号</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class;<span class="comment">//隐式调用默认构造函数</span></span><br><span class="line">MyClass my_class = MyClass();<span class="comment">//显示调用默认构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">my_class</span><span class="params">()</span></span>;<span class="comment">//这个变成了一个函数声明</span></span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数的小tips"><a href="#构造函数的小tips" class="headerlink" title="构造函数的小tips"></a>构造函数的小tips</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = MyClass();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，编译器有两种实现方式。第一种：不会创建临时对象，直接将对象赋给my_class；第二种：调用构造函数来创建一个临时对象，然后将该临时对象拷贝到my_class中，并丢弃该临时对象，则这样会为临时对象调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = MyClass();</span><br><span class="line">my_class = MyClass();</span><br></pre></td></tr></table></figure>
<p>对于上述代码的第二个赋值语句，在这样的赋值语句中使用构造函数<code>总会</code>导致在赋值前创建一个临时对象。</p>
<p><code>如果既可以通过初始化，也可以通过赋值来设置对象的值，应采用初始化方式，通常这种方式的效率更高，即可以避免创建临时对象。</code></p>
<p><code>每个类都只能有一个析构函数</code></p>
<h1 id="带const的类成员函数"><a href="#带const的类成员函数" class="headerlink" title="带const的类成员函数"></a>带const的类成员函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass my_class;</span><br><span class="line">my_class.func();<span class="comment">//编译器可能会拒绝执行该方法，因为func方法可能无法保证调用对象不被修改</span></span><br></pre></td></tr></table></figure>
<p>但是如果func()的类方法声明为const类方法就可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//承诺不修改调用对象</span></span><br></pre></td></tr></table></figure><br><code>只要类方法不修改调用对象，就应将其声明为const</code></p>
<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_classes[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>上述声明要求，这个类要么显式的定义了默认构造函数，要么没有定义任何构造函数(即编译器提供了默认构造函数)</p>
<p>可以使用构造函数来初始化数组元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_classes[<span class="number">4</span>] = &#123;</span><br><span class="line">    MyClass();</span><br><span class="line">    MyClass(<span class="string">&quot;&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述代码初始化了对象数组的部分元素，剩余的2个将会使用默认构造函数进行初始化。</p>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。<code>因此，要创建对象数组并有部分数组元素未使用显示构造函数创建时，则这个类必须要有默认构造函数</code></p>
<h1 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">egg</span> &#123;</span>Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">t_shirt</span> &#123;</span>Small, Mediun, Large, Xlarge&#125;;</span><br></pre></td></tr></table></figure>
<p><code>上述代码在两个枚举中定义了同一个枚举变量，会发生冲突，编译器会报错。</code><br>为了避免这种冲突，C++11提供了一种新枚举，其枚举变量的作用域为类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">egg</span> &#123;</span>Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">t_shirt</span> &#123;</span>Small, Mediun, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure><br>可以使用关键字struc代替关键字class，<code>创建作用域内枚举时都需要使用枚举名来限定枚举量</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egg choice = egg::Large;</span><br><span class="line">t_shirt Floyd = t_shirt::Large;</span><br></pre></td></tr></table></figure><br><code>常规的枚举变量可以自动转换为整型，但是作用域内枚举不能隐式地转换为整型。但是必要时可以进行显式类型转换</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = egg::Small;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">int</span>(egg::Small);<span class="comment">//b = 0</span></span><br></pre></td></tr></table></figure><br>作用域内枚举变量可以设置底层数据类型，但是<code>必须为整型数据</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> :</span> <span class="keyword">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;<span class="comment">//指定底层类型为短整型</span></span><br></pre></td></tr></table></figure></p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>要重载运算符，需使用被称为运算符函数的特殊形式。运算符函数的格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>-type <span class="keyword">operator</span> op(argument-<span class="built_in">list</span>);</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">MyClass <span class="keyword">operator</span> +(<span class="keyword">const</span> Myclass &amp;my_class);</span><br></pre></td></tr></table></figure><br>当编译器发现如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = my_class_1 + my_class_2;</span><br></pre></td></tr></table></figure><br>编译器会使相印的运算符函数替换上述运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class = my_class_1.<span class="keyword">operator</span>+(my_class_2);</span><br></pre></td></tr></table></figure></p>
<h4 id="运算符重载限制："><a href="#运算符重载限制：" class="headerlink" title="运算符重载限制："></a>运算符重载限制：</h4><p>1、重载后的运算符必须至少有一个操作数是用户定义的类型，这将<code>防止用户为标准类型重载运算符</code><br>2、使用运算符时不能违反运算符原来的句法规则</p>
<p><code>运算符的重载可以通过成员函数或非成员函数进行重载</code>，但下面的运算符只能通过成员函数进行重载：</p>
<ul>
<li>“=” : 赋值运算符</li>
<li>“()”: 函数调用运算符</li>
<li>“[]”: 下标运算符</li>
<li>“-&gt;”: 通过指针访问类成员的运算符</li>
</ul>
<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>友元有三种：</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ul>
<p><code>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限</code></p>
<h3 id="为什么要使用友元？"><a href="#为什么要使用友元？" class="headerlink" title="为什么要使用友元？"></a>为什么要使用友元？</h3><p>对于如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设类A实现了A operator +(int value);</span></span><br><span class="line">A b = a + <span class="number">3</span>;<span class="comment">//转换成a.operator+(3);</span></span><br><span class="line">A b = <span class="number">3</span> + a;<span class="comment">//因为3不是A类对象，编译器无法使用成员函数来替换该表达式</span></span><br></pre></td></tr></table></figure><br>使用友元函数可以解决这个问题</p>
<h3 id="创建友元函数"><a href="#创建友元函数" class="headerlink" title="创建友元函数"></a>创建友元函数</h3><p>创建友元函数的第一步是将其<code>原型放在类声明中</code>，并在原型声明前加上关键字friend</p>
<p>第二步编写函数定义，因为友元函数不是成员函数，所以<code>不要使用&quot;::&quot;限定符，且在定义中不要使用关键字friend</code></p>
<p>所以对于上面的这个问题，只需要实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">int</span> value, <span class="keyword">const</span> A &amp;a)</span><br></pre></td></tr></table></figure><br><code>注意：只有类声明可以决定哪一个函数是友元</code></p>
<h3 id="重载”-lt-lt-”运算符"><a href="#重载”-lt-lt-”运算符" class="headerlink" title="重载”&lt;&lt;”运算符"></a>重载”&lt;&lt;”运算符</h3><p>直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种重载方式</span></span><br><span class="line"><span class="keyword">void</span> opeartor&lt;&lt;(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种重载方式</span></span><br><span class="line"><span class="keyword">void</span> opeartor&lt;&lt;(ostream &amp;os) &#123;</span><br><span class="line">    os &lt;&lt; <span class="keyword">this</span>-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种重载方式</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">    os &lt;&lt; a.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这是定义同时也是实现，单独实现的时候不加friend</span></span><br></pre></td></tr></table></figure><br>对于上述代码1，你觉得可以这样使用吗？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;</span><br></pre></td></tr></table></figure><br>答案是不可以</p>
<p>对于上述代码2，调用的格式因该是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a &lt;&lt; <span class="built_in">cout</span>;</span><br></pre></td></tr></table></figure><br>很别扭是吧</p>
<p>第三种方式可以实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; a.data</span><br></pre></td></tr></table></figure><br>但是第三种方式有种缺憾，就是不可以这样调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a.data is&quot;</span> &lt;&lt; a.data &lt;&lt; <span class="string">&quot;and b.data is&quot;</span> &lt;&lt; b.data;</span><br></pre></td></tr></table></figure><br>解决方法——让第三种方式返回ostream对象的引用即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(osteam &amp;os, <span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">    os &lt;&lt; a.data;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="重载单操作数运算符"><a href="#重载单操作数运算符" class="headerlink" title="重载单操作数运算符"></a>重载单操作数运算符</h3><p>对于某些运算符既可以作单数运算符，又可以作为双操作数运算符。例如“-”既可以作为自反运算符，又可以作为减号操作符。<br>那么重载这种运算符的时候，作为单操作数运算符是不同于双操作运算符的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为成员函数的情况</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>-();<span class="comment">//用作单操作运算符</span></span><br><span class="line">return_type <span class="keyword">operator</span>-(parameter);<span class="comment">//用作双操作运算符</span></span><br></pre></td></tr></table></figure><br>有了上述成员函数的情况，作为非成员函数的情况就可以类推出来了</p>
<h4 id="重载-和—运算符"><a href="#重载-和—运算符" class="headerlink" title="重载++和—运算符"></a>重载++和—运算符</h4><p>++运算符和—运算符既可以做前缀可以做后缀，重载前缀++(—)和后缀++(—)的情况是不同的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>++();<span class="comment">//前缀++</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后缀++</span></span><br></pre></td></tr></table></figure><br><code>C++规定后缀形式有一个int类型的参数，但是这个参数永远不会用到，所以不必写参数名，也不要写这个参数名。</code></p>
<h3 id="运算符重载：作为成员函数还是非成员函数？"><a href="#运算符重载：作为成员函数还是非成员函数？" class="headerlink" title="运算符重载：作为成员函数还是非成员函数？"></a>运算符重载：作为成员函数还是非成员函数？</h3><p>前面说过运算符的重载可以通过成员函数或非成员函数进行重载，但是不能同时声明这两种格式，否则将造成二义性错误，导致编译错误。</p>
<p>对于某些运算符来说，成员函数是唯一合法的选择，例如前面说的”=”(赋值运算符)。有时，根据类设计，使用非成员函数版本可能更好（尤其是为类定义类型转换时）。其他情况下，这两种格式没有太大区别。</p>
<h3 id="可以对运算符重载再进行重载"><a href="#可以对运算符重载再进行重载" class="headerlink" title="可以对运算符重载再进行重载"></a>可以对运算符重载再进行重载</h3><p>例如对于”-“运算符，它既可以表示减法，也可以表示自反，那么就可以实现两种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以向量为例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    Vector(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector &amp;v) &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(x - v.x, y - v.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vecotor <span class="keyword">operator</span>-()&#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h1><p>在c++中，如果一个类有接受一个参数的构造函数，则c++支持将与该参数相同类型的值转换为类。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    A(<span class="keyword">int</span> data) : data(data) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>程序将使用构造函数A(10)来创建一个临时对象，并将19.6作为初始化值，然后将该临时对象复制到a中。这一过程称为隐式转换。</p>
<p>c++中新增了关键字explicit用于关闭这种自动特性<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> data)</span> : <span class="title">data</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="number">10</span>;<span class="comment">//报错，不能再隐式转换</span></span><br><span class="line">A a = (A) <span class="number">10</span>;<span class="comment">//仍然可以使用显示转换</span></span><br></pre></td></tr></table></figure><br><code>explicit关键字只有用来修饰单参数的构造函数才有意义</code></p>
<p><code>建议不要使用隐式转换，最好将单参数的构造函数都加上explicit关键字，使用强制类型转换</code></p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>上面的例子是将整型转换成A类型，同时转换函数可以让A类型转换成整型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> data)</span> : <span class="title">data</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">//b = 10</span></span><br></pre></td></tr></table></figure><br><code>声明转换函数注意以下几点</code>：</p>
<ul>
<li>转换函数必须是类方法</li>
<li>转换函数不能指定返回类型</li>
<li>转换函数不能有参数</li>
</ul>
<p>同时c++11及之后可以将explicit关键字用于转换函数，这样就只能进行强制类型转换而不能进行隐式类型转换</p>
<p><code>使用转换函数的原则</code>：<br>谨慎使用转换函数，最好使用功能相同的非转换函数，例如上例中完全可以实现一个int to_int();的成员方法来实现相同的功能。</p>
<h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><h4 id="static成员变量的声明及初始化"><a href="#static成员变量的声明及初始化" class="headerlink" title="static成员变量的声明及初始化"></a>static成员变量的声明及初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static成员变量初始化</span></span><br><span class="line"><span class="keyword">double</span> MyClass::d = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<p>一般不能在类声明中初始化静态成员变量，这是因为类声明只描述了如何分配内存，但不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句指出了类型，并使用了作用域运算符，<code>但没有使用关键字static</code>。</p>
<p><code>但是如果静态成员是const整型或const枚举型，则可以在类声明中初始化。</code></p>
<h4 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h4><ul>
<li>不能通过对象调用static成员函数，对于声明在共有部分的static成员函数，可以使用类名和作用域解析运算符来调用它。</li>
<li><code>static成员函数中不能使用this指针</code></li>
<li>static成员函数只能访问static成员变量</li>
</ul>
<h4 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h4><p>c++自动提供了下面这些成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数</li>
<li>默认析构函数，如果没有定义</li>
<li>复制(拷贝)构造函数，如果没有定义</li>
<li>赋值运算符(“=”)，如果没有定义</li>
<li>地址运算符(“&amp;”)，如果没有定义</li>
</ul>
<h5 id="复制-拷贝-构造函数"><a href="#复制-拷贝-构造函数" class="headerlink" title="复制(拷贝)构造函数"></a>复制(拷贝)构造函数</h5><p>复制构造函数用于将一个对象复制到新创建的对象中，也就是说，它用于初始化过程中。复制构造函数的原型通常如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;);</span><br></pre></td></tr></table></figure><br><code>调用复制构造函数的时机：</code></p>
<ul>
<li><code>新建一个对象并</code>将其初始化为同类对象时，复制(拷贝)构造函数都将被调用。</li>
<li>当函数按值传递对象或函数返回对象时(<code>返回引用则不会调用</code>)，都将使用复制(拷贝)构造函数</li>
</ul>
<p>默认的复制(拷贝)构造函数逐个复制非静态成员的值（即<code>浅拷贝</code>）</p>
<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>将已有对象赋值给另一个对象时，将使用重载的赋值运算符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass my_class_1;</span><br><span class="line">MyClass my_class_2 = my_class_1;<span class="comment">//使用复制(拷贝)构造函数，可能使用赋值运算符——可能先使用复制(拷贝)构造函数创建一个临时对象，然后使用赋值构造函数将这个临时对象赋值给my_class_2</span></span><br><span class="line">MyClass my_class_3;</span><br><span class="line">my_class_3 = my_class_1;<span class="comment">//使用赋值运算符</span></span><br></pre></td></tr></table></figure><br>同默认的复制(拷贝)构造函数一样，<code>默认的赋值运算函数也对成员进行逐个复制（浅拷贝）</code></p>
<p><code>编写赋值运算符函数的规范：</code></p>
<ul>
<li>由于目标对象可能引用了以前分配的数据，所以函数应使用delete或delete[]来释放这些数据</li>
<li>函数应当避免将对象赋给自身，首先这样做没有太大意义，并且，给对象重新赋值前，释放内存操作可能删除对象的内容(详见示例代码)</li>
<li>函数最后返回一个指向调用对象的引用，这是为了能够连续赋值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyClass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass &amp; my_class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;my_class) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放动态内存，如果有的话</span></span><br><span class="line">    <span class="comment">//如果没有上面的判断且this == &amp;my_class的话，那么 delete p也会将my_class中的p delete掉，那么下面的内存拷贝就会出错</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    data = my_class.data;</span><br><span class="line">    p = <span class="keyword">new</span> ...;<span class="comment">//重新分配动态内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用拷贝构造函数还是赋值运算符函数？"><a href="#调用拷贝构造函数还是赋值运算符函数？" class="headerlink" title="调用拷贝构造函数还是赋值运算符函数？"></a>调用拷贝构造函数还是赋值运算符函数？</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">my1</span><span class="params">(my2)</span></span>;<span class="comment">//只调用拷贝构造函数</span></span><br><span class="line">MyClass my1 = my2;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">MyClass my1;</span><br><span class="line">my1 = my2;<span class="comment">//调用赋值运算符函数</span></span><br></pre></td></tr></table></figure>
一般有新对象被创建时就会调用一个构造函数，可能就是拷贝构造函数</li>
</ul>
<h3 id="重载-运算符的一个技巧"><a href="#重载-运算符的一个技巧" class="headerlink" title="重载[]运算符的一个技巧"></a>重载[]运算符的一个技巧</h3><p>重载运算符最好能够返回引用，因为这样不仅能够使用”[index]”获取值，而且可以方便的为”[index]”处对应的值进行赋值。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i) <span class="keyword">const</span>;<span class="comment">//const成员函数返回一定是const char &amp;</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">char</span> c = str[<span class="number">1</span>];</span><br><span class="line">str[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//如果返回不是引用那么修改的就只是一个临时对象而已</span></span><br></pre></td></tr></table></figure><br>使用const版本的operator[]实现非const版本的operator[]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> MyClass&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第一次cast将<em>this转换成const MyClass&amp;类型，即为</em>this添加const，第二次则从const operator[]的返回值中移除const。<br><code>只能用const版本来实现非const版本，注意不要用非const版本来实现const版本。</code>是否需要const版本来实现非const版本取决于你自己。</p>
<h3 id="包含类成员的类的逐成员复制"><a href="#包含类成员的类的逐成员复制" class="headerlink" title="包含类成员的类的逐成员复制"></a>包含类成员的类的逐成员复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBigClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MySmallClass1 my_small_class1;</span><br><span class="line">MySmallClass2 my_small_class2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于MyBigClass而言，<code>默认的逐成员复制和赋值行为有一定的智能，逐成员复制或赋值将使用成员类型定义的复制(拷贝)构造函数和赋值运算符</code>。然而，如果MyBigClass有需要定义复制(拷贝)构造函数和赋值运算符函数，则最好重新为MyBigClass编写复制(拷贝)构造函数和赋值运算符函数。</p>
<h3 id="需要重新编写复制-拷贝-构造函数和赋值运算符函数的一种情况"><a href="#需要重新编写复制-拷贝-构造函数和赋值运算符函数的一种情况" class="headerlink" title="需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况"></a>需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况</h3><p>如果一个类的成员是需要动态内存分配的，那么这个类一般是在构造函数中动态申请内存，而在析构函数中一般会释放该动态内存。</p>
<p>因为默认复制(拷贝)构造函数和赋值运算符函数是浅拷贝，所以浅拷贝复制的只是指向动态内存的指针的值，当其中一个对象被释放掉了，其析构函数释放掉动态内存，那个另外一个对象也将不再拥有该动态分配的内存。</p>
<p>这时就应该为该类重新编写复制(拷贝)构造函数和赋值运算符函数，让其进行深拷贝，即重新申请内存，而不是简单的指针赋值。</p>
<h3 id="对于使用定位new运算符分配的动态对象"><a href="#对于使用定位new运算符分配的动态对象" class="headerlink" title="对于使用定位new运算符分配的动态对象"></a>对于使用定位new运算符分配的动态对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">MyClass *p1 = <span class="keyword">new</span> (buffer) MyClass;</span><br></pre></td></tr></table></figure>
<p>由于对于定位new运算符不能使用delete，所以，<code>对使用定义new运算符创建的对象，要显式的调用函数的析构函数</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1-&gt;~MyClass();</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure></p>
<h1 id="嵌套结构和类"><a href="#嵌套结构和类" class="headerlink" title="嵌套结构和类"></a>嵌套结构和类</h1><p>在类声明的结构、类或枚举被称为是嵌套在类中的，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是类的私有部分进行的，则只能在这个类使用被声明的类型，如果声明是在共有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类。</p>
<h1 id="成员初始化列表的语法"><a href="#成员初始化列表的语法" class="headerlink" title="成员初始化列表的语法"></a>成员初始化列表的语法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b) : mem1(a), mem2(b), mem3(a * b + <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员初始化列表格式只能用于构造函数</li>
<li><code>必须使用这个格式来初始化非静态const数据成员，即单const修饰的成员</code></li>
<li><code>必须用这种格式来初始化引用数据成员</code>（一般很少有引用数据成员，因为这种设计很不好）</li>
<li><code>当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序</code>。如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要了。</li>
</ul>
<p>成员初始化列表会覆盖类内初始化的成员的初始值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//类内初始化</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass() : a(<span class="number">10</span>)<span class="comment">//将会覆盖掉a，a=10</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="子类的初始化"><a href="#子类的初始化" class="headerlink" title="子类的初始化"></a>子类的初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BaseClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b) : a(a), b(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SubClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> c): BaseClass(a, b), c(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类的构造函数必须使用<code>相邻基类</code>的构造函数，<code>且只能使用成员初始化列表的方式</code>，创建派生类对象时，程序首先创建基类对象。如果不显示的调用基类的构造函数，程序将使用默认的基类构造函数(如果有的话，否则将会报错)</p>
<p>派生类对象过期时，程序将先调用派生类的析构函数，然后再调用基类析构函数</p>
<h3 id="在派生类成员函数中调用父类的方法"><a href="#在派生类成员函数中调用父类的方法" class="headerlink" title="在派生类成员函数中调用父类的方法"></a>在派生类成员函数中调用父类的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BaseClass::func();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在派生类成员函数中调用父类定义的方法是使用作用域解析运算符来调用的。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h3><p>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的条件下引用派生类对象，也可以将派生对象赋给基类对象（向上强制转换）。但是不可以将基类对象赋给派生类对象和派生类引用，不可以把基类对象地址赋给派生类对象指针（向下强制转换）</p>
<h3 id="虚函数-virtual-function-与多态实现"><a href="#虚函数-virtual-function-与多态实现" class="headerlink" title="虚函数(virtual function)与多态实现"></a>虚函数(virtual function)与多态实现</h3><p>如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用virtual，程序将根据引用或指针指向的具体对象的类型来选择方法<br>不使用virtual：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseClass base;</span><br><span class="line">SubClass sub;</span><br><span class="line">BaseClass *b1 = &amp;base;</span><br><span class="line">BaseClass *b2 = &amp;sub;</span><br><span class="line">b1-&gt;func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b2-&gt;func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">BaseClass &amp;b3 = base;</span><br><span class="line">BaseClass &amp;b4 = sub;</span><br><span class="line">b3.func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b4.func(); <span class="comment">// 使用 BaseClass::func()</span></span><br></pre></td></tr></table></figure><br>使用virtual关键字：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;<span class="comment">//只能对virtual方法标记override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseClass base;</span><br><span class="line">SubClass sub;</span><br><span class="line">BaseClass *b1 = &amp;base;</span><br><span class="line">BaseClass *b2 = &amp;sub;</span><br><span class="line">b1-&gt;func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b2-&gt;func(); <span class="comment">// 使用 SubClass::func()</span></span><br><span class="line">BaseClass &amp;b3 = base;</span><br><span class="line">BaseClass &amp;b4 = sub;</span><br><span class="line">b3.func(); <span class="comment">// 使用 BaseClass::func()</span></span><br><span class="line">b4.func(); <span class="comment">// 使用 SubClass::func()</span></span><br></pre></td></tr></table></figure><br>经常在基类中将派生类会重新定义的方法声明为虚方法，方法在基类中被声明为虚方法后，它在<code>所有派生类中</code>将<code>自动成为</code>虚方法。但是最好在派生类声明中使用virtual来指出哪些函数是虚函数，这可以增加程序的可读性</p>
<p><code>virtual关键字只用于类声明的方法原型中，而不用于方法实现中</code></p>
<h4 id="总结实现多态的方法"><a href="#总结实现多态的方法" class="headerlink" title="总结实现多态的方法"></a>总结实现多态的方法</h4><ul>
<li><code>公有继承</code>，因为只有公有继承是才允许将基类指针或基类引用指向派生类</li>
<li>成员函数要用virtual修饰</li>
<li>使用对象的引用或指针</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~BaseClass() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~SubClass() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseClass *p1 = <span class="keyword">new</span> BaseClass();</span><br><span class="line">BaseClass *p2 = <span class="keyword">new</span> SubClass();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，如果析构函数不是虚函数，当delete p2时，将只会调用基类的虚构函数。如果是虚析构函数，则当delete p2时，将会调用SubClass的析构函数。</p>
<p><code>所以，一般将类的析构函数定义为虚函数</code></p>
<h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。在程序运行时选择正确的函数代码块，被称为动态联编（dynamic binding），又称为晚期联编（late dinding）</p>
<p>为什么有两种类型的联编？：<br>由于动态联编需要采用一些方法来追踪基类指针或引用指向的对象类型，这增加了额外的开销，所以静态联编的效率比动态联编的效率高，因此<code>静态联编也被设置为c++的默认选择</code>。</p>
<h4 id="虚成员函数与动态联编"><a href="#虚成员函数与动态联编" class="headerlink" title="虚成员函数与动态联编"></a>虚成员函数与动态联编</h4><p>编译器会对非虚方法使用静态联编，对虚方法使用动态联编。但是由于动态联编需要额外开销，所以<code>对不需要重新定义的成员函数，不要将这些函数设置为虚函数</code>，这样有两种好处：首先效率更高；<code>其次，指出不要重新定义该函数</code>。仅将那些需要被重新定义的方法声明为虚的</p>
<h3 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a><code>虚函数的工作原理</code></h3><p>编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这个指针一般会成为对象的第一个数据成员。这个数组被称为<code>虚函数表</code>。虚函数表中存储了为类对象进行声明的虚函数的地址。无论类中包含的虚函数还是1个还是10个，都只需要在对象中添加一个地址成员，只是表的大小不同而已。<code>使用虚函数表也就是为了不增大类所占的内存，并加快函数查找速度</code><br><img src="/2020/11/20/c++/C++PrimerPlus/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/虚函数机制.jpg" alt="虚函数机制" style="zoom:25%;"></p>
<p>对于上图，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个<code>指向独立地址</code>的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，虚函数表将<code>保存函数原始版本的地址</code>。如果派生类定义了新的虚函数，则该函数的地址也将被添加到虚函数表中。</p>
<p>如果使用类声明中定义的第一个虚函数，则程序将使用数组 中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</p>
<h3 id="虚表指针初始化的时机"><a href="#虚表指针初始化的时机" class="headerlink" title="虚表指针初始化的时机"></a><code>虚表指针初始化的时机</code></h3><p>序表指针的初始化在进入类构造函数之前，<br>一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SubClass&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass s;</span><br></pre></td></tr></table></figure><br>最后打印的结构为“Base”，因为在进入s的构造函数之前，会先进行Base的构造，而在进入Base的构造函数之前，虚表指针被初始化为指向Base的虚函数表，所以这是执行虚函数调用的是父类的虚函数。当父类被构造完，进入自己的构造函数之前，虚表指针再被初始化为指向自己的虚函数表</p>
<h3 id="关于虚函数的注意事项"><a href="#关于虚函数的注意事项" class="headerlink" title="关于虚函数的注意事项"></a>关于虚函数的注意事项</h3><ul>
<li><code>构造函数不能是虚函数</code>，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。</li>
<li><code>析构函数最好设计成虚函数</code>，除非类不用做基类。也就是说即使基类不需要显示析构函数提供服务，也不应该依赖于默认析构函数，而应该提供析构函数，</li>
<li><code>友元不能是虚函数</code>，因为友元不是类成员，<code>而只有成员才能是虚函数。</code></li>
</ul>
<h1 id="在派生类中重新定义方法将隐藏方法"><a href="#在派生类中重新定义方法将隐藏方法" class="headerlink" title="在派生类中重新定义方法将隐藏方法"></a>在派生类中重新定义方法将隐藏方法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span> :</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不在继承类中重新定义showperks方法，则继承类中可以使用基类所有的showperks方法。但是重新定义将showperks()定义为一个不接受任何参数的函数。<code>重新定义不会生成函数的两个重载版本</code>，而是隐藏了接收一个int参数的基类版本。总之，<code>重新定义继承的方法并不是重载</code>。</p>
<p><code>这引出了两条经验准则</code>：<br>第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类应用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Dwelling &amp; <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span>:</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Hovel &amp; <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>注意这种例外只适用于返回值，而不适用于参数</code></p>
<p>第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本，或者使用<code>继承方法函数</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法1：重新定义所有的基类版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span>:</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法2：使用继承方法函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span>:</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Dwelling::showperks;<span class="comment">//can use all showperks now</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;<span class="comment">//还可以定义自己的showperks(double x)，而不使用基类的showperks(double x)。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span> <span class="keyword">const</span></span>;<span class="comment">//还可以定义其他的showperks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>如果派生类中只定义一个版本，则另外两个版本将被隐藏，派生对象将无法使用它们。如果不需要需要修改，则新定义可只调用基类版本</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hovel::showperks</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Dwelling::showperks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="当typedef出现在类定义的私有部分"><a href="#当typedef出现在类定义的私有部分" class="headerlink" title="当typedef出现在类定义的私有部分"></a>当typedef出现在类定义的私有部分</h1><p>则只有在类中使用，在类外和子类中不能使用</p>
<h1 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h1><p>使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，基类的私有成员子类无法访问。使用私有继承时，只能在派生类中访问基类的非私有成员及成员函数。</p>
<p><code>使用私有继承，不支持隐式向上转换(隐式向上转换：无需进行显示类型转换，就可以将基类指针或引用指向派生类对象)</code></p>
<h1 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h1><p>基类的公有成员和保护成员都将成为派生类的保护成员</p>
<h1 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h1><p>使用保护继承或私有继承时， 基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，方法之一是定义一个使用基类方法的派生类方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pri_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> protect BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pri_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一种方法是使用一个using声明，来指出派生类可以使用特定的基类成员，即使采用的是私有派生<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> <span class="keyword">private</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> BaseClass::pri_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>注意using声明只使用成员名——没有圆括号、函数特征标和返回类型。且using声明只适用于继承，而不适用于包含</code></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c-primer-plus/" rel="tag"># c++ primer plus</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/19/others/pytest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="pytest学习笔记">
      <i class="fa fa-chevron-left"></i> pytest学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/01/av_processing/%E8%A7%86%E9%A2%91/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/" rel="next" title="图像基础">
      图像基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%86%85%E5%AE%9A%E4%B9%89%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">类内定义的成员函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">类的构造函数和析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%8Ftips"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">构造函数的小tips</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%A6const%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">带const的类成员函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E6%9E%9A%E4%B8%BE"><span class="nav-number">6.</span> <span class="nav-text">作用域内枚举</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">7.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6%EF%BC%9A"><span class="nav-number">7.0.0.1.</span> <span class="nav-text">运算符重载限制：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">8.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8B%E5%85%83%EF%BC%9F"><span class="nav-number">8.0.1.</span> <span class="nav-text">为什么要使用友元？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">8.0.2.</span> <span class="nav-text">创建友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E2%80%9D-lt-lt-%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">8.0.3.</span> <span class="nav-text">重载”&lt;&lt;”运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%8D%95%E6%93%8D%E4%BD%9C%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">8.0.4.</span> <span class="nav-text">重载单操作数运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E5%92%8C%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">8.0.4.1.</span> <span class="nav-text">重载++和—运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%9A%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">8.0.5.</span> <span class="nav-text">运算符重载：作为成员函数还是非成员函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%AF%B9%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%86%8D%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD"><span class="nav-number">8.0.6.</span> <span class="nav-text">可以对运算符重载再进行重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">类的自动转换和强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">9.0.1.</span> <span class="nav-text">转换函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">10.</span> <span class="nav-text">类和动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">10.0.0.1.</span> <span class="nav-text">static成员变量的声明及初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">10.0.0.2.</span> <span class="nav-text">static成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">10.0.0.3.</span> <span class="nav-text">特殊成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6-%E6%8B%B7%E8%B4%9D-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.0.0.3.1.</span> <span class="nav-text">复制(拷贝)构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">10.0.0.3.2.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">10.0.0.3.3.</span> <span class="nav-text">调用拷贝构造函数还是赋值运算符函数？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8A%80%E5%B7%A7"><span class="nav-number">10.0.1.</span> <span class="nav-text">重载[]运算符的一个技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E7%9A%84%E9%80%90%E6%88%90%E5%91%98%E5%A4%8D%E5%88%B6"><span class="nav-number">10.0.2.</span> <span class="nav-text">包含类成员的类的逐成员复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E7%BC%96%E5%86%99%E5%A4%8D%E5%88%B6-%E6%8B%B7%E8%B4%9D-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">10.0.3.</span> <span class="nav-text">需要重新编写复制(拷贝)构造函数和赋值运算符函数的一种情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%BD%8Dnew%E8%BF%90%E7%AE%97%E7%AC%A6%E5%88%86%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.0.4.</span> <span class="nav-text">对于使用定位new运算符分配的动态对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">嵌套结构和类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">成员初始化列表的语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">13.</span> <span class="nav-text">子类的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">13.0.1.</span> <span class="nav-text">在派生类成员函数中调用父类的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">14.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E7%89%B9%E6%AE%8A%E5%85%B3%E7%B3%BB"><span class="nav-number">14.0.1.</span> <span class="nav-text">派生类和基类之间的特殊关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-virtual-function-%E4%B8%8E%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.0.2.</span> <span class="nav-text">虚函数(virtual function)与多态实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">14.0.2.1.</span> <span class="nav-text">总结实现多态的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">14.0.3.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="nav-number">14.0.4.</span> <span class="nav-text">静态联编和动态联编</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="nav-number">14.0.4.1.</span> <span class="nav-text">虚成员函数与动态联编</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">14.0.5.</span> <span class="nav-text">虚函数的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">14.0.6.</span> <span class="nav-text">虚表指针初始化的时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">14.0.7.</span> <span class="nav-text">关于虚函数的注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%E5%B0%86%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95"><span class="nav-number">15.</span> <span class="nav-text">在派生类中重新定义方法将隐藏方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93typedef%E5%87%BA%E7%8E%B0%E5%9C%A8%E7%B1%BB%E5%AE%9A%E4%B9%89%E7%9A%84%E7%A7%81%E6%9C%89%E9%83%A8%E5%88%86"><span class="nav-number">16.</span> <span class="nav-text">当typedef出现在类定义的私有部分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-number">17.</span> <span class="nav-text">私有继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="nav-number">18.</span> <span class="nav-text">保护继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8using%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">19.</span> <span class="nav-text">使用using重新定义访问权限</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SwordAndTea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwordAndTea</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
